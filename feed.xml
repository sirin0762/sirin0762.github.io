<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://sirin0762.gitbub.io/</id><title>Sirin0762</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-04-29T20:20:40+08:00</updated> <author> <name>sirin0762</name> <uri>https://sirin0762.gitbub.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://sirin0762.gitbub.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://sirin0762.gitbub.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 sirin0762 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>BOJ_9184 신나는 재귀함수 풀이</title><link href="https://sirin0762.gitbub.io/posts/BOJ9184/" rel="alternate" type="text/html" title="BOJ_9184 신나는 재귀함수 풀이" /><published>2022-04-29T20:17:29+08:00</published> <updated>2022-04-29T20:17:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/BOJ9184/</id> <content src="https://sirin0762.gitbub.io/posts/BOJ9184/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 백준 신나는 재귀함수 문제 링크 내 생각 주어진 재귀의 연산량이 너무 많기 때문에 메모이제이션을 통해 연산량을 줄여야합니다. 코드 package boj_9184; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays; public class Main { static int[][][] dp = new int[51][51][51]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(ne... </summary> </entry> <entry><title>BOJ_6603 로또 풀이</title><link href="https://sirin0762.gitbub.io/posts/BOJ6603/" rel="alternate" type="text/html" title="BOJ_6603 로또 풀이" /><published>2022-04-27T20:51:29+08:00</published> <updated>2022-04-27T20:51:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/BOJ6603/</id> <content src="https://sirin0762.gitbub.io/posts/BOJ6603/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 백준 퇴사 문제 링크 내 생각 주어진 집합에 대해서 6개의 수를 조합 방식으로 선별하는 문제입니다. 조합에 대해서 잘 모르신다면 n과m(2) 를 풀어보시는 것을 추천 드립니다. 코드 package boj_6603; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.StringTokenizer; public class Main { static int k; static final int LOTTO_COUNT = 6; public static void main(String[] args) throws IOException { ... </summary> </entry> <entry><title>BOJ_4963 섬의 갯수 풀이</title><link href="https://sirin0762.gitbub.io/posts/BOJ4963/" rel="alternate" type="text/html" title="BOJ_4963 섬의 갯수 풀이" /><published>2022-04-14T20:00:29+08:00</published> <updated>2022-04-27T20:59:25+08:00</updated> <id>https://sirin0762.gitbub.io/posts/BOJ4963/</id> <content src="https://sirin0762.gitbub.io/posts/BOJ4963/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 백준 섬의 갯수 문제 링크 내 생각 섬을 기준으로 주위 1칸에 섬이 있는 경우, 연결되었다고 보기 때문에, 해당 조건을 이용하여 BFS로 문제를 풀이 하면 됩니다. 코드 package boj_4963; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.LinkedList; import java.util.Queue; import java.util.StringTokenizer; class Node { int x; int y; public Node(int x, int y) { this.x = x; this.y ... </summary> </entry> <entry><title>BOJ_14501 퇴사 풀이</title><link href="https://sirin0762.gitbub.io/posts/BOJ14501/" rel="alternate" type="text/html" title="BOJ_14501 퇴사 풀이" /><published>2022-04-14T20:00:29+08:00</published> <updated>2022-04-14T20:00:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/BOJ14501/</id> <content src="https://sirin0762.gitbub.io/posts/BOJ14501/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 백준 퇴사 문제 링크 내 생각 DFS를 통한 완전탐색으로 풀었습니다. 로직은 다음과 같습니다. dfs로 t[i]와 p[i]를 계속해서 더해줍니다. day &amp;gt;= n 이 되면 정답을 구하고 백트래킹합니다. 일반적인 백트래킹과 다른 점은 이 경우, t[0] &amp;gt; n 인 경우, 곧바로 return이 되어 정답이 0으로 나와버립니다. 따라서 곧바로 return 되지 않게 초기 day는 0으로 넣어주고, dfs 마지막에 dfs(day + 1, cost) 를 통해서, t[0] &amp;gt; n 이더라도 dfs가 진행되도록 했습니다. dfs 메서드의 마지막 라인인 dfs(day + 1, cost) 를 빼고 다음과 같은 반례를 넣으시면 이해가 될듯합니다. 2 ... </summary> </entry> <entry><title>BOJ_4948 베르트랑 공존 풀이</title><link href="https://sirin0762.gitbub.io/posts/BOJ4948/" rel="alternate" type="text/html" title="BOJ_4948 베르트랑 공존 풀이" /><published>2022-04-13T19:27:29+08:00</published> <updated>2022-04-13T19:27:29+08:00</updated> <id>https://sirin0762.gitbub.io/posts/BOJ4948/</id> <content src="https://sirin0762.gitbub.io/posts/BOJ4948/" /> <author> <name>sirin0762</name> </author> <category term="algorithm" /> <category term="java" /> <summary> 문제 백준 베르트랑 공존 문제 링크 내 생각 주어진 n ~ 2n 사이의 소수를 구하는 문제입니다. 저는 다음과 같은 논리로 해결했습니다. 주어진 입력의 max가 123,456 이므로 그에 2배의 길이 + 1의 배열을 준비해줍니다. 아리스토테네스의 체를 이용하여 소수가 아닌 것을 분간해냅니다. 입력으로 주어진 사이의 소수들의 개수를 새어서 출력합니다. 코드 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; public class Main { static int[] prime; static int n = 246_913; public static v... </summary> </entry> </feed>
