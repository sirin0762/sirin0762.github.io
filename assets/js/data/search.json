[ { "title": "BOJ_9184 신나는 재귀함수 풀이", "url": "/posts/BOJ9184/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-29 20:17:29 +0800", "snippet": "문제백준 신나는 재귀함수 문제 링크내 생각주어진 재귀의 연산량이 너무 많기 때문에 메모이제이션을 통해 연산량을 줄여야합니다.코드package boj_9184;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { static int[][][] dp = new int[51][51][51]; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); while (true) { int[] numbers = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); if (isFinish(numbers)) { break; } System.out.println(&quot;w(&quot; + numbers[0] + &quot;, &quot; + numbers[1] + &quot;, &quot; + numbers[2] + &quot;) = &quot; + recursion(numbers[0], numbers[1], numbers[2])); } } private static int recursion(int a, int b, int c) { if (a &amp;lt;= 0 || b &amp;lt;= 0 || c &amp;lt;= 0) { return 1; } if (dp[a][b][c] != 0) { return dp[a][b][c]; } if (a &amp;gt; 20 || b &amp;gt; 20 || c &amp;gt; 20) { dp[20][20][20] = recursion(20, 20, 20); return dp[20][20][20]; } if (a &amp;lt; b &amp;amp;&amp;amp; b &amp;lt; c) { dp[a][b][c - 1] = recursion(a, b, c - 1); dp[a][b - 1][c - 1] = recursion(a, b - 1, c - 1); dp[a][b - 1][c] = recursion(a, b - 1, c); return dp[a][b][c - 1] + dp[a][b - 1][c - 1] - dp[a][b - 1][c]; } dp[a - 1][b][c] = recursion(a - 1, b, c); dp[a - 1][b - 1][c] = recursion(a - 1, b - 1, c); dp[a - 1][b][c - 1] = recursion(a - 1, b, c - 1); dp[a - 1][b - 1][c - 1] = recursion(a - 1, b - 1, c - 1); return dp[a - 1][b][c] + dp[a - 1][b - 1][c] + dp[a - 1][b][c - 1] - dp[a - 1][b - 1][c - 1]; } private static boolean isFinish(int[] numbers) { return numbers[0] == -1 &amp;amp;&amp;amp; numbers[1] == -1 &amp;amp;&amp;amp; numbers[2] == -1; }}" }, { "title": "BOJ_6603 로또 풀이", "url": "/posts/BOJ6603/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-27 20:51:29 +0800", "snippet": "문제백준 퇴사 문제 링크내 생각주어진 집합에 대해서 6개의 수를 조합 방식으로 선별하는 문제입니다.조합에 대해서 잘 모르신다면 n과m(2) 를 풀어보시는 것을 추천 드립니다.코드package boj_6603;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { static int k; static final int LOTTO_COUNT = 6; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); while (true) { StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); k = Integer.parseInt(st.nextToken()); if (isFinish(k)) { break; } int[] arr = new int[k]; for (int i = 0; i &amp;lt; k; i++) { arr[i] = Integer.parseInt(st.nextToken()); } combination(arr, new int[LOTTO_COUNT], 0, 0); System.out.println(&quot;&quot;); } } private static void combination(int[] arr, int[] output, int depth, int start) { if (depth == LOTTO_COUNT) { for (int o : output) { System.out.print(o + &quot; &quot;); } System.out.println(&quot;&quot;); return; } for (int i = start; i &amp;lt; k; i++) { output[depth] = arr[i]; combination(arr, output, depth + 1, i + 1); } } private static boolean isFinish(int k) { return k == 0; }}" }, { "title": "BOJ_4963 섬의 갯수 풀이", "url": "/posts/BOJ4963/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-14 20:00:29 +0800", "snippet": "문제백준 섬의 갯수 문제 링크내 생각섬을 기준으로 주위 1칸에 섬이 있는 경우, 연결되었다고 보기 때문에, 해당 조건을 이용하여 BFS로 문제를 풀이 하면 됩니다.코드package boj_4963;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class Node { int x; int y; public Node(int x, int y) { this.x = x; this.y = y; }}public class Main { static int[] dx = {-1, 1, 0, 0, -1, -1, 1, 1}; static int[] dy = {0, 0, -1, 1, 1, -1, 1, -1}; static int n, m; static int[][] map; static boolean[][] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); while (true) { StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); m = Integer.parseInt(st.nextToken()); n = Integer.parseInt(st.nextToken()); if (isFinish(n, m)) { break; } int answer = 0; map = new int[n][m]; visited = new boolean[n][m]; for (int i = 0; i &amp;lt; n; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int j = 0; j &amp;lt; m; j++) { map[i][j] = Integer.parseInt(st.nextToken()); } } for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (map[i][j] == 1 &amp;amp;&amp;amp; !visited[i][j]) { answer++; bfs(i, j); } } } System.out.println(answer); } } private static boolean isFinish(int n, int m) { return n == 0 &amp;amp;&amp;amp; m == 0; } private static void bfs(int x, int y) { Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(x, y)); visited[x][y] = true; while (!q.isEmpty()) { Node node = q.poll(); x = node.x; y = node.y; for (int i = 0; i &amp;lt; 8; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if (nx &amp;lt; 0 || nx &amp;gt;= n || ny &amp;lt; 0 || ny &amp;gt;= m) { continue; } if (map[nx][ny] == 1 &amp;amp;&amp;amp; !visited[nx][ny]) { q.offer(new Node(nx, ny)); visited[nx][ny] = true; } } } }}" }, { "title": "BOJ_14501 퇴사 풀이", "url": "/posts/BOJ14501/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-14 20:00:29 +0800", "snippet": "문제백준 퇴사 문제 링크내 생각DFS를 통한 완전탐색으로 풀었습니다. 로직은 다음과 같습니다. dfs로 t[i]와 p[i]를 계속해서 더해줍니다. day &amp;gt;= n 이 되면 정답을 구하고 백트래킹합니다. 일반적인 백트래킹과 다른 점은 이 경우, t[0] &amp;gt; n 인 경우, 곧바로 return이 되어 정답이 0으로 나와버립니다. 따라서 곧바로 return 되지 않게 초기 day는 0으로 넣어주고, dfs 마지막에 dfs(day + 1, cost) 를 통해서, t[0] &amp;gt; n 이더라도 dfs가 진행되도록 했습니다. dfs 메서드의 마지막 라인인 dfs(day + 1, cost) 를 빼고 다음과 같은 반례를 넣으시면 이해가 될듯합니다. 2 3 100 2 10 코드package boj_14501;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { static int n; static int[] t, p; static int answer = 0; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); t = new int[n]; p = new int[n]; for (int i = 0; i &amp;lt; n; i++) { StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); t[i] = Integer.parseInt(st.nextToken()); p[i] = Integer.parseInt(st.nextToken()); } dfs(0, 0); System.out.println(answer); } private static void dfs(int day, int cost) { if (day &amp;gt;= n) { answer = Math.max(answer, cost); return; } if (day + t[day] &amp;lt;= n) { dfs(day + t[day], cost + p[day]); } else { dfs(day + t[day], cost); } dfs(day + 1, cost); }}" }, { "title": "BOJ_4948 베르트랑 공존 풀이", "url": "/posts/BOJ4948/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-13 19:27:29 +0800", "snippet": "문제백준 베르트랑 공존 문제 링크내 생각주어진 n ~ 2n 사이의 소수를 구하는 문제입니다. 저는 다음과 같은 논리로 해결했습니다. 주어진 입력의 max가 123,456 이므로 그에 2배의 길이 + 1의 배열을 준비해줍니다. 아리스토테네스의 체를 이용하여 소수가 아닌 것을 분간해냅니다. 입력으로 주어진 사이의 소수들의 개수를 새어서 출력합니다.코드import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static int[] prime; static int n = 246_913; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); calculateAllPrime(); while (true) { int target = Integer.parseInt(br.readLine()); if (target == 0) break; System.out.println(getPrimeBetweenArgs(target, target * 2)); } } private static int getPrimeBetweenArgs(int start, int end) { int count = 0; for (int i = start + 1; i &amp;lt;= end ; i++) { if (prime[i] != 0) count++; } return count; } private static void calculateAllPrime() { prime = new int[n]; for (int i = 2; i &amp;lt; n; i++) { prime[i] = i; } for (int i = 2; i &amp;lt; n; i++) { if(prime[i] == 0) continue; for (int j = 2 * i; j &amp;lt;= n; j += i) { prime[j] = 0; } } }}" }, { "title": "BOJ_11053 가장 긴 증가하는 부분 수열 풀이", "url": "/posts/BOJ11053/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-12 18:46:29 +0800", "snippet": "문제백준 가장 긴 증가하는 부분 수열 문제 링크내 생각통칭 LIS 라고 불리는 문제입니다. dp의 방식을 이용합니다. 모든 위치의 부분수열의 길이를 1로 둔 뒤(자기자신), 앞에서 부터 자기 자신 보다 작은 크기를 가진 숫자의 수열 중, 가장 긴 것 + 1을 자신의 수열길이로 하여 나아가면됩니다. private static int calculateLIS(int target) { // 이미 수열의 길이는 모두 1로 초기화 int max = 0; // 자기 자신보다 작은 크기를 가진 값의 수열의 길이 중 최대값을 찾음 for (int i = target - 1; i &amp;gt;= 0; i--) { if (seq[target] &amp;gt; seq[i]) { max = Math.max(max, dp[i]); } } return max; }코드package boj_11053;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { static int n; static int[] seq, dp; public static void main(String[] args) throws IOException { inputData(); int answer = 0; for (int i = 0; i &amp;lt; n; i++) { dp[i] = calculateLIS(i) + 1; answer = Math.max(dp[i], answer); } System.out.println(answer); } private static int calculateLIS(int target) { int max = 0; for (int i = target - 1; i &amp;gt;= 0; i--) { if (seq[target] &amp;gt; seq[i]) { max = Math.max(max, dp[i]); } } return max; } private static void inputData() throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); seq = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); dp = new int[n]; Arrays.fill(dp, 1); }}" }, { "title": "BOJ_2644 촌수 계산 풀이", "url": "/posts/BOJ2644/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-11 18:42:29 +0800", "snippet": "문제백준 촌수 계산 문제 링크내 생각주어진 문제는 graph를 통해서 해당 target을 찾아가는 문제입니다. bfs, dfs 두가지 방법 모두 다 가능하지만 저는 dfs로 해결했습니다.코드package boj_2644;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.StringTokenizer;public class Main { static int n, m; static int targetStart, targetEnd; static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; graph = new ArrayList&amp;lt;&amp;gt;(); static boolean[] visited; static int answer = -1; public static void main(String[] args) throws IOException { inputData(); calculateKinship(targetStart, 0); System.out.println(answer); } private static void calculateKinship(int start, int depth) { if (start == targetEnd) { answer = depth; return; } for (int i = 0; i &amp;lt; graph.get(start).size(); i++) { int next = graph.get(start).get(i); if(!visited[next]) { visited[next] = true; calculateKinship(next, depth + 1); } } } private static void inputData() throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt;= n; i++) { graph.add(new ArrayList&amp;lt;&amp;gt;()); } visited = new boolean[n + 1]; StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); targetStart = Integer.parseInt(st.nextToken()); targetEnd = Integer.parseInt(st.nextToken()); m = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; m; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int start = Integer.parseInt(st.nextToken()); int end = Integer.parseInt(st.nextToken()); graph.get(start).add(end); graph.get(end).add(start); } }}" }, { "title": "BOJ_1931 회의실 배정 풀이", "url": "/posts/BOJ1931/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-06 19:19:29 +0800", "snippet": "문제백준 회의실 배정 문제 링크내 생각이러한 문제를 활동 선택 문제 라고 합니다. 한 사람이 하나의 활동에 대해서만 작업할 수 있을 떄, 최대한 많은 행동을 할 수 있는 수를 선택하는 문제입니다. 해당 유형의 문제들은 그리드 유형으로, 겹치지 않는 활동들에 대해서 독립적이라는 것입니다. 종료시간 기준으로 정렬하여 직전 종료 시간 &amp;lt; 다음 시작 시간 일 경우에 counting을 해주는 것으로 문제 풀이가 가능합니다.코드package boj_1931;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[][] times = new int[n][2]; for (int i = 0; i &amp;lt; n; i++) { StringTokenizer st = new StringTokenizer(br.readLine()); times[i][0] = Integer.parseInt(st.nextToken()); times[i][1] = Integer.parseInt(st.nextToken()); } Arrays.sort(times, (o1, o2) -&amp;gt; { if(o1[1] == o2[1]) { return o1[0] - o2[0]; } return o1[1] - o2[1]; }); int count = 0; int prev_end_time = 0; for (int i = 0; i &amp;lt; n; i++) { if(prev_end_time &amp;lt;= times[i][0]) { prev_end_time = times[i][1]; count++; } } System.out.println(count); }}" }, { "title": "BOJ_16953 A -&gt; B 풀이", "url": "/posts/BOJ16953/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-05 20:16:29 +0800", "snippet": "문제백준 A -&amp;gt; B 문제 링크내 생각A -&amp;gt; B 로 가는 2가지 연산을 백트래킹을 이용하여 완전 탐색 했습니다.코드package boj_16953;import java.io.BufferedReader;import java.io.InputStreamReader;import java.util.Scanner;public class Main { static int answer = Integer.MAX_VALUE; public static void main(String[] args) { Scanner sc = new Scanner(System.in); long a = sc.nextLong(); long b = sc.nextLong(); getCountConvertAtoB(a, b, 1); System.out.println(answer != Integer.MAX_VALUE ? answer : -1); } private static void getCountConvertAtoB(long a, long b, int depth) { if (a == b) { answer = Math.min(answer, depth); return; } if (a &amp;gt; b) { return; } getCountConvertAtoB(a &amp;lt;&amp;lt; 1, b, depth + 1); getCountConvertAtoB(a * 10 + 1, b, depth + 1); }}" }, { "title": "BOJ_1927 최소 힙 풀이", "url": "/posts/BOJ1927/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-04 20:52:29 +0800", "snippet": "문제백준 최소 힙 문제 링크내 생각힙에 대해서 아는지, 그리고 힙을 쓸 줄 아는지를 물어보는 힙의 기초문제입니다. 자바의 경우 PriorityQueue를 통해 힙 자료구조를 이용할 수 있습니다.코드package boj_1927;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.PriorityQueue;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); PriorityQueue&amp;lt;Integer&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); int n = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; n; i++) { int input = Integer.parseInt(br.readLine()); if (input == 0) { printQueueElement(pq); } else { pq.offer(input); } } } private static void printQueueElement(PriorityQueue&amp;lt;Integer&amp;gt; pq) { if (pq.isEmpty()) { System.out.println(0); } else { System.out.println(pq.poll()); } }}" }, { "title": "BOJ_1912 연속합 풀이", "url": "/posts/BOJ1912/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-02 20:30:29 +0800", "snippet": "문제백준 연속합 문제 링크내 생각주어진 수열의 연속합을 구하는 방법은 다음과 같습니다. 앞에서 부터 숫자를 더합니다. 이 때 (앞에서 부터 더한 숫자 + 현재 위치의 숫자)와 현재 위치의 숫자를 비교하여 큰 것이 현재 위치에서의 가장 큰 연속합입니다. 각각의 위치의 연속합 중에 가장 큰 값을 정답으로 출력합니다.이를 위해서는 각각의 연속합을 저장하고 있는 배열이 필요합니다.코드package boj_1912;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] sequence = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); int[] dp = new int[n]; dp[0] = sequence[0]; int answer = dp[0]; for (int i = 1; i &amp;lt; n; i++) { dp[i] = Math.max(dp[i - 1] + sequence[i], sequence[i]); answer = Math.max(answer, dp[i]); } System.out.println(answer); }}" }, { "title": "BOJ_1780 종이의 개수 풀이", "url": "/posts/BOJ1780/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-04-01 12:29:29 +0800", "snippet": "문제백준 종이의 개수 문제 링크내 생각주어진 3의 n승인 배열을 재귀를 통해서 3으로 나누면서 진행하면 됩니다. 예를 들어 길이가 9 * 9인 배열이라면, x축과 y축을 각각 3으로 나누면서 재귀를 진행하되, 각 단계마다 종이의 개수를 샐수 있는가(해당 영역이 모두 같은 숫자인가)를판단하면 됩니다.코드package boj_1780;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { static int n; static int[] countOfPaper = new int[3]; static int[][] map; public static void main(String[] args) throws IOException { inputData(new BufferedReader(new InputStreamReader(System.in))); countPaper(0, n, 0, n); for (int i = 0; i &amp;lt; countOfPaper.length; i++) { System.out.println(countOfPaper[i]); } } private static void countPaper(int x1, int x2, int y1, int y2) { if(isCountable(x1, x2, y1, y2)) { countOfPaper[map[x1][y1] + 1]++; return; } int nextValueOfX = (x2 - x1) / 3; int nextValueOfY = (y2 - y1) / 3; for (int i = x1; i &amp;lt; x2; i += nextValueOfX) { for (int j = y1; j &amp;lt; y2; j += nextValueOfY) { countPaper(i, i + nextValueOfX, j, j + nextValueOfY); } } } private static boolean isCountable(int x1, int x2, int y1, int y2) { if(x2 - x1 == 1 &amp;amp;&amp;amp; y2 - y1 == 1) { return true; } int standard = map[x1][y1]; for (int i = x1; i &amp;lt; x2; i++) { for (int j = y1; j &amp;lt; y2; j++) { if(map[i][j] != standard) return false; } } return true; } private static void inputData(BufferedReader br) throws IOException { n = Integer.parseInt(br.readLine()); inputDataInMap(br); } private static void inputDataInMap(BufferedReader br) throws IOException { map = new int[n][n]; for (int i = 0; i &amp;lt; n; i++) { StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int j = 0; j &amp;lt; n; j++) { map[i][j] = Integer.parseInt(st.nextToken()); } } }}" }, { "title": "BOJ_7569 토마토 풀이", "url": "/posts/BOJ7569/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-30 12:29:29 +0800", "snippet": "문제백준 토마토 문제 링크내 생각 3차원 배열을 통한 BFS 문제입니다. dx, dy, dz 배열을 통해서 주어진 토마토를 기점으로 바이러스 처럼 퍼트리면 됩니다. bfs 는 한단계만 이루어지므로 시간에 따라서 토마토를 익게하는 것이 포인트입니다. 아래 코드의 경우에는 2개의 큐를 통해서 해당 부분을 해결했습니다.코드package boj_7569;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class Coordinate { private final int height; private final int row; private final int column; public Coordinate(int height, int row, int column) { this.height = height; this.row = row; this.column = column; } public int getHeight() { return height; } public int getRow() { return row; } public int getColumn() { return column; }}public class Main { static int n, m, h; static int[][][] warehouse; static boolean[][][] visited; static Queue&amp;lt;Coordinate&amp;gt; todayQueue = new LinkedList&amp;lt;&amp;gt;(); static Queue&amp;lt;Coordinate&amp;gt; tomorrowQueue = new LinkedList&amp;lt;&amp;gt;(); static int[] dx = {-1, 1, 0, 0, 0, 0}; static int[] dy = {0, 0, -1, 1, 0, 0}; static int[] dz = {0, 0, 0, 0, -1, 1}; public static void main(String[] args) throws IOException { inputData(new BufferedReader(new InputStreamReader(System.in))); int elapsedDays = 0; while(!todayQueue.isEmpty()) { ripeTomatoes(); todayQueue = tomorrowQueue; tomorrowQueue = new LinkedList&amp;lt;&amp;gt;(); elapsedDays++; } System.out.println(isEveryTomatoRipe() ? elapsedDays - 1 : -1); } private static boolean isEveryTomatoRipe() { for (int i = 0; i &amp;lt; h; i++) { for (int j = 0; j &amp;lt; n; j++) { for (int k = 0; k &amp;lt; m; k++) { if (warehouse[i][j][k] == 0) { return false; } } } } return true; } private static void ripeTomatoes() { while (!todayQueue.isEmpty()) { Coordinate coord = todayQueue.poll(); int z = coord.getHeight(); int x = coord.getRow(); int y = coord.getColumn(); bfs(z, x, y); } } private static void bfs(int z, int x, int y) { visited[z][x][y] = true; for (int i = 0; i &amp;lt; 6; i++) { int nz = z + dz[i]; int nx = x + dx[i]; int ny = y + dy[i]; if(isOutOfRange(nz, nx, ny)) continue; if(warehouse[nz][nx][ny] == 0 &amp;amp;&amp;amp; !visited[nz][nx][ny]) { visited[nz][nx][ny] = true; warehouse[nz][nx][ny] = 1; tomorrowQueue.offer(new Coordinate(nz, nx, ny)); } } } private static boolean isOutOfRange(int z, int x, int y) { return z &amp;gt;= h || z &amp;lt; 0 || x &amp;gt;= n || x &amp;lt; 0 || y &amp;gt;= m || y &amp;lt; 0; } private static void inputData(BufferedReader input) throws IOException { inputWarehouseSize(input.readLine()); inputWarehouseInfo(input); inputVisited(); } private static void inputWarehouseInfo(BufferedReader input) throws IOException { warehouse = new int[h][n][m]; for (int i = 0; i &amp;lt; n * h; i++) { inputWarehouseInfo(input.readLine(), i % n, i / n); } } private static void inputWarehouseInfo(String oneLayerOfWarehouseInfo, int row, int level) { StringTokenizer st = new StringTokenizer(oneLayerOfWarehouseInfo, &quot; &quot;); for (int i = 0; i &amp;lt; m; i++) { warehouse[level][row][i] = Integer.parseInt(st.nextToken()); if(warehouse[level][row][i] == 1) { todayQueue.offer(new Coordinate(level, row, i)); } } } private static void inputWarehouseSize(String warehouseSize) { StringTokenizer st = new StringTokenizer(warehouseSize, &quot; &quot;); m = Integer.parseInt(st.nextToken()); n = Integer.parseInt(st.nextToken()); h = Integer.parseInt(st.nextToken()); } private static void inputVisited() { visited = new boolean[h][n][m]; }}" }, { "title": "BOJ_1541 잃어버린 괄호 풀이", "url": "/posts/BOJ1541/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-28 19:56:29 +0800", "snippet": "문제백준 잃어버린 괄호 문제 링크내 생각주어진 식의 최솟값을 구하는 방법은 - 연산자를 시작으로 다음 - 연산자 까지의 모든 수를 합하면 됩니다. 예를 들어 주어진 식이 50-45+30-20+20 이라면 최솟값은 50-(45+30)-(20+20) = -65 로, - 연산자 사이에 괄호를 넣어주면 됩니다.이 때 정규 표현식에서 사용하는 positive lookaround 를 알면 좋은데, 이는 대상 문자열을 포함한 상태에서 문자열 파싱하게 해주기 때문입니다.예를 들어 ‘50-50-50’ 을 split(‘-‘)을 할 경우, [‘50’, ‘50’, ‘50’] 이 나오게 되는데, 만약 lookaround 문법인 split(‘(?=[-])’) 를 한다면 [‘50’, ‘-50’, ‘-50’] 으로 구분자인 ‘-‘ 를 앞에 포함시킨채로 문자열을 잘라주기 때문에 이후 계산에서 용이합니다.코드package boj_1541;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] expressions = br.readLine().split(&quot;(?=[-])&quot;); System.out.println(calculateMinValue(expressions)); } private static int calculateMinValue(String[] expressions) { int result = 0; for (String e : expressions) { char sign = e.charAt(0); if(sign == &#39;-&#39;) result -= sumToInt(e.substring(1).split(&quot;\\\\+&quot;)); else result += sumToInt(e.split(&quot;\\\\+&quot;)); } return result; } private static int sumToInt(String[] arr) { return Arrays.stream(arr).mapToInt(Integer::parseInt).sum(); }}" }, { "title": "BOJ_1012 유기농 배추 풀이", "url": "/posts/BOJ1012/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-25 13:44:29 +0800", "snippet": "문제백준 유기농 배추 문제 링크내 생각주어진 map을 순회하며 배추벌레가 필요한 영역을 계산하면 됩니다. 만약 배추가 있다면 이미 왔던 곳 : 아무런 조치를 해줄 필요가 없습니다. 처음 온 곳 : 해당 영역에는 배추벌레가 필요하므로 answer += 1을 해주고 해당 지점을 시작으로 bfs를 돌려 해당 영역을 visited = true로 만들어줍니다. 코드package boj_1012;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class Node { private int x; private int y; public Node(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; }}public class Main { static int n, m, k; static int[][] map; static boolean[][] visited; static int[] dx = {-1, 1, 0, 0}; static int[] dy = {0, 0, 1, -1}; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int t = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; t; i++) { inputData(br); int answer = calculateWarms(); System.out.println(answer); } } private static int calculateWarms() { int result = 0; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if(map[i][j] == 1 &amp;amp;&amp;amp; !visited[i][j]) { bfs(i, j); result++; } } } return result; } private static void inputData(BufferedReader br) throws IOException { String[] split = br.readLine().split(&quot; &quot;); m = Integer.parseInt(split[0]); n = Integer.parseInt(split[1]); k = Integer.parseInt(split[2]); map = new int[n][m]; visited = new boolean[n][m]; for (int i = 0; i &amp;lt; k; i++) { StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); int x = Integer.parseInt(st.nextToken()); int y = Integer.parseInt(st.nextToken()); map[y][x] = 1; } } private static void bfs(int x, int y) { Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(x, y)); visited[x][y] = true; while (!q.isEmpty()) { Node now = q.poll(); x = now.getX(); y = now.getY(); for (int i = 0; i &amp;lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;gt;= n || nx &amp;lt; 0 || ny &amp;gt;= m || ny &amp;lt; 0) continue; if(map[nx][ny] == 1 &amp;amp;&amp;amp; !visited[nx][ny]) { q.offer(new Node(nx, ny)); visited[nx][ny] = true; } } } }}" }, { "title": "BOJ_11439 ATM 풀이", "url": "/posts/BOJ11439/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-24 11:48:29 +0800", "snippet": "문제백준 ATM 문제 링크내 생각그리디 유형으로, 주어진 앞사람의 시간을 줄이는 것이 관건입니다. 배열 오름차순 정렬을 통해서 시간을 기다리는 로직을 수행하면 됩니다.코드package boj_11399;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] arr = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); Arrays.sort(arr); int answer = 0; for (int i = 0; i &amp;lt; n; i++) { answer += arr[i] * (n - i); } System.out.println(answer); }}" }, { "title": "BOJ_2805 나무자르기 풀이", "url": "/posts/BOJ2805/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-23 20:34:29 +0800", "snippet": "문제백준 나무자르기 문제 링크내 생각절단기에서 잘린 나무의 길이를 토대로 이분 탐색을 하면됩니다. 이 떄, 절단기의 높이를 최대로 하는 방향의 UPPER_BOUND가 필요합니다.코드package boj_2805;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] input = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(input[0]); int m = Integer.parseInt(input[1]); long max = 0; int[] trees = new int[n]; StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 0; i &amp;lt; n; i++) { trees[i] = Integer.parseInt(st.nextToken()); max = Math.max(max, trees[i]); } long left = 0; long right = max; while(left &amp;lt;= right) { long mid = (left + right) / 2; long cutLength = getTreeLength(mid, trees); if(cutLength &amp;lt; m) { right = mid - 1; } else { left = mid + 1; } } System.out.println(right); } private static long getTreeLength(long pos, int[] trees) { long result = 0; for (int tree : trees) { if (tree &amp;gt; pos){ result += (tree - pos); } } return result; }}" }, { "title": "BOJ_20436 ZOAC 3 풀이", "url": "/posts/BOJ20436/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-22 20:18:29 +0800", "snippet": "문제백준 ZOAC 3 문제 링크내 생각주어진 키보드를 각각 leftKeyMap, rightKeyMap 이라는 Map을 이용하여, &amp;lt;키, 키위치&amp;gt; 로 미리 데이터를 넣어놨습니다. 그 후, 주어진 문자열을 순회하며 해당 키에 맞는 map으로 이동하여 거리 산출을 하는 로직으로 만들었습니다.코드package boj_20436;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;import java.util.Map;class Node { private int x; private int y; public Node(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; }}public class Main { static Map&amp;lt;Character, Node&amp;gt; leftKeyMap = new HashMap&amp;lt;&amp;gt;(); static Map&amp;lt;Character, Node&amp;gt; rightKeyMap = new HashMap&amp;lt;&amp;gt;(); static char sl, sr; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] input = br.readLine().split(&quot; &quot;); sl = input[0].charAt(0); sr = input[1].charAt(0); inputKeyMap(); System.out.println(calculateMinValue(br.readLine())); } private static int calculateMinValue(String str) { int result = 0; for (char c : str.toCharArray()) { if(leftKeyMap.containsKey(c)) { result += getDistance(sl, c, leftKeyMap); sl = c; } else { result += getDistance(sr, c, rightKeyMap); sr = c; } result++; } return result; } private static int getDistance(char c1, char c2, Map&amp;lt;Character, Node&amp;gt; map) { Node origin = map.get(c1); Node other = map.get(c2); return Math.abs(origin.getX() - other.getX()) + Math.abs(origin.getY() - other.getY()); } private static void inputKeyMap() { inputLeftKeyMap(); inputRightKeyMap(); } private static void inputRightKeyMap() { rightKeyMap.put(&#39;b&#39;, new Node(0, 4)); rightKeyMap.put(&#39;n&#39;, new Node(0, 5)); rightKeyMap.put(&#39;m&#39;, new Node(0, 6)); rightKeyMap.put(&#39;h&#39;, new Node(1, 5)); rightKeyMap.put(&#39;j&#39;, new Node(1, 6)); rightKeyMap.put(&#39;k&#39;, new Node(1, 7)); rightKeyMap.put(&#39;l&#39;, new Node(1, 8)); rightKeyMap.put(&#39;y&#39;, new Node(2, 5)); rightKeyMap.put(&#39;u&#39;, new Node(2, 6)); rightKeyMap.put(&#39;i&#39;, new Node(2, 7)); rightKeyMap.put(&#39;o&#39;, new Node(2, 8)); rightKeyMap.put(&#39;p&#39;, new Node(2, 9)); } private static void inputLeftKeyMap() { leftKeyMap.put(&#39;z&#39;, new Node(0, 0)); leftKeyMap.put(&#39;x&#39;, new Node(0, 1)); leftKeyMap.put(&#39;c&#39;, new Node(0, 2)); leftKeyMap.put(&#39;v&#39;, new Node(0, 3)); leftKeyMap.put(&#39;a&#39;, new Node(1, 0)); leftKeyMap.put(&#39;s&#39;, new Node(1, 1)); leftKeyMap.put(&#39;d&#39;, new Node(1, 2)); leftKeyMap.put(&#39;f&#39;, new Node(1, 3)); leftKeyMap.put(&#39;g&#39;, new Node(1, 4)); leftKeyMap.put(&#39;q&#39;, new Node(2, 0)); leftKeyMap.put(&#39;w&#39;, new Node(2, 1)); leftKeyMap.put(&#39;e&#39;, new Node(2, 2)); leftKeyMap.put(&#39;r&#39;, new Node(2, 3)); leftKeyMap.put(&#39;t&#39;, new Node(2, 4)); }}" }, { "title": "BOJ_2108 통계학 풀이", "url": "/posts/BOJ2108/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-21 21:20:29 +0800", "snippet": "문제백준 통계학 문제 링크내 생각주어진 조건들을 구현하면 되는 문제입니다. 다만 최빈값에서 Counting 정렬을 이용할 경우 시간 단축을 할 수 있습니다.코드package boj_2108;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.Map;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] arr = new int[n]; for (int i = 0; i &amp;lt; n; i++) { arr[i] = Integer.parseInt(br.readLine()); } System.out.println(getAvg(arr)); System.out.println(getCenterValue(arr)); System.out.println(getFrequentValue(arr)); System.out.println(getDiffMinMax(arr)); } private static int getDiffMinMax(int[] arr) { Arrays.sort(arr); return arr[arr.length - 1] - arr[0]; } private static int getFrequentValue(int[] arr) { Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); int result = 0; for (int a : arr) { if(map.containsKey(a)) { map.put(a, map.get(a) + 1); } else { map.put(a, 1); } result = Math.max(result, map.get(a)); } List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for(int key : map.keySet()) { if(map.get(key) == result) { list.add(key); } } Collections.sort(list); if(list.size() &amp;gt; 1) { return list.get(1); } else { return list.get(0); } } private static int getCenterValue(int[] arr) { Arrays.sort(arr); return arr[arr.length / 2]; } private static int getAvg(int[] arr) { return (int) Math.round(Arrays.stream(arr).average().getAsDouble()); }}" }, { "title": "BOJ_2003 바이러스 풀이", "url": "/posts/BOJ2606/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-18 20:07:29 +0800", "snippet": "문제백준 바이러스 문제 링크내 생각바이러스가 간선을 타고 이동하므로, 주어진 입력을 통해 graph를 구성하고 bfs or dfs 등의 그래프 탐색을 통해서 1번 컴퓨터로부터 감염된 컴퓨터의 개수를 구하면 됩니다.코드package boj_2606;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;import java.util.List;import java.util.Queue;class Node { private int index; private int distance; public Node(int index, int distance) { this.index = index; this.distance = distance; } public int getIndex() { return index; } public int getDistance() { return distance; }}public class Main { static List&amp;lt;List&amp;lt;Node&amp;gt;&amp;gt; GRAPH = new ArrayList&amp;lt;&amp;gt;(); static boolean[] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int edgeCnt = Integer.parseInt(br.readLine()); visited = new boolean[n + 1]; for (int i = 0; i &amp;lt;= n; i++) { GRAPH.add(new ArrayList&amp;lt;&amp;gt;()); } for (int i = 0; i &amp;lt; edgeCnt; i++) { int[] split = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); GRAPH.get(split[0]).add(new Node(split[1], 1)); GRAPH.get(split[1]).add(new Node(split[0], 1)); } System.out.println(bfs(1)); } private static int bfs(int start) { Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(start, 0)); visited[start] = true; int count = 0; while (!q.isEmpty()) { Node node = q.poll(); for (int i = 0; i &amp;lt; GRAPH.get(node.getIndex()).size(); i++) { Node next = GRAPH.get(node.getIndex()).get(i); if(!visited[next.getIndex()]) { q.offer(next); visited[next.getIndex()] = true; count++; } } } return count; }}" }, { "title": "BOJ_2003 수들의 합2 풀이", "url": "/posts/BOJ2003/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-16 18:40:29 +0800", "snippet": "문제백준 수들의 합2 문제 링크내 생각투 포인터를 통해서 접근해야합니다.주어진 수열을 left, right 2개의 변수를 통해서 배열의 범위를 구하고, 해당 배열의 범위 전체 값과 target의 값을 비교하여, target == 배열의 범위 값 : count++, left++ target &amp;gt; 배열의 전체 값 : right++ target &amp;lt; 배열의 전체 값 : left++위의 로직대로 left, right을 점진적으로 증가시켜나갑니다.코드package boj_2003;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int[] split = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); int n = split[0]; int m = split[1]; int[] arr = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); System.out.println(countSameSequenceAmount(arr, m)); } private static int countSameSequenceAmount(int[] arr, int target) { int result = 0; int left = 0; int right = 1; while (right &amp;lt;= arr.length) { int summary = Arrays.stream(Arrays.copyOfRange(arr, left, right)).sum(); if(summary == target) { result++; left++; } else if(summary &amp;gt; target) { left++; } else { right++; } } return result; }}" }, { "title": "BOJ_2217 로프 풀이", "url": "/posts/BOJ2217/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-15 08:46:29 +0800", "snippet": "문제백준 로프 문제 링크내 생각로프가 견딜 수 있는 최대 무게를 찾는 문제입니다. 다음 과정으로 해결했습니다. 주어진 로프를 오름 차순 정렬합니다. 로프 배열을 앞에서 부터 순회합니다. 이 때, 견딜 수 있는 최대 무게 = 해당 로프의 최대 무게 * (전체 로프의 개수 - 해당 로프의 인덱스) 입니다. 로프마다의 최대 무게를 비교하며 답을 얻어냅니다.코드public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] lopes = new int[n]; for (int i = 0; i &amp;lt; n; i++) { lopes[i] = Integer.parseInt(br.readLine()); } Arrays.sort(lopes); System.out.println(findMaxWeight(lopes)); } private static int findMaxWeight(int[] lopes) { int result = 0; for (int i = 0; i &amp;lt; lopes.length; i++) { result = Math.max(result, lopes[i] * (lopes.length - i)); } return result; }}" }, { "title": "BOJ_1966 프린터 큐 풀이", "url": "/posts/BOJ1966/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-14 18:53:29 +0800", "snippet": "문제백준 프린터 큐 문제 링크내 생각구현 문제입니다. 주어진 문제의 조건을 분석하면, 프린터 큐에서 원소를 뽑는다. 해당 원소이면 종료한다. 해당 원소가 아니라면 다음 두가지에 의해 분기된다 우선 순위가 가장 높다면 그대로 빼면된다. 우선 순위가 가장 높지 않다면 다시 큐에 집어넣는다. 이렇게 논리가 전개되게끔 코드를 짜야합니다.코드package boj_1966;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.Collections;import java.util.LinkedList;import java.util.Queue;class Node { int priority; boolean isTarget; public Node(int priority, boolean isTarget) { this.priority = priority; this.isTarget = isTarget; }}public class Main { static int count; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int t = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; t; i++) { catchTarget(br); System.out.println(count); } } private static void catchTarget(BufferedReader br) throws IOException { String[] split = br.readLine().split(&quot; &quot;); count = 0; int n = Integer.parseInt(split[0]); int target = Integer.parseInt(split[1]); int targetPriority = 0; Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); Integer[] priorities = new Integer[n]; split = br.readLine().split(&quot; &quot;); for (int i = 0; i &amp;lt; n; i++) { int priority = Integer.parseInt(split[i]); priorities[i] = priority; if(i == target) { q.offer(new Node(priority, true)); targetPriority = priority; } else { q.offer(new Node(priority, false)); } } Arrays.sort(priorities, Collections.reverseOrder()); int priorityIndex = 0; while(!q.isEmpty()) { Node node = q.poll(); if(node.isTarget &amp;amp;&amp;amp; priorities[priorityIndex] == targetPriority) { count++; return; } if(node.priority != priorities[priorityIndex]) { q.offer(node); } else { count++; priorityIndex++; } } }}" }, { "title": "BOJ_2579 계단 오르기 풀이", "url": "/posts/BOJ2579/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-12 19:47:29 +0800", "snippet": "문제백준 계단 오르기 문제 링크내 생각계단의 최대값은 계단의 최대값을 저장한 배열 dp와 계단의 값을 나타낸 steps 배열을 이용하여 다음과 같은 점화식에 의해 정의 될 수 있습니다. dp[n] = Math.max(dp[n - 3] + steps[i], dp[n - 2]) + steps[n]; 코드 package boj_2579;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] steps = new int[n + 1]; int[] dp = new int[n + 1]; for (int i = 1; i &amp;lt;= n; i++) { steps[i] = Integer.parseInt(br.readLine()); } dp[1] = steps[1]; if(n &amp;gt;= 2) { dp[2] = steps[1] + steps[2]; } for (int i = 3; i &amp;lt;= n; i++) { dp[i] = Math.max(dp[i - 2] , dp[i - 3] + steps[i - 1]) + + steps[i]; } System.out.println(dp[n]); }}" }, { "title": "BOJ_1904 01타일 풀이", "url": "/posts/BOJ1904/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-11 09:37:29 +0800", "snippet": "문제백준 01타일 문제 링크내 생각n = 1 부터 점차적으로 늘려나가면 결국 피보나치 수열인게 보입니다. n은 1,000,000 까지 가능하기 때문에 dp를 통한 메모이제이션을 할 떄, 각 값을 15746으로 나눠서 저장하는 것이 포인트입니다.코드package boj_1904;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); if(n == 1) { System.out.println(1); return; } if(n == 2) { System.out.println(2); return; } int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &amp;lt;= n; i++) { dp[i] = (dp[i - 2] + dp[i - 1]) % 15746; } System.out.println(dp[n]); }}" }, { "title": "BOJ_1074 Z 풀이", "url": "/posts/BOJ1074/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-10 10:36:29 +0800", "snippet": "문제백준 Z 문제 링크내 생각재귀를 통해서 문제를 해결해야합니다. 각 depth 마다 R, C의 위치가 4개의 사분면 중 어디인지를 판단하여 그에 맞게 이동하며 count를 증가시켜야합니다. R &amp;lt; size &amp;amp;&amp;amp; C &amp;lt; size : 1사분면입니다. count는 올릴 필요 없습니다. R &amp;gt;= size &amp;amp;&amp;amp; C &amp;lt; size : 2사분면입니다. count += (size * size) / 4 입니다. R &amp;lt; size &amp;amp;&amp;amp; C &amp;gt;= size : 3사분면입니다. count += ((size * size) / 4) * 2 입니다. R &amp;gt;= size &amp;amp;&amp;amp; C &amp;gt;= size : 4사분면입니다. count += ((size * size) / 4) * 3 입니다.코드package boj_1074;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static int count; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); int N = Integer.parseInt(split[0]); int R = Integer.parseInt(split[1]); int C = Integer.parseInt(split[2]); count = 0; searchZ((int) Math.pow(2, N), R, C); System.out.println(count); } private static void searchZ(int size, int R, int C) { if (size == 1) { return; } if (R &amp;lt; size / 2 &amp;amp;&amp;amp; C &amp;lt; size / 2) { searchZ(size / 2, R, C); } else if(R &amp;lt; size / 2 &amp;amp;&amp;amp; C &amp;gt;= size / 2) { count += (size * size / 4); searchZ(size / 2, R, C - size / 2); } else if(R &amp;gt;= size / 2 &amp;amp;&amp;amp; C &amp;lt; size / 2) { count += (size * size / 4) * 2; searchZ(size / 2, R - size / 2, C); } else { count += (size * size / 4) * 3; searchZ(size / 2, R - size / 2, C - size / 2); } }}" }, { "title": "BOJ_1894 스택 수열 풀이", "url": "/posts/BOJ1874/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-09 17:07:29 +0800", "snippet": "문제백준 스택 수열 문제 링크내 생각Stack의 Push와 Pop을 사용하여 문제를 구현해야 합니다. 자세한 로직은 다음과 같습니다. 주어진 target 만큼 stack에 푸시하면서 + 를 StringBuilder에 넣어줍니다. 이 때, stack에 들어가는 수는 boolean 배열을 통해서 한번만 들어가게 합니다. pop = target 이 될 때까지 pop 하면서 - 를 StringBuilder에 넣어줍니다. 이 때, stack이 비었다면 구현이 불가능한 경우이므로 NO를 StringBuilder에 넣습니다. StringBuilder 내의 NO가 있을 경우 NO를, 없을 경우 구현 결과를 출력합니다.코드package boj_1874;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;public class Main { static boolean[] visited; static Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); static StringBuilder sb = new StringBuilder(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); visited = new boolean[n + 1]; String result = calculate(br, n); if (result.contains(&quot;NO&quot;)) { System.out.println(&quot;NO&quot;); } else { System.out.println(result); } } private static String calculate(BufferedReader br, int n) throws IOException { for (int i = 0; i &amp;lt; n; i++) { int target = Integer.parseInt(br.readLine()); pushStack(target); popStack(target); } return sb.toString(); } private static void popStack(int target) { while (true) { if(stack.isEmpty()) { sb.append(&quot;NO&quot;); break; } int pop = stack.pop(); sb.append(&quot;-&quot;).append(&quot;\\n&quot;); if(pop == target) { break; } } } private static void pushStack(int target) { for (int i = 1; i &amp;lt;= target; i++) { if(!visited[i]){ stack.push(i); sb.append(&quot;+&quot;).append(&quot;\\n&quot;); visited[i] = true; } } }}답안허나 위의 풀이의 경우, visited를 통한 조건 검색이 이루어지기 때문에 성능이 느립니다. push한 원소의 마지막 위치를 저장해서 성능을 올리도록 합시다.package boj_1874;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringBuilder sb = new StringBuilder(); Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); int N = Integer.parseInt(br.readLine()); // push한 마지막 원소 위치 저장 int start = 0; while(N-- &amp;gt; 0) { int target = Integer.parseInt(br.readLine()); if(target &amp;gt; start) { for (int i = start + 1; i &amp;lt;= target; i++) { stack.push(i); sb.append(&quot;+&quot;).append(&quot;\\n&quot;); } start = target; } else if(stack.peek() != target) { System.out.println(&quot;NO&quot;); return; } stack.pop(); sb.append(&quot;-&quot;).append(&quot;\\n&quot;); } System.out.println(sb); }}" }, { "title": "BOJ_2110 공유기 설치 풀이", "url": "/posts/BOJ2110/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-08 10:14:29 +0800", "snippet": "문제백준 공유기 설치 문제 링크내 생각이분탐색 문제입니다. 공유기 거리를 이분탐색의 대상으로 하여 문제를 해결 할 수 있습니다. 핵심 아이디어는 다음과 같습니다. start = 1, end = 두 집 사이의 가장 긴 거리로 초기화 합니다. 이분탐색을 진행하며 나오는 mid 값으로 house 위치를 순회하며 공유기 설치가 가능하다면 count를 해줍니다. 해당 count 값으로 이분탐색을 반복합니다.코드package boj_2110;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(split[0]); int c = Integer.parseInt(split[1]); int[] housePos = new int[n]; for (int i = 0; i &amp;lt; n; i++) { housePos[i] = Integer.parseInt(br.readLine()); } Arrays.sort(housePos); System.out.println(getMaxRouterLength(housePos, c)); } private static int getMaxRouterLength(int[] housePos, int c) { int start = 1; int end = housePos[housePos.length - 1] - housePos[0]; int result = 0; while(start &amp;lt;= end) { int mid = (start + end) / 2; if(isPossible(housePos, c, mid)) { start = mid + 1; result = mid; } else { end = mid - 1; } } return result; } private static boolean isPossible(int[] housePos, int c, int distance) { int count = 1; int lastLocate = housePos[0]; for (int i = 1; i &amp;lt; housePos.length; i++) { int locate = housePos[i]; if(locate - lastLocate &amp;gt;= distance) { count++; lastLocate = locate; } } return count &amp;gt;= c; }}" }, { "title": "BOJ_1654 렌선 자르기 풀이", "url": "/posts/BOJ1654/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-08 08:26:29 +0800", "snippet": "문제백준 렌선 자르기 문제 링크내 생각이분탐색 문제로, 몇가지를 주의하면 풀 수 있다. upper_bound 풀이를 통해서 렌선이 n개일 때의 최대 렌선 길이가 나오게 while문 내부를 만들어야한다. 주어진 렌선 길이의 최대값이 Integer.MAX_VALUE 이므로 start + end 연산시 overflow가 발생할 수 있다. 따라서 계산시 사용하는 변수들은 long타입으로 계산한다. 코드 ```javapackage boj_1654; // 1. start = 0, end = max_value 로 하여 이분 탐색을 시작한다.// 2. N은 같은데 길이가 Max인 경우는 어떻게 구해야할까? -&amp;gt; upper_bound// 3. 렌선의 Max 길이가 정수의 가장 큰 수 인점 -&amp;gt; Overflow 방지를 위해서 long 형으로 계산import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {static int k, n;public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); k = Integer.parseInt(split[0]); n = Integer.parseInt(split[1]); int[] lines = new int[k]; for (int i = 0; i &amp;lt; k; i++) { lines[i] = Integer.parseInt(br.readLine()); } System.out.println(getMaxLineLength(lines));}private static long getMaxLineLength(int[] lines) { long start = 1; long end = Integer.MAX_VALUE; long result = 0; while (start &amp;lt;= end) { long mid = (start + end) / 2; int cutCount = 0; for (int i = 0; i &amp;lt; k; i++) { cutCount += lines[i] / mid; } if (cutCount &amp;lt; n) { end = mid - 1; } else { start = mid + 1; result = mid; } } return result;}}```" }, { "title": "BOJ_1406 에디터 풀이", "url": "/posts/BOJ1406/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-03 09:08:29 +0800", "snippet": "문제백준 에디터 문제 링크내 생각구현 문제이다. 주어진 문제를 읽고, 해당하는 명령어 대로 커서를 조작하여 연산하면 된다.코드처음에는 StringBuilder 와 cursor 변수를 통해서 문제를 풀었다. 로직은 맞았으나 시간초과가 발생했다. 아래는 시간초과가 난 코드이다.package BOJ_1406;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class Main { static int cursor; static StringBuilder sb; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); sb = new StringBuilder(br.readLine()); int m = Integer.parseInt(br.readLine()); cursor = sb.length(); for (int i = 0; i &amp;lt; m; i++) { String[] split = br.readLine().split(&quot; &quot;); command(split); } bw.write(sb.toString()); bw.flush(); bw.close(); } private static void command(String[] command) { switch (command[0]) { case &quot;L&quot; : { if(cursor &amp;gt; 0) cursor--; break; } case &quot;D&quot; : { if(cursor &amp;lt; sb.length()) cursor++; break; } case &quot;B&quot; : { if(cursor &amp;gt; 0) { sb.deleteCharAt(cursor - 1); cursor--; } break; } case &quot;P&quot; : { sb.insert(cursor, command[1]); cursor++; break; } } }}다음은 커서 위치를 기준으로 좌 우를 각각 Stack으로 저장하여 푸는 예제이다(정답). L : rightCursor.push(leftCursor.pop()); D : leftCursor.push(rightCursor.pop()); B : leftCursor.pop(); D : leftCursor.push(command.charAt(2));package BOJ_1406;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Stack;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String str = br.readLine(); Stack&amp;lt;Character&amp;gt; leftCursor = new Stack&amp;lt;&amp;gt;(); Stack&amp;lt;Character&amp;gt; rightCursor = new Stack&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; str.length(); i++) { leftCursor.push(str.charAt(i)); } int m = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; m; i++) { String command = br.readLine(); switch (command.charAt(0)) { case &#39;L&#39;: { if (leftCursor.isEmpty()) break; rightCursor.push(leftCursor.pop()); break; } case &#39;D&#39;: { if (rightCursor.isEmpty()) break; leftCursor.push(rightCursor.pop()); break; } case &#39;B&#39;: { if (leftCursor.isEmpty()) break; leftCursor.pop(); break; } case &#39;P&#39;: { leftCursor.push(command.charAt(2)); break; } } } StringBuilder sb = new StringBuilder(); while (!leftCursor.isEmpty()) { rightCursor.push(leftCursor.pop()); } while (!rightCursor.isEmpty()) { sb.append(rightCursor.pop()); } System.out.println(sb); }}" }, { "title": "BOJ_1003 피보나치 함수 풀이", "url": "/posts/BOJ1003/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-03 08:47:29 +0800", "snippet": "문제백준 피보나치 함수 문제 링크내 생각피보나치 함수 중, n = 1 or n = 0 이 호출 되는 숫자를 새면 되는 문제이다. 처음에는 0과 1을 모두 순회 하면서 풀어야한다고 생각하여 재귀로 짰으나, 시간초과가 발생했다. 이 문제가 실버 3인 이유는 0과 1을 카운트 하되, DP를 이용해야해서 실버 3이 아닌가 싶다.코드다음은 재귀로 짜서 시간초과가 난 코드이다.package boj_1003;import java.util.Scanner;public class Main { static int zeroCnt, oneCnt; public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); for (int i = 0; i &amp;lt; t; i++) { int n = sc.nextInt(); zeroCnt = 0; oneCnt = 0; fibonacci(n); System.out.println(zeroCnt + &quot; &quot; + oneCnt); } } private static int fibonacci(int n) { if(n == 0) { zeroCnt++; return 0; } if(n == 1) { oneCnt++; return 1; } return fibonacci(n - 1) + fibonacci(n - 2); }}다음은 DP를 통해서 통과된 코드이다.package boj_1003;import java.util.Scanner;class Node { private int zeroCnt; private int oneCnt; public Node(int zeroCnt, int oneCnt) { this.zeroCnt = zeroCnt; this.oneCnt = oneCnt; } public int getZeroCnt() { return zeroCnt; } public int getOneCnt() { return oneCnt; } @Override public String toString() { final StringBuilder sb = new StringBuilder(); sb.append(zeroCnt).append(&quot; &quot;); sb.append(oneCnt); return sb.toString(); }}public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); for (int i = 0; i &amp;lt; t; i++) { int n = sc.nextInt(); System.out.println(fibonacci(n)); } } private static Node fibonacci(int n) { if(n == 0) return new Node(1, 0); if(n == 1) return new Node(0, 1); Node[] dp = new Node[n + 1]; dp[0] = new Node(1, 0); dp[1] = new Node(0, 1); for (int i = 2; i &amp;lt;= n; i++) { int zeroCnt = dp[i - 2].getZeroCnt() + dp[i - 1].getZeroCnt(); int oneCnt = dp[i - 2].getOneCnt() + dp[i - 1].getOneCnt(); dp[i] = new Node(zeroCnt, oneCnt); } return dp[n]; }}" }, { "title": "BOJ_1764 카드 2 풀이", "url": "/posts/BOJ2164/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-02 19:31:29 +0800", "snippet": "문제백준 카드 2 문제 링크내 생각주어진 카드를 제거하고, 뒤에서 붙이는 것은 FIFO의 방식이므로 Queue를 통해서 구현할 수 있다.코드package boj_2164;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); for (int i = 1; i &amp;lt;= n; i++) { q.add(i); } while(q.size() != 1) { q.poll(); q.offer(q.poll()); } System.out.println(q.peek()); }}" }, { "title": "BOJ_1764 듣보잡 풀이", "url": "/posts/BOJ1764/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-02 10:47:29 +0800", "snippet": "문제백준 듣보잡 문제 링크내 생각듣도 못한 사람과 보도 못한 사람의 교집합을 구하는 문제이다. 주어진 문자열을 빠르게 찾기 위하여 Hash가 적용된 HashSet을 이용하되, 듣도 보도 못한 사람을 저장하는 Set은 순서 보장을 위해 TreeSet을 사용했다.코드package boj_1764;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashSet;import java.util.Set;import java.util.TreeSet;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); Set&amp;lt;String&amp;gt; noSee = new HashSet&amp;lt;&amp;gt;(); Set&amp;lt;String&amp;gt; noSeeNoHear = new TreeSet&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; n; i++) { noSee.add(br.readLine()); } for (int i = 0; i &amp;lt; m; i++) { String noHear = br.readLine(); if(noSee.contains(noHear)) noSeeNoHear.add(noHear); } System.out.println(noSeeNoHear.size()); noSeeNoHear.forEach(System.out::println); }}추가TreeSet 부분의 경우 입력으로 들어갈때마다 정렬되기 때문에 List에 한 번에 다 넣은 뒤 정렬하는 방법에 비해 느릴꺼라 생각했는데, 실험 한 결과, 속도는 비슷하다." }, { "title": "BOJ_1065 한수 풀이", "url": "/posts/BOJ1065/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-02 10:31:29 +0800", "snippet": "문제백준 한수 문제 링크내 생각1 부터 N 까지의 수 중에서 각 자리수가 등차수열을 이루는 수를 찾는 문제이다.코드package boj_1065;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int answer = 0; for (int i = 1; i &amp;lt;= n; i++) { if(isArithmeticSequence(String.valueOf(i))) answer++; } System.out.println(answer); } private static boolean isArithmeticSequence(String str) { if(str.length() == 1) return true; int diff = str.charAt(1) - str.charAt(0); for (int i = 0; i &amp;lt; str.length() - 1; i++) { if(str.charAt(i + 1) - str.charAt(i) != diff) return false; } return true; }}답안ascii 코드 값 차이와는 다른 방식으로, 100의 자리, 10의 자리, 1의 자리 값을 구하여 a - b == b - c 꼴로 문제를 푸는 경우도 있었다. 속도를 측정해보니 비슷한 속도가 나온다." }, { "title": "BOJ_1026 보물 풀이", "url": "/posts/BOJ1026/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-02 10:01:29 +0800", "snippet": "문제백준 보물 문제 링크내 생각배열 A와 배열 B의 원소 곱의 최솟값을 묻는 문제이다. 배열 B는 고정되어 있으므로, 배열 A를 정렬하여 배열 A의 원소 최솟값 * 배열 B의 원소 최대값을 더하는 방식으로 풀 수 있다.코드package boj_1026;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;class MaxElement { private int index; private int value; public MaxElement(int index, int value) { this.index = index; this.value = value; } public int getIndex() { return index; } public int getValue() { return value; }}public class Main { static boolean[] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] a = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); int[] b = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); // B에 동일 값을 가진 원소가 존재할 수 있으므로 구분하기 위한 1차원 배열 visited = new boolean[b.length]; // a의 최솟값을 구하기 위해 정렬 후 앞에서부터 하나씩 사용 Arrays.sort(a); int answer = 0; for (int aElement : a) { MaxElement bMaxElement = getMaxElement(b); visited[bMaxElement.getIndex()] = true; answer += aElement * bMaxElement.getValue(); } System.out.println(answer); } private static MaxElement getMaxElement(int[] arr) { int maxValue = Integer.MIN_VALUE; int index = -1; for (int i = 0; i &amp;lt; arr.length; i++) { if(maxValue &amp;lt; arr[i] &amp;amp;&amp;amp; !visited[i]) { maxValue = arr[i]; index = i; } } return new MaxElement(index, maxValue); }}답안문제에서 B는 고정되어있다 했지만, 사실 두 배열의 곱의 최솟값을 구하면 되는 문제이기 때문에 배열 A는 오름차순, 배열 B는 내림차순으로 정렬하여 같은 인덱스끼리 곱해주면 된다.public class Main { static boolean[] visited; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int[] a = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); Integer[] b = Arrays.stream(br.readLine().split(&quot; &quot;)).map(Integer::parseInt).toArray(Integer[]::new); Arrays.sort(a); Arrays.sort(b, Collections.reverseOrder()); int answer = 0; for (int i = 0; i &amp;lt; a.length; i++) { answer += a[i] * b[i]; } System.out.println(answer); }}" }, { "title": "BOJ_1021 회전하는 큐 풀이", "url": "/posts/BOJ1021/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-01 20:23:29 +0800", "snippet": "문제백준 회전하는 큐 문제 링크내 생각Deque을 활용하여 2번과 3번연산을 하는 것이 핵심이다. Deque의 size() / 2 를 기점으로 2번연산을 할지, 3번 연산을 할지 정해야한다. targetIdx &amp;lt;= size() / 2 - 1 : 2번연산 targetIdx &amp;gt; size() / 2 - 1 : 3번연산코드package boj_1021;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.LinkedList;public class Main { static int n, m; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); n = Integer.parseInt(split[0]); m = Integer.parseInt(split[1]); int answer = 0; LinkedList&amp;lt;Integer&amp;gt; deque = new LinkedList&amp;lt;&amp;gt;(); for (int i = 1; i &amp;lt;= n; i++) { deque.add(i); } int[] arr = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); for (int target : arr) { int targetIdx = deque.indexOf(target); int halfIdx; if (deque.size() % 2 == 0) { halfIdx = deque.size() / 2 - 1; } else { halfIdx = deque.size() / 2; } if (targetIdx &amp;lt;= halfIdx) { for (int i = 0; i &amp;lt; targetIdx; i++) { int temp = deque.pollFirst(); deque.offerLast(temp); answer++; } } else { for (int i = 0; i &amp;lt; deque.size() - targetIdx; i++) { int temp = deque.pollLast(); deque.offerFirst(temp); answer++; } } deque.pollFirst(); } System.out.println(answer); }}" }, { "title": "BOJ_1002 터렛 풀이", "url": "/posts/BOJ1002/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-03-01 10:41:29 +0800", "snippet": "문제백준 터렛 문제 링크내 생각조규현의 좌표와 r1을 이용한 원, 백승환의 좌표와 r2를 이용한 원의 접점을 구하는 문제이다. 접점은 다음과 경우에 생기게 된다. (r1 - r2) ^ 2 &amp;lt; (x2 - x1) ^ 2 + (y2 - y1) ^ 2 &amp;lt; (r1 + r2) ^ 2 : 2개의 접점 (x2 - x1) ^ 2 + (y2 - y1) ^ 2 = (r1 + r2) ^ 2 : 1개의 접점(외접) (x2 - x1) ^ 2 + (y2 - y1) ^ 2 = (r1 - r2) ^ 2 : 1개의 접점(내접) x2 = x1, y2 = y1, r2 = r1 : 무한개의 접점(같은 원) 그 외의 경우 : 0개코드package boj_1002;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;class Coordinate { private int x; private int y; private int r; public Coordinate(int x, int y, int r) { this.x = x; this.y = y; this.r = r; } public int getX() { return x; } public int getY() { return y; } public int getR() { return r; } public int countContactPoint(Coordinate other) { if(samePoint(other)) { return -1; } if(contactOutside(other) || contactInside(other)) { return 1; } if(contactDoublePoint(other)) { return 2; } return 0; } private boolean contactDoublePoint(Coordinate other) { int xSquared = (int) Math.pow(other.getX() - this.getX(), 2); int ySquared = (int) Math.pow(other.getY() - this.getY(), 2); int smallRSquared = (int) Math.pow(other.getR() - this.getR(), 2); int bigRSquared = (int) Math.pow(other.getR() + this.getR(), 2); return (smallRSquared &amp;lt; xSquared + ySquared) &amp;amp;&amp;amp; (xSquared + ySquared &amp;lt; bigRSquared); } private boolean contactInside(Coordinate other) { int xSquared = (int) Math.pow(other.getX() - this.getX(), 2); int ySquared = (int) Math.pow(other.getY() - this.getY(), 2); int rSquared = (int) Math.pow(other.getR() - this.getR(), 2); return xSquared + ySquared == rSquared; } private boolean contactOutside(Coordinate other) { int xSquared = (int) Math.pow(other.getX() - this.getX(), 2); int ySquared = (int) Math.pow(other.getY() - this.getY(), 2); int rSquared = (int) Math.pow(other.getR() + this.getR(), 2); return xSquared + ySquared == rSquared; } private boolean samePoint(Coordinate other) { return this.getX() == other.getX() &amp;amp;&amp;amp; this.getY() == other.getY() &amp;amp;&amp;amp; this.getR() == other.getR(); }}public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int T = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; T; i++) { int[] split = Arrays.stream(br.readLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray(); Coordinate origin = new Coordinate(split[0], split[1], split[2]); Coordinate other = new Coordinate(split[3], split[4], split[5]); System.out.println(origin.countContactPoint(other)); } }}" }, { "title": "BOJ_1676 팩토리얼 0의 개수 풀이", "url": "/posts/BOJ1676/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-25 19:57:29 +0800", "snippet": "문제백준 팩토리얼 0의 개수 문제 링크내 생각뒤에 0이 오는 조건을 확인해야한다. 뒤에 0이 오기위해서는 2 X 5 의 모양새가 필요한데, 팩토리얼 특성상 2가 5보다 무조건 많다. 그렇기 때문에 5의 개수만 새주면 된다.코드package boj_1015;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int n = Integer.parseInt(br.readLine()); int answer = 0; while(n &amp;gt; 0) { answer += n / 5; n /= 5; } System.out.println(answer); }}" }, { "title": "BOJ_9461 파도반 수열 풀이", "url": "/posts/BOJ9461/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-24 20:13:29 +0800", "snippet": "문제백준 파도반 수열 문제 링크내 생각문제에 있는 그림을 보면, 6각형이 생겼을 때를 기준으로 두 변의 합이 한 변의 길이가 되는 모습이 보이게 된다. 그 시점이 6번째 삼각형 부터 이기 때문에 6번째 삼각형 부터 dp를 적용하면 된다.코드package boj_9461;import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int t = sc.nextInt(); for (int i = 0; i &amp;lt; t; i++) { System.out.println(getOneSideLength(sc.nextInt())); } } private static long getOneSideLength(int level) { if(level &amp;lt; 4) { return 1; } if(level &amp;lt; 6) { return 2; } long[] dp = new long[level + 1]; dp[1] = 1; dp[2] = 1; dp[3] = 1; dp[4] = 2; dp[5] = 2; for(int i = 6; i &amp;lt;= level; i++) { dp[i] = dp[i - 5] + dp[i - 1]; } return dp[level]; }}" }, { "title": "BOJ_15683 감시 풀이", "url": "/posts/BOJ15683/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-23 17:05:29 +0800", "snippet": "문제백준 감시 문제 링크내 생각CCTV 방향에 대한 순열을 dfs로, 해당 방향을 통해 감시하는 것을 bfs로 구현해야하는 문제이다. 백준에서 지원하는 Java 버전이 11이라 pattern matching switch를 몰라서 틀리고 있다(차후 수정).코드package boj_15683;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.Scanner;class CCTV { int number; int x; int y; public CCTV(int number, int x, int y) { this.number = number; this.x = x; this.y = y; }}public class Main { public static int N, M; public static int[][] map; public static int[][] copyMap; public static int[] output; public static List&amp;lt;CCTV&amp;gt; cctvList; public static int[] dx = {-1, 0, 1, 0}; public static int[] dy = {0, 1, 0, -1}; public static int answer = Integer.MAX_VALUE; public static boolean[][] visited; public static void main(String[] args) { Scanner sc = new Scanner(System.in); N = sc.nextInt(); M = sc.nextInt(); map = new int[N][M]; cctvList = new ArrayList&amp;lt;&amp;gt;(); for (int i = 0; i &amp;lt; N; i++) { for (int j = 0; j &amp;lt; M; j++) { map[i][j] = sc.nextInt(); if (map[i][j] != 0 &amp;amp;&amp;amp; map[i][j] != 6) { cctvList.add(new CCTV(map[i][j], i, j)); } } } output = new int[cctvList.size()]; permutation(0, cctvList.size()); System.out.println(answer); } private static void permutation(int depth, int r) { if (depth == r) { copyMap = new int[N][M]; for (int i = 0; i &amp;lt; map.length; i++) { System.arraycopy(map[i], 0, copyMap[i], 0, map[i].length); } for (int i = 0; i &amp;lt; cctvList.size(); i++) { direction(cctvList.get(i), output[i]); } getBlindSpot(); return; } for (int i = 0; i &amp;lt; 4; i++) { output[depth] = i; permutation(depth + 1, r); } } private static void direction(CCTV cctv, int d) { int cctvNum = cctv.number; switch (cctvNum) { case 1 -&amp;gt; { watch(cctv, d); } case 2 -&amp;gt; { switch (d) { case 0, 2 -&amp;gt; { watch(cctv, 0); watch(cctv, 2); } case 1, 3 -&amp;gt; { watch(cctv, 1); watch(cctv, 3); } } } case 3 -&amp;gt; { switch (d) { case 0 -&amp;gt; { watch(cctv, 0); watch(cctv, 1); } case 1 -&amp;gt; { watch(cctv, 1); watch(cctv, 2); } case 2 -&amp;gt; { watch(cctv, 2); watch(cctv, 3); } case 3 -&amp;gt; { watch(cctv, 3); watch(cctv, 0); } } } case 4 -&amp;gt; { switch (d) { case 0 -&amp;gt; { watch(cctv, 0); watch(cctv, 1); watch(cctv, 3); } case 1 -&amp;gt; { watch(cctv, 0); watch(cctv, 1); watch(cctv, 2); } case 2 -&amp;gt; { watch(cctv, 1); watch(cctv, 2); watch(cctv, 3); } case 3 -&amp;gt; { watch(cctv, 0); watch(cctv, 2); watch(cctv, 3); } } } default -&amp;gt; { watch(cctv, 0); watch(cctv, 1); watch(cctv, 2); watch(cctv, 3); } } } private static void watch(CCTV cctv, int d) { Queue&amp;lt;CCTV&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); visited = new boolean[N][M]; queue.add(cctv); visited[cctv.x][cctv.y] = true; while(!queue.isEmpty()) { CCTV now = queue.poll(); int nx = now.x + dx[d]; int ny = now.y + dy[d]; if(nx &amp;lt; 0 || nx &amp;gt;= N || ny &amp;lt; 0 || ny &amp;gt;= M || copyMap[nx][ny] == 6) break; if(copyMap[nx][ny] == 0) { copyMap[nx][ny] = -1; // 빈칸이라면 감시할 수 있다는 의미로 -1 queue.add(new CCTV(cctv.number, nx, ny)); } else { // 다른 cctv가 있거나 이미 감시된 칸이라면 queue.add(new CCTV(cctv.number, nx, ny)); // 그냥 통과 } } } public static void getBlindSpot() { int cnt = 0; for(int i = 0; i &amp;lt; N; i++) { for(int j = 0; j &amp;lt; M; j++) { if(copyMap[i][j] == 0) { cnt++; } } } answer = Math.min(answer, cnt); }}" }, { "title": "프로그래머스 헤비 유저가 소유한 장소 풀이", "url": "/posts/prgrms77487/", "categories": "algorithm, MySQL", "tags": "algorithm", "date": "2022-02-21 21:03:29 +0800", "snippet": "문제프로그래머스 헤비 유저가 소유한 장소 링크내 생각서브 쿼리를 이용하여 In 절의 조건을 제시함으로써 문제를 해결했다.내 코드SELECT *FROM PLACES AS pWHERE HOST_IDIN (SELECT HOST_ID FROM PLACES AS sub_p GROUP BY sub_p.HOST_ID HAVING count(*) &amp;gt; 1);" }, { "title": "프로그래머스 JadenCase 문자열 만들기 풀이", "url": "/posts/prgrms12951/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-18 15:29:29 +0800", "snippet": "문제프로그래머스 JadenCase 문자열 만들기 링크내 생각주어진 문자열 사이의 공백이 여러개일 수 있다는 점이 어려웠던 부분이다. split을 사용하는 방식이 아닌, 문자 하나하나를 타고 들어가며 봐야했다.내 코드import java.util.*;class Solution { public String solution(String s) { StringBuilder answer = new StringBuilder(); s = s.toLowerCase(); String firstStr = s.charAt(0) + &quot;&quot;; answer.append(firstStr.toUpperCase()); for(int i = 1; i &amp;lt; s.length(); i++) { String now = s.charAt(i) + &quot;&quot;; if(now.equals(&quot; &quot;)){ answer.append(&quot; &quot;); } else if(s.charAt(i - 1) == &#39; &#39;) { answer.append(now.toUpperCase()); } else { answer.append(now.toLowerCase()); } } return answer.toString(); }}" }, { "title": "프로그래머스 보호소에서 중성화한 동물 풀이", "url": "/posts/prgrms59045/", "categories": "algorithm, MySQL", "tags": "algorithm", "date": "2022-02-16 21:32:29 +0800", "snippet": "문제프로그래머스 보호소에서 중성화한 동물 링크내 생각2개의 테이블을 조인 한 후 특정 조건을 확인하면 된다.내 코드SELECT ai.ANIMAL_ID, ai.ANIMAL_TYPE, ai.NAMEFROM ANIMAL_INS AS aiJOIN ANIMAL_OUTS AS ao ON ai.ANIMAL_ID = ao.ANIMAL_IDWHERE ai.SEX_UPON_INTAKE != ao.SEX_UPON_OUTCOME;" }, { "title": "프로그래머스 우유와 요거트가 담긴 장바구니 풀이", "url": "/posts/prgrms62284/", "categories": "algorithm, MySQL", "tags": "algorithm", "date": "2022-02-16 21:26:29 +0800", "snippet": "문제프로그래머스 우유와 요거트가 담긴 장바구니 링크내 생각주어진 조건 2개에 맞춰 intersect를 구하면 된다. 허나 MYSQL은 intersect가 없으니 join을 이용하여 구현하였다내 코드SELECT C1.CART_IDFROM CART_PRODUCTS AS C1 INNER JOIN CART_PRODUCTS AS C2 ON C1.CART_ID = C2.CART_ID AND C2.NAME = &#39;Yogurt&#39;WHERE C1.NAME = &#39;Milk&#39;ORDER BY CART_ID;" }, { "title": "BOJ_11723 집합 풀이", "url": "/posts/BOJ11723/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-15 11:57:29 +0800", "snippet": "문제백준 집합 문제 링크내 생각여러개의 숫자를 더하고 삭제하는 방식이다 보니 LinkedList를 통한 해결방법을 생각했다. 허나 문제에 나와있는 것과 같이 비트연산을 이용하면 더 쉽게 할 수 있게된다.코드아래는 LinkedList를 활용해서 푼 경우이다. 솔직히 효율성에서 틀려야 할 것 같은데 맞아서 신기하다.package boj_11723;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.LinkedList;import java.util.List;import java.util.StringTokenizer;import java.util.stream.Collectors;import java.util.stream.Stream;public class Main { static List&amp;lt;Integer&amp;gt; list = new LinkedList&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); int n = Integer.parseInt(br.readLine()); StringTokenizer st; for (int i = 0; i &amp;lt; n; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); String command = st.nextToken(); if(command.equals(&quot;all&quot;) || command.equals(&quot;empty&quot;)) { execute(command, 0, bw); } else { execute(command, Integer.parseInt(st.nextToken()), bw); } } bw.flush(); bw.close(); } private static void execute(String command, int value, BufferedWriter bw) throws IOException { switch (command) { case (&quot;add&quot;): { list.add(value); break; } case (&quot;check&quot;): { bw.write((list.contains(value) ? 1 : 0) + &quot;\\n&quot;); break; } case (&quot;remove&quot;): { list.remove((Integer) value); break; } case (&quot;toggle&quot;): { if (list.contains(value)) { list.remove((Integer) value); } else { list.add(value); } break; } case (&quot;all&quot;): { list = Stream.iterate(1, i -&amp;gt; i + 1).limit(20).collect(Collectors.toCollection(LinkedList::new)); break; } case (&quot;empty&quot;): { list.clear(); break; } } }}다음은 비트마스킹을 통한 풀이이다. add는 x를 추가하기 때문에 1 &amp;lt;&amp;lt; x 와 OR 연산을 활용해 추가한다. remove는 x를 제거하기 때문에 1 &amp;lt;&amp;lt; x 를 NOT 연산을 사용해 비트를 뒤집어 AND 연산 해준다. check는 x의 체크여부를 확인하기 위해 1 &amp;lt;&amp;lt; x 와 마스킹한 값을 AND 연산하여 0이 아닌지 확인한다. toggle은 연산은 x의 연산을 뒤집어야 하므로 1 &amp;lt;&amp;lt; x 와 XOR 연산을 사용한다. all은 보든 비트를 체크하기 때문에 (1 « 21) - 1로 값을 변경해준다. empty는 공집합 이기 때문에 0으로 값을 변경한다.package boj_11723;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main2 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int M = Integer.parseInt(br.readLine()); int s = 0; StringBuilder sb = new StringBuilder(); for (int i = 0; i &amp;lt; M; i++) { String[] input = br.readLine().split(&quot; &quot;); switch (input[0]) { case &quot;all&quot;: s = (1 &amp;lt;&amp;lt; 21) - 1; break; case &quot;empty&quot;: s = 0; break; default: int x = Integer.parseInt(input[1]); switch (input[0]) { case &quot;add&quot;: s |= (1 &amp;lt;&amp;lt; x); break; case &quot;remove&quot;: s &amp;amp;= ~(1 &amp;lt;&amp;lt; x); break; case &quot;check&quot;: sb.append((s &amp;amp; (1 &amp;lt;&amp;lt; x)) != 0 ? 1 : 0).append(&#39;\\n&#39;); break; case &quot;toggle&quot;: s ^= (1 &amp;lt;&amp;lt; x); break; } } } System.out.println(sb); }}" }, { "title": "BOJ_10816 수 고르기 풀이", "url": "/posts/BOJ2230/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-14 21:17:29 +0800", "snippet": "문제백준 수 고르기 문제 링크내 생각이진 탐색으로 target에 대해서 lower_bound 를 하거나, 투포인터로 문제를 해결 할 수있다.코드아래는 투 포인터의 예시이다.package boj_2230;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;public class Main2 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(split[0]); int m = Integer.parseInt(split[1]); int[] arr = new int[n]; for (int i = 0; i &amp;lt; n; i++) { arr[i] = Integer.parseInt(br.readLine()); } Arrays.sort(arr); int right = 0; int answer = Integer.MAX_VALUE; for(int left = 0; left &amp;lt; n; left++) { while(right &amp;lt; n &amp;amp;&amp;amp; arr[right] - arr[left] &amp;lt; m) right++; if(right == n) break; answer = Math.min(answer, arr[right] - arr[left]); } System.out.println(answer); }}" }, { "title": "BOJ_1208 부분 수열의 합 2 풀이", "url": "/posts/BOJ1208/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-11 11:43:29 +0800", "snippet": "문제백준 수 찾기 문제 링크내 생각겁나 어려웠다… 답을 보고도 이틀 정도 걸려서 푼 문제 같았다. 문제의 해결법은 다음과 같다. 주어진 수열의 길이가 40까지로 완전 탐색이 불가능하기 때문에(시간 초과) 주어진 수열을 반으로 잘라 각각 완전 탐색해준다. 반으로 자른 수열의 결과 값을 answer 와 비교한다. 아래 3가지의 경우의 수가 있다. 좌측 수열의 값 우측 수열의 값 좌측 수열 + 우측 수열의 값 이 때 중요한 것은 leftSide와 rightSide에 공집합이 들어있기 때문에 아래 코드로 3가지의 경우의 수가 다 가능하다는 것이다. 만약 이진탐색에서 중복 원소의 좌측과 우측 위치를 찾는 방법을 모른다면 BOJ 10816번을 풀어보는 것을 추천한다.for (int left : leftSide) { int target = s - left; int lower = binarySearchForLower(target, rightSide); int upper = binarySearchForUpper(target, rightSide); answer += upper - lower;}코드package boj_1208;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;public class Main { static int n, s; static int[] arr; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); n = Integer.parseInt(st.nextToken()); s = Integer.parseInt(st.nextToken()); arr = new int[n]; st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 0; i &amp;lt; n; i++) { arr[i] = Integer.parseInt(st.nextToken()); } List&amp;lt;Integer&amp;gt; leftSide = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; rightSide = new ArrayList&amp;lt;&amp;gt;(); dfs(0, n / 2, 0, leftSide); dfs(n / 2, n, 0, rightSide); Collections.sort(rightSide); long answer = 0; for (int left : leftSide) { int target = s - left; int lower = binarySearchForLower(target, rightSide); int upper = binarySearchForUpper(target, rightSide); answer += upper - lower; } if(s == 0) answer--; System.out.println(answer); } private static int binarySearchForUpper(int target, List&amp;lt;Integer&amp;gt; list) { int left = 0; int right = list.size(); while(left &amp;lt; right) { int mid = (left + right) / 2; if(list.get(mid) &amp;gt; target) { right = mid; } else { left = mid + 1; } } return left; } private static int binarySearchForLower(int target, List&amp;lt;Integer&amp;gt; list) { int left = 0; int right = list.size(); while(left &amp;lt; right) { int mid = (left + right) / 2; if(list.get(mid) &amp;gt;= target) { right = mid; } else { left = mid + 1; } } return left; } private static void dfs(int depth, int max, int value, List&amp;lt;Integer&amp;gt; list) { if (depth == max) { list.add(value); return; } dfs(depth + 1, max, value, list); dfs(depth + 1, max, value + arr[depth], list); }}" }, { "title": "BOJ_10816 숫자 카드 2 풀이", "url": "/posts/BOJ10816/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-11 10:50:29 +0800", "snippet": "문제백준 숫자 카드 2 문제 링크내 생각이진 탐색 중 같은 원소가 있을 때, 해당 원소의 가장 좌측과 우측을 알 수 있는 알고리즘을 안다면 쉽게 풀 수 있는 문제이다.코드package boj_10816;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.util.Arrays;import java.util.StringTokenizer;public class Main { static int n, m; static int[] origin; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); n = Integer.parseInt(br.readLine()); origin = new int[n]; StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 0; i &amp;lt; n; i++) { origin[i] = Integer.parseInt(st.nextToken()); } Arrays.sort(origin); m = Integer.parseInt(br.readLine()); st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 0; i &amp;lt; m; i++) { int target = Integer.parseInt(st.nextToken()); int left = binarySearchForLeft(target); int right = binarySearchForRight(target); bw.write(right - left + &quot; &quot;); } bw.flush(); bw.close(); } private static int binarySearchForLeft(int target) { int left = 0; int right = origin.length; while(left &amp;lt; right) { int mid = (left + right) / 2; if(origin[mid] &amp;gt;= target) { right = mid; } else { left = mid + 1; } } return left; } private static int binarySearchForRight(int target) { int left = 0; int right = origin.length; while(left &amp;lt; right) { int mid = (left + right) / 2; if(origin[mid] &amp;gt; target) { right = mid; } else { left = mid + 1; } } return left; }}느낀 점" }, { "title": "BOJ_1920 수 찾기 풀이", "url": "/posts/BOJ1920/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-11 10:03:29 +0800", "snippet": "문제백준 수 찾기 문제 링크내 생각전형적인 이진 탐색 문제이다. 이진탐색을 복기하기에 좋은 문제이다.코드package boj_2230;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.StringTokenizer;public class Main { static int n, m; static int[] origin; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); origin = new int[n]; StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 0; i &amp;lt; n; i++) { origin[i] = Integer.parseInt(st.nextToken()); } Arrays.sort(origin); m = Integer.parseInt(br.readLine()); st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 0; i &amp;lt; m; i++) { System.out.println(binarySearch(Integer.parseInt(st.nextToken()))); } } private static int binarySearch(int target) { int left = 0; int right = origin.length - 1; while(left &amp;lt;= right) { int mid = (left + right) / 2; if(origin[mid] == target) { return 1; } if(origin[mid] &amp;gt; target) { right = mid - 1; } else { left = mid + 1; } } return 0; }}" }, { "title": "BOJ_1072 게임 풀이", "url": "/posts/BOJ1072/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-10 10:03:29 +0800", "snippet": "문제백준 게임 문제 링크내 생각x 값이 굉장히 큰 점으로 보아 이진탐색을 해야하는 유형이다. left = 0, right = x - y 를 처음으로 잡고 이진 탐색을 하며 z 값을 구하면 되는 문제다… 라고 생각했다. 테스트케이스는 맞았으나 제출 결과 3%에서 광탈… 그 이유를 알아보니 크게 2가지 였다. right 초기값 문제 right의 초기값이 x - y 가 아니라 x 로 잡아줘야한다. 부동소수점 문제 변수에 실수형을 저장하면 오차가 발생하게 된다. 실수형은 소수가 2진수로 저장되기 때문에 이를 나타낼 수 없을 경우 가장 근사한 값을 저장하기 때문이다. 예를 들어 double 변수에 0.58을 저장하고 * 100을 한다면 58이 나온다고 생각할 수 있지만, 컴퓨터는 이를 0.579999로 저장하기 때문에 실제로는 57이 반환된다. 알려주신 블로그 코드 아래는 처음에 시도하여 틀린 코드이다. 실수형 변수 저장과 right 초기 값 설정이 잘못된 상황이다.```javapackage boj_1072; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main {public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); int x = Integer.parseInt(split[0]); int y = Integer.parseInt(split[1]); int z = (int) ((y / (double) x) * 100); int answer = Integer.MAX_VALUE; int left = 0; int right = x - y; while(left &amp;lt;= right) { int mid = (left + right) / 2; int tempZ = (int) (((y + mid) / (double) (x + mid)) * 100); if(z == tempZ) { left = mid + 1; } else { answer = Math.min(answer, mid); right = mid - 1; } } if(answer == Integer.MAX_VALUE) { System.out.println(-1); } else { System.out.println(answer); }}}다음은 피드백을 따라 바꾼 풀이이다.```javapackage boj_1072;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); int x = Integer.parseInt(split[0]); int y = Integer.parseInt(split[1]); int z = getZ(x, y); int answer = -1; int left = 0; int right = x; while(left &amp;lt;= right) { int mid = (left + right) / 2; int tempZ = getZ(x + mid, y + mid); if(z == tempZ) { left = mid + 1; } else { answer = mid; right = mid - 1; } } System.out.println(answer); } private static int getZ(int x, int y) { return (int) ((long) y * 100 / x); }}" }, { "title": "프로그래머스 셔틀버스 풀이", "url": "/posts/prgrms17678/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-09 11:21:29 +0800", "snippet": "문제프로그래머스 셔틀버스 링크내 생각구현 문제이다. 주어진 버스에 사람을 태운뒤에, 마지막 버스를 기준으로 다음 두가지만 비교하면된다. 마지막 버스가 꽉 차지 않을 경우 : 마지막 버스의 시간을 리턴한다. 마지막 버스가 꽉 차는 경우 : 마지막 손님의 탑승 시간 - 1분 의 시간을 리턴한다.마지막 버스만 보면 되기 때문에 PriorityQueue를 사용해 버스의 출발 시간을 내림차순으로 하여 저장한 뒤, pq.poll() 메서드로 마지막 버스를 찾아내었다.내 코드import java.util.*;import java.time.*;import java.time.format.DateTimeFormatter;class Bus implements Comparable&amp;lt;Bus&amp;gt;{ LocalTime startTime; List&amp;lt;LocalTime&amp;gt; customers; Bus(LocalTime startTime) { this.startTime = startTime; customers = new ArrayList&amp;lt;&amp;gt;(); } @Override public int compareTo(Bus o) { return -this.startTime.compareTo(o.startTime); }}class Solution { PriorityQueue&amp;lt;Bus&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); public String solution(int n, int t, int m, String[] timetable) { DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;HH:mm&quot;); LocalTime startTime = LocalTime.of(9, 0); Arrays.sort(timetable); int index = 0; for(int i = 0; i &amp;lt; n; i++) { Bus bus = new Bus(startTime.plusMinutes(i * t)); while(index &amp;lt; timetable.length) { LocalTime boardingTime = LocalTime.parse(timetable[index], format); if(bus.startTime.isBefore(boardingTime)) break; if(bus.customers.size() &amp;gt;= m) break; bus.customers.add(boardingTime); index++; } pq.add(bus); } String answer = &quot;&quot;; Bus lastBus = pq.poll(); if(lastBus.customers.size() &amp;lt; m) { answer = lastBus.startTime.format(format); } else { LocalTime lastCustomer = lastBus.customers.get(lastBus.customers.size() - 1); answer = lastCustomer.minusMinutes(1).format(format); } return answer; }}" }, { "title": "BOJ_15684 사다리 조작 풀이", "url": "/posts/BOJ15684/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-08 11:33:29 +0800", "snippet": "문제백준 사다리 조작 문제 링크내 생각사다리를 0개 ~ 3개까지 놓으면서 사다리 타기를 진행하면 된다. 세로선 n개, 가로선 h개를 이용하여 해당 사다리가 연결되어있는지 여부를 조사하는 배열은 사다리 사이의 가로선이기 때문에isLinked[h][n - 1] 이지만, 편의성을 고려해 1부터 시작한다고 생각하고, 사다리의 좌우 맨 끝도 있다고 생각하면,isLinked[h + 1][n + 1] 로 두어서 index Exception을 생각하지 않아도 되어 좀 더 수월했다. 여기서 isLinked[h][n] 은, h번쨰의 세로선에서,n 번째, n + 1 번쨰의 가로선이 연결되어있다는 의미이다.논리를 살펴보면 아래와 같다. 주어진 선분들을 연결한다. 0 ~ 3개의 사다리를 놓으면서 조건이 만족하는 순간, 해당 값이 정답이기 때문에(최솟값) 바로 break문으로 나간다. 정답을 출력한다.코드package BOJ_15684;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { static int n, m, h; static boolean[][] isLinked; static boolean flag = false; static int answer = -1; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); h = Integer.parseInt(st.nextToken()); isLinked = new boolean[h + 1][n + 1]; for (int i = 0; i &amp;lt; m; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); isLinked[a][b] = true; } if(m == 0) { answer = 0; } else { for (int i = 0; i &amp;lt;= 3; i++) { dfs(0, i); if(flag) { answer = i; break; } } } System.out.println(answer); } private static void dfs(int depth, int r) { if(depth == r) { if(isPossible()) { flag = true; } return; } for(int i = 1; i &amp;lt;= h; i++) { for(int j = 1; j &amp;lt; n; j++) { if(!isLinked[i][j] &amp;amp;&amp;amp; !isLinked[i][j - 1] &amp;amp;&amp;amp; !isLinked[i][j + 1]) { isLinked[i][j] = true; dfs(depth + 1, r); isLinked[i][j] = false; } } } } private static boolean isPossible() { for(int i = 1; i &amp;lt;= n; i++) { int nPos = i; int hPos = 1; while (hPos &amp;lt;= h) { if(isLinked[hPos][nPos]) nPos++; else if(isLinked[hPos][nPos - 1]) nPos--; hPos++; } if(nPos != i) { return false; } } return true; }}느낀 점프로그래밍 문제들을 보다보면, 논리는 어려워보이지 않는데 구현하려고 하면 참 어렵다…" }, { "title": "BOJ_15649 n과 m 풀이", "url": "/posts/BOJ15649/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-08 10:31:29 +0800", "snippet": "문제백준 N과 M 문제 링크내 생각N과 M 시리즈를 풀면, 순열과 조합에 대해서는 확실히 요령이 생기게 된다. 각각의 특징을 늘어놓으면, 순열 : visited 라는 boolean[] 배열 필요 조합 : 백트래킹 함수 내의 for문의 초기 인덱스를 잡아줄 int 변수 필요 증복 순열 : 중복을 허용하기 때문에 visited 필요없음 중복 조합 : 중복을 허용하기 때문에 초기 인덱스를 잡아줄 int 변수의 증가 필요없음 배열내의 중복 원소가 있는 순열, 조합 : set을 통해 중복되는 경우 삭제이번 문제는 N과 M(1) 이고, 순열을 묻는 문제이기 때문에 boolean[] 배열을 통해 해당 원소를 썻는지 확인하며 나아가야한다.코드package boj_15649;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); int n = Integer.parseInt(st.nextToken()); int m = Integer.parseInt(st.nextToken()); perm(n, m, new boolean[n], new int[m], 0); } private static void perm(int n, int m, boolean[] visited, int[] output, int depth) { if(depth == m) { for (int i : output) { System.out.print(i + &quot; &quot;); } System.out.println(); return; } for(int i = 0; i &amp;lt; n; i++) { if(!visited[i]) { visited[i] = true; output[depth] = i + 1; perm(n, m, visited, output, depth + 1); visited[i] = false; } } }}" }, { "title": "프로그래머스 다단계 칫솔 판매 풀이", "url": "/posts/prgrms77486/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-07 15:22:29 +0800", "snippet": "문제프로그래머스 다단계 문제 링크내 생각재귀를 통한 트리탐색 문제다. 허나 왠지모르게 숫자를 더하고 빼는 부분에서 자꾸 1정도의 오차가 생겨 결국 문제해결에 실패했다. 숫자 반올림하고 이런거에 좀 취약한것 같다 보완하자.내 코드import java.util.*;class Solution { ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; graph = new ArrayList&amp;lt;&amp;gt;(); int[] answer; public int[] solution(String[] enroll, String[] referral, String[] seller, int[] amount) { answer = new int[enroll.length]; for(int i = 0; i &amp;lt; enroll.length; i++) { graph.add(new ArrayList&amp;lt;&amp;gt;()); } for(int i = 0; i &amp;lt; referral.length; i++) { String r = referral[i]; if(r.equals(&quot;-&quot;)) continue; graph.get(i).add(r); } for(int i = 0; i &amp;lt; seller.length; i++) { String s = seller[i]; int a = amount[i] * 100; int sellerIndex = Arrays.asList(enroll).indexOf(s); dfs(sellerIndex, a, enroll); Arrays.toString(answer); } return answer; } private int dfs(int index, int amount, String[] enroll) { if(graph.get(index).size() == 0) { if(enroll[index].equals(&quot;mary&quot;) || enroll[index].equals(&quot;john&quot;)) { answer[index] += (int) (amount * 0.9); return amount; } answer[index] += amount; return amount; } int nextIndex = Arrays.asList(enroll).indexOf(graph.get(index).get(0)); answer[index] += amount - dfs(nextIndex, amount / 10, enroll); return amount; }}답안답안에서는 반복과 재귀 2개의 방법을 이용하여 문제를 풀었다. 나와 논리는 같지만 코딩실력이 많이 다르다 ㅎㅎ…import java.util.*;class Solution { public int[] solution(String[] enroll, String[] referral, String[] seller, int[] amount) { int[] answer = new int[enroll.length]; Map&amp;lt;String, String&amp;gt; parentMap = new HashMap&amp;lt;&amp;gt;(); Map&amp;lt;String, Integer&amp;gt; memberIndexMap = new HashMap&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; enroll.length; i++) { parentMap.put(enroll[i], referral[i]); memberIndexMap.put(enroll[i], i); } for(int i = 0; i &amp;lt; seller.length; i++) { String now = seller[i]; int profit = 100 * amount[i]; while(!now.equals(&quot;-&quot;)) { int profitForParent = profit / 10; int nowProfit = profit - profitForParent; answer[memberIndexMap.get(now)] += nowProfit; now = parentMap.get(now); profit /= 10; if(profit &amp;lt; 1) { break; } } } return answer; }}" }, { "title": "프로그래머스 순위 풀이", "url": "/posts/prgrms49191/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-04 15:56:29 +0800", "snippet": "문제프로그래머스 순위 문제 링크내 생각이 문제는 플로이드 워셜 알고리즘이라는 걸 아는 순간 쉽게 풀리지만, 그걸 깨닫는 것이 어려운 문제이다.정답을 보고 나서도 이게 왜 플로이드 워셜이지 라는 생각을 했다. 답은 다음과 같다. 플로이드 워셜 알고리즘을 통해서 모든 그래프의 정보를 얻는다. 그래프의 정보를 토대로, n - 1번의 싸움을 했다면 그 사람의 순위를 예측할 수 있다.예를들어 1, 3, 4가 2를 이겼고, 2가 5를 이겼다면, 1, 3, 4 -&amp;gt; 2 -&amp;gt; 5 인데, 이를 플로이드 워셜 알고리즘을 통해 모든 간선을 확인하면2번과 5번은 4번의 싸움을 했기 때문에 순위를 예측할 수 있고, 답은 2가 된다.코드import java.util.*;class Solution { static int INF = (int) 1e9; public int solution(int n, int[][] results) { int answer = 0; int[][] graph = new int[n + 1][n + 1]; for(int i = 0; i &amp;lt;= n; i++) { Arrays.fill(graph[i], INF); } for(int i = 1; i &amp;lt;= n; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(i == j) graph[i][j] = 0; } } for(int[] result: results) { graph[result[0]][result[1]] = 1; } for(int k = 1; k &amp;lt;= n; k++) { for(int i = 1; i &amp;lt;= n; i++) { for(int j = 1; j &amp;lt;= n; j++) { graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]); } } } for(int i = 1; i &amp;lt;= n; i++) { int count = n - 1; for(int j = 1; j &amp;lt;= n; j++) { if(graph[i][j] == INF &amp;amp;&amp;amp; graph[j][i] == INF) count--; } if(count == n - 1) answer++; } return answer; }}" }, { "title": "BOJ_9663 N-Queen 풀이", "url": "/posts/BOJ9663/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-04 12:52:29 +0800", "snippet": "문제백준 N-Queen 문제 링크내 생각dfs를 통해서 queen을 놓으며 해당 queen의 개수가 n개이면 답의 카운트를 올리는 방식으로 풀면된다.하지만 queen을 놀 수 있는가? 를 판단하는 부분이 좀 까다롭다.나의 경우는 바킹독님의 강의를 보고 풀어서 쉬웠지만, 아마 처음 봤다면 굉장히 어려웠을 것 같다.코드package boj_9663;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static boolean visited1[]; static boolean visited2[]; static boolean visited3[]; static int answer = 0; static int n; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); n = Integer.parseInt(br.readLine()); visited1 = new boolean[n]; visited2 = new boolean[n * 2 - 1]; visited3 = new boolean[n * 2 - 1]; dfs(0); System.out.println(answer); } private static void dfs(int depth) { if(depth == n) { answer++; return; } for(int i = 0; i &amp;lt; n; i++) { if(visited1[i] || visited2[i + depth] || visited3[depth - i + n - 1]) continue; visited1[i] = true; visited2[i + depth] = true; visited3[depth - i + n - 1] = true; dfs(depth + 1); visited1[i] = false; visited2[i + depth] = false; visited3[depth - i + n - 1] = false; } }}느낀 점바킹독님 강의는 처음 봤는데 굉장히 잘 가르쳐주신다.나의 경우, 백 트래킹은 개념보다는 문제를 많이 풀다보니 체득한 상황이였는데, 개념을 제대로 알지 못하고하다보니 좀만 어려워도 막힐 경우가 있었다. 이번 강의를 통해서 많은 도움을 얻었다.바킹독님 강의" }, { "title": "BOJ_1463 1로 만들기 풀이", "url": "/posts/BOJ1463/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-03 11:57:29 +0800", "snippet": "문제BOJ 1463 1로 만들기 문제 링크내 생각완전탐색으로 도전해봤으나 시간 제한이 0.15초 라서 시간초과가 발생했다. 완전탐색이아닌 dp, greedy 를 생각해야하나, greedy는 아닌 것 같고 결국 남은것은 dp라고 생각했다.코드바로 아래는 dfs로 풀었다가 시간초과로 실패한 코드이다.package boj_1463;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static int target; static int answer = Integer.MAX_VALUE; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); target = Integer.parseInt(br.readLine()); dfs(0, 1); System.out.println(answer); } private static void dfs(int depth, int value) { if(value &amp;gt; target) return; if(value == target) { answer = Math.min(answer, depth); return; } dfs(depth + 1, value * 3); dfs(depth + 1, value * 2); dfs(depth + 1, value + 1); }}dp를 통해서 푼 문제는 다믕과 같다.package boj_1463;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static int[] dp; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int target = Integer.parseInt(br.readLine()); dp = new int[target + 1]; dp[1] = 0; for (int i = 2; i &amp;lt; target + 1; i++) { dp[i] = dp[i - 1] + 1; if(i % 2 == 0) dp[i] = Math.min(dp[i], dp[i / 2] + 1); if(i % 3 == 0) dp[i] = Math.min(dp[i], dp[i / 3] + 1); } System.out.println(dp[target]); }}느낀 점이코테에서 몇 번 풀었던 문제인데 최근에 dp를 안하다보니 구현하는데 꽤 오랜시간이 들었다. 수학 + dp가 결합된 문제를 많이 풀어봐야겠다." }, { "title": "프로그래머스 네트워크 풀이", "url": "/posts/prgrms43162/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-03 10:34:29 +0800", "snippet": "문제프로그래머스 네트워크 문제 링크내 생각처음에는 bfs를 통해서 인접한 곳을 네트워크가 연결되었다고 생각해서 문제를 풀었으나 광탈했다.알고보니 dfs를 통해서 리프노드까지 쭉쭉 나아가면서 check하는 방식으로 문제를 풀어나가야한다. dfs로 노드들을 탐색한다. 이때 최초탐색의 경우 정답 + 1을 해준다. 모든 노드들을 대상으로 이를 반복한다. 단 방문했다면 하지 않는다.코드class Solution { boolean[] visited; int[][] map; public int solution(int n, int[][] computers) { int answer = 0; visited = new boolean[n]; map = computers; for(int i = 0; i &amp;lt; n; i++) { if(!visited[i]) { answer++; dfs(i, computers[i]); } } return answer; } private void dfs(int index, int[] graph) { visited[index] = true; for(int i = 0; i &amp;lt; graph.length; i++) { if(index != i &amp;amp;&amp;amp; graph[i] == 1 &amp;amp;&amp;amp; !visited[i]) { dfs(i, map[i]); } } }}" }, { "title": "BOJ_1238 파티 문제 풀이", "url": "/posts/BOJ1238/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-02 19:55:29 +0800", "snippet": "문제BOJ 파티 문제 풀이내 생각다익스트라 문제이다. 시작과 끝을 왕복하여 나온 최댓값을 보여주면된다.코드package boj_1238;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.PriorityQueue;import java.util.StringTokenizer;class Node implements Comparable&amp;lt;Node&amp;gt;{ int position; int dist; public Node(int position, int dist) { this.position = position; this.dist = dist; } @Override public int compareTo(Node o) { return Integer.compare(this.dist, o.dist); }}public class Main { static int n, m, x; static ArrayList&amp;lt;ArrayList&amp;lt;Node&amp;gt;&amp;gt; graph = new ArrayList&amp;lt;&amp;gt;(); static int[] distance; static int answer = 0; static final int INF = (int) 1e9; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); x = Integer.parseInt(st.nextToken()); for (int i = 0; i &amp;lt;= n; i++) { graph.add(new ArrayList&amp;lt;&amp;gt;()); } for (int i = 0; i &amp;lt; m; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); int c = Integer.parseInt(st.nextToken()); graph.get(a).add(new Node(b, c)); } for (int i = 1; i &amp;lt;= n; i++) { answer = Math.max(answer, dijkstra(i, x) + dijkstra(x, i)); } System.out.println(answer); } private static int dijkstra(int start, int end) { PriorityQueue&amp;lt;Node&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); distance = new int[n + 1]; Arrays.fill(distance, INF); distance[start] = 0; pq.offer(new Node(start, 0)); while(!pq.isEmpty()) { Node now = pq.poll(); int position = now.position; int dist = now.dist; if(dist &amp;gt; distance[position]) continue; for(int i = 0; i &amp;lt; graph.get(position).size(); i++) { int cost = distance[position] + graph.get(position).get(i).dist; if(cost &amp;lt; distance[graph.get(position).get(i).position]) { distance[graph.get(position).get(i).position] = cost; pq.offer(new Node(graph.get(position).get(i).position, cost)); } } } return distance[end]; }}" }, { "title": "BOJ_10451 순열사이클 문제 풀이", "url": "/posts/BOJ10451/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-02 11:02:29 +0800", "snippet": "문제백준 순열사이클 문제 링크내 생각DFS를 몰라도, 주어진 순열을 따라가면 풀수 있다. 하지만 지레 겁먹고 DFS 로 풀었다.코드package boj_10451;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.StringTokenizer;public class Main { static int[][] map; static boolean[] visited; static int n; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int t = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; t; i++) { System.out.println(getCycle(br)); } } private static int getCycle(BufferedReader br) throws IOException { int result = 0; n = Integer.parseInt(br.readLine()); map = new int[n + 1][n + 1]; visited = new boolean[n + 1]; StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int i = 1; i &amp;lt; n + 1; i++) { int destination = Integer.parseInt(st.nextToken()); map[i][destination] = 1; } for (int i = 1; i &amp;lt; n + 1; i++) { if(!visited[i]) { result++; dfs(i); } } return result; } private static void dfs(int start) { visited[start] = true; for(int i = 1; i &amp;lt; n + 1; i++) { if(map[start][i] == 1 &amp;amp;&amp;amp; !visited[i]) { dfs(i); } } }}" }, { "title": "BOJ_1260 미로탐색 문제 풀이", "url": "/posts/BOJ2178/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-02 10:06:29 +0800", "snippet": "문제백준 미로탐색 문제 링크내 생각문제는 크게 2가지로 해결할 수 있을 것 같다. BFS를 통한 탐색 다익스트라 알고리즘을 통한 탐색다익스트라로 풀 경우의 시간복잡도는 NlogN(heap을 통해서 탐색시간 축소) 이기 때문에 더 빠르지만, bfs를 연습하고 싶어 bfs로 풀었다코드package boj_2178;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.Arrays;import java.util.LinkedList;import java.util.Queue;class Node { int x; int y; public Node(int x, int y) { this.x = x; this.y = y; }}public class Main { static int[][] map; static int[][] shortMap; static final int INF = (int) 1e9; static int[] dx = {-1, 1, 0, 0}; static int[] dy = {0, 0, -1, 1}; static int n, m; public static void main(String[] args) throws IOException { inputData(); bfs(0, 0); System.out.println(shortMap[n - 1][m - 1]); } private static void bfs(int x, int y) { Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(x, y)); shortMap[0][0] = 1; while (!q.isEmpty()) { Node now = q.poll(); x = now.x; y = now.y; for (int i = 0; i &amp;lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;gt;= n || nx &amp;lt; 0 || ny &amp;gt;= m || ny &amp;lt; 0) continue; if(map[nx][ny] == 1 &amp;amp;&amp;amp; shortMap[nx][ny] &amp;gt; shortMap[x][y] + 1) { shortMap[nx][ny] = shortMap[x][y] + 1; q.offer(new Node(nx, ny)); } } } } private static void inputData() throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] split = br.readLine().split(&quot; &quot;); n = Integer.parseInt(split[0]); m = Integer.parseInt(split[1]); map = new int[n][m]; shortMap = new int[n][m]; for (int i = 0; i &amp;lt; n; i++) { Arrays.fill(shortMap[i], INF); } for (int i = 0; i &amp;lt; n; i++) { String[] line = br.readLine().split(&quot;&quot;); for (int j = 0; j &amp;lt; line.length; j++) { map[i][j] = Integer.parseInt(line[j]); } } }}" }, { "title": "BOJ_1260 BFS와 DFS 문제 풀이", "url": "/posts/BOJ1260/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-02 10:03:29 +0800", "snippet": "문제백준 BFS와 DFS 문제 링크내 생각DFS, BFS 를 사용할 수 있느냐의 문제이다. DFS는 재귀, BFS는 Queue를 통해서 해결하면된다.7개월 전에 풀었던 문제라서 이번에는 2차원 배열이 아닌, 2차원 그래프로 문제를 풀었다.코드package boj_1260;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;public class Main { static ArrayList&amp;lt;ArrayList&amp;lt;Integer&amp;gt;&amp;gt; GRAPH = new ArrayList&amp;lt;&amp;gt;(); static int n, m, start; static boolean[] visited; public static void main(String[] args) throws IOException { inputData(); dfs(start); System.out.println(); visited = new boolean[n + 1]; bfs(start); } private static void bfs(int start) { Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(start); visited[start] = true; while(!q.isEmpty()) { Integer now = q.poll(); System.out.print(now + &quot; &quot;); for(int i = 0; i &amp;lt; GRAPH.get(now).size(); i++) { Integer next = GRAPH.get(now).get(i); if(!visited[next]) { q.offer(next); visited[next] = true; } } } } private static void dfs(int start) { System.out.print(start + &quot; &quot;); visited[start] = true; for (int i = 0; i &amp;lt; GRAPH.get(start).size(); i++) { Integer next = GRAPH.get(start).get(i); if(!visited[next]) dfs(next); } } private static void inputData() throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); visited = new boolean[n + 1]; start = Integer.parseInt(st.nextToken()); for (int i = 0; i &amp;lt;= n; i++) { GRAPH.add(new ArrayList&amp;lt;&amp;gt;()); } for (int i = 0; i &amp;lt; m; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); GRAPH.get(a).add(b); GRAPH.get(b).add(a); } for (int i = 1; i &amp;lt;= n; i++) { Collections.sort(GRAPH.get(i)); } }}" }, { "title": "프로그래머스 n진수 게임 풀이", "url": "/posts/prgrms17687/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-02-01 09:50:29 +0800", "snippet": "문제프로그래머스 n진수 게임 문제 링크내 생각논리는 다음과 같습니다. 주어진 t(미리 구할 숫자의 개수), m(게임의 참가하는 인원) 을 곱한 수를 반복문을 돌아 0 ~ end 까지 n 진법으로 만든 문자열을 만듭니다. 해당 문자열을 char[] 로 만들어 배열을 순회하며 tube가 말할 문자를 꺼내 새로운 문자열을 만들어준다. 새로운 문자열을 정답으로 제출한다.코드class Solution { public String solution(int n, int t, int m, int p) { char[] chars = parse(n, t * m); StringBuilder answer = new StringBuilder(); for(int i = 0; i &amp;lt; chars.length; i++) { if(answer.length() == t) break; int tubeTime = p - 1; if(i % m == tubeTime) { answer.append(chars[i]); } } return answer.toString(); } private char[] parse(int notation, int length) { StringBuilder sb = new StringBuilder(&quot;0&quot;); for(int i = 1; i &amp;lt;= length; i++) { sb.append(parseOne(notation, i)); } return sb.toString().toCharArray(); } private String parseOne(int notation, int value) { StringBuilder sb = new StringBuilder(); while(value &amp;gt; 0) { int reminder = value % notation; if(reminder &amp;lt; 10) { sb.append(reminder); } else { sb.append((char)(reminder + 55)); } value /= notation; } return sb.reverse().toString(); }}답안아래의 코드는 프로그래머스에서 많은 좋아요를 받은 답안 중에 하나입니다.위의 코드로 문제를 제출해도 정답이지만, 사실 정수를 특정 진법에 맞춰주는 Integer.toString(숫자, 진법) 메서드가 있습니다. 이걸 사용하면 기존의 코드를 훨씬 줄일 수 있습니다.class Solution { public String solution(int n, int t, int m, int p) { String answer = &quot;&quot;; int startNum = 0; String targetString = new String(); String retString = new String(); while (targetString.length() &amp;lt; m * t) { targetString += Integer.toString(startNum++, n); } for (int i = 0; i &amp;lt; t; i++) { retString += targetString.charAt(p - 1 + i * m); } answer = retString.toUpperCase(); return answer; }}" }, { "title": "프로그래머스 방문 길이 풀이", "url": "/posts/prgrms49994/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-31 11:45:29 +0800", "snippet": "문제프로그래머스 방문 길이 풀이내 생각프로그래머스 빛의 경로 사이클 문제와 풀이가 유사하다. 주어진 노드를 순회하며 방향성을 고려하되,방향이 아닌 지나온 길을 기준으로 하기 떄문에 반대쪽 경로도 마킹을 해줘야한다.예를 들어 [5, 5] -&amp;gt; [4, 5] 라면, visited[5][5][1] = true, visited[4][5][0] = true 로 하는 방식이다.visited를 3차원으로 주는 이유는 visited[x좌표][y좌표][방향(U, D, L, R 중에 하나 보통 0 1 2 3 으로 나타냄)] 를 통해서 방향성도 체크할 수 있기 때문이다.코드import java.util.*;class Solution { List&amp;lt;Character&amp;gt; directions = List.of(&#39;U&#39;, &#39;D&#39;, &#39;L&#39;, &#39;R&#39;); // U, D, L, R int[] dx = {-1, 1, 0, 0}; int[] dy = {0, 0, -1, 1}; boolean[][][] visited; public int solution(String dirs) { visited = new boolean[11][11][4]; int x = 5, y = 5; int answer = 0; for(char c : dirs.toCharArray()) { int i = directions.indexOf(c); int reverseI = getReverse(i); int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;gt;= 11 || nx &amp;lt; 0 || ny &amp;gt;= 11 || ny &amp;lt; 0) continue; if(!visited[nx][ny][i]){ visited[nx][ny][i] = true; visited[x][y][reverseI] = true; answer++; } x = nx; y = ny; } return answer; } private int getReverse(int i) { return i % 2 == 0? i + 1 : i - 1; }}" }, { "title": "프로그래머스 n^2 배열 자르기 풀이", "url": "/posts/prgrms87390/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-31 08:50:29 +0800", "snippet": "문제프로그래머스 n^2 배열 자르기 문제 링크내 생각시간 초과가 관건인 문제였다. 주어진 n 이 10^7 까지 가능하고, left, right는 n^2 까지 가능하기때문에 일반적인 2차원 배열 선언시에는 메모리 초과가 난다.따라서 수학적으로 해결해야하는데, left에서 right 의 길이의 1차원 배열을 만들고,left에서 right 까지의 for문을 순회하면서 해당 i값의 몫, 나머지 중에 큰 값 + 1을 배열에넣어주면, 문제의 요구사항을 충족한다.코드import java.util.*;class Solution { public int[] solution(int n, long left, long right) { int[] array = new int[(int) (right - left) + 1]; for(long i = left; i &amp;lt;= right; i++) { int s = (int) (i / n); int r = (int) (i % n); array[(int) (i - left)] = Math.max(s, r) + 1; } return array; }}" }, { "title": "프로그래머스 방금그곡 풀이", "url": "/posts/prgrms17683/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-30 10:54:29 +0800", "snippet": "문제프로그래머스 방금 그곡 문제 링크내 생각C#, D# 등을 처리한것이 관건인 문제였다. C# 같은 경우 contains 메서드로 잡아낼 수 없기 때문에 쓰지않는문자인 F, G 등으로 치환한 뒤에 문제를 진행하면 훨씬 수월하다.코드import java.util.*;import java.text.SimpleDateFormat;import java.text.ParseException;class MusicInfo implements Comparable&amp;lt;MusicInfo&amp;gt; { Date startDate; Date endDate; int minute; String name; String melody; public MusicInfo (Date startDate, Date endDate, int minute, String name, String melody) { this.startDate = startDate; this.endDate = endDate; this.minute = minute; this.name = name; this.melody = melody; } @Override public int compareTo(MusicInfo o) { return -Integer.compare(this.minute, o.minute); }}class Solution { List&amp;lt;MusicInfo&amp;gt; infos = new ArrayList&amp;lt;&amp;gt;(); SimpleDateFormat f = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.KOREA); public String solution(String m, String[] musicinfos) throws ParseException { parse(musicinfos); List&amp;lt;MusicInfo&amp;gt; myMusic = new ArrayList&amp;lt;&amp;gt;(); for(MusicInfo info : infos) { m = replaceMelody(m); if(info.melody.contains(m)) { myMusic.add(info); } } Collections.sort(myMusic); if(myMusic.size() &amp;gt; 0) { return myMusic.get(0).name; } return &quot;(None)&quot;; } private String replaceMelody(String oldMelody) { oldMelody = oldMelody.replaceAll(&quot;C#&quot;, &quot;H&quot;); oldMelody = oldMelody.replaceAll(&quot;D#&quot;, &quot;I&quot;); oldMelody = oldMelody.replaceAll(&quot;F#&quot;, &quot;J&quot;); oldMelody = oldMelody.replaceAll(&quot;G#&quot;, &quot;K&quot;); String newMelody = oldMelody.replaceAll(&quot;A#&quot;, &quot;L&quot;); return newMelody; } private void parse(String[] musicinfos) throws ParseException { for(String info : musicinfos) { String[] split = info.split(&quot;,&quot;); Date startDate = f.parse(split[0]); Date endDate = f.parse(split[1]); String name = split[2]; int minute = (int) ((endDate.getTime() - startDate.getTime()) / 60000); String melody = getMelody(split[3], minute); infos.add(new MusicInfo(startDate, endDate, minute, name, melody)); } } private String getMelody(String origin, int minute) { StringBuilder sb = new StringBuilder(); int n = 0; while(n &amp;lt; minute) { int index = n % origin.length(); sb.append(origin.charAt(index)); if(origin.charAt(index) == &#39;#&#39;) { minute++; }; n++; } if(origin.length() &amp;gt; minute &amp;amp;&amp;amp; origin.charAt(minute) == &#39;#&#39;) { sb.append(&#39;#&#39;); } return replaceMelody(sb.toString()); }}답안베스트 솔루션에서는 나와 같은 로직이지만 훨씬 깔끔하게 풀었다.class Solution { public String solution(String m, String[] musicinfos) { String answer = &quot;(None)&quot;; int time = 0; m = edit(m); for(int inx = 0; inx &amp;lt; musicinfos.length; inx++) { String[] info = musicinfos[inx].split(&quot;,&quot;); int start = (60 * Integer.parseInt(info[0].substring(0, 2))) + Integer.parseInt(info[0].substring(3)); int end = (60 * Integer.parseInt(info[1].substring(0, 2))) + Integer.parseInt(info[1].substring(3)); int t = end - start; if(t &amp;gt; time) { info[3] = edit(info[3]); StringBuilder sb = new StringBuilder(); for(int jnx = 0; jnx &amp;lt; t; jnx++) { sb.append(info[3].charAt(jnx % (info[3].length()))); } if(sb.toString().indexOf(m) &amp;gt;= 0) { answer = info[2]; time = t; } } } return answer; } private String edit(String m) { m = m.replaceAll(&quot;C#&quot;, &quot;V&quot;); m = m.replaceAll(&quot;D#&quot;, &quot;W&quot;); m = m.replaceAll(&quot;F#&quot;, &quot;X&quot;); m = m.replaceAll(&quot;G#&quot;, &quot;Y&quot;); m = m.replaceAll(&quot;A#&quot;, &quot;Z&quot;); return m; }}" }, { "title": "프로그래머스 캐시 풀이", "url": "/posts/prgrms17680/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-28 10:01:29 +0800", "snippet": "문제프로그래머스 캐시 문제 풀이내 생각LRU 라는 개념을 처음 들어봤으면 문제를 이해하는데 어려웠을 수도있다. 주어진 문제를 잘 읽고 그에 맟줘풀어야하는 구현 문제이다.코드import java.util.*;class Solution { public int solution(int cacheSize, String[] cities) { List&amp;lt;String&amp;gt; cache = new LinkedList&amp;lt;&amp;gt;(); int answer = 0; if(cacheSize == 0) { return cities.length * 5; } for(String city: cities) { city = city.toLowerCase(); if(cache.contains(city)) { cache.remove(city); cache.add(city); answer += 1; } else { if(cache.size() &amp;gt;= cacheSize) { cache.remove(0); } cache.add(city); answer += 5; } } return answer; }}" }, { "title": "프로그래머스 모음 사전 풀이", "url": "/posts/prgrms84512/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-28 09:56:29 +0800", "snippet": "문제프로그래머스 모음 사전 문제 링크내 생각dfs를 통해 AEIOU 에 대한 완전 탐색을 진행하면서, 완전 탐색 중에 word 와 맞는 단어가 보인다면 그 떄의 count 값을 저장해놓고 정답으로 제출한다. 하지만 중간에 backTracking이 되는 것이 아니라서 속도가 느리다. 이 점은 보완해야한다.코드import java.util.*;class Solution { int count = 0; int answer = 0; public int solution(String word) { dfs(&quot;AEIOU&quot;, &quot;&quot;, word, 0); return answer; } private void dfs(String origin, String prev, String word, int depth) { if(word.equals(prev)) { answer = count; return; } if(depth == 5) { return; } for(int i = 0; i &amp;lt; origin.length(); i++) { count++; dfs(origin, prev + origin.charAt(i), word, depth + 1); } }}" }, { "title": "프로그래머스 사라지는 발판 풀이", "url": "/posts/prgrms92345/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-27 09:27:29 +0800", "snippet": "문제프로그래머스 사라지는 발판 문제 링크정답 풀이 링크풀이이 문제의 키 포인트는 최적의 플레이를 구하는데에 중점을 두고 있다. 최적의 플레이란, 이기는 쪽은게임의 턴 수를 최소화하려 하고, 지는 쪽은 최대화 하려고 하는 것을 말한다.코드아래의 코드는 위의 정답 링크의 코드를 java로 변경한 것이다.class Pair { boolean canWin; int count; Pair (boolean canWin, int count) { this.canWin = canWin; this.count = count; }}class Solution { int N, M; int[] dx = {-1, 1, 0, 0}; int[] dy = {0, 0, -1, 1}; private boolean inRange(int x, int y) { return x &amp;lt; N &amp;amp;&amp;amp; x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; M &amp;amp;&amp;amp; y &amp;gt;= 0; } private boolean isFinished(int[][] board, int x, int y) { for(int i = 0; i &amp;lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(inRange(nx, ny) &amp;amp;&amp;amp; board[nx][ny] == 1) { return false; } } return true; } private Pair dfs(int[][] board, int ax, int ay, int bx, int by) { if(isFinished(board, ax, ay)) return new Pair(false, 0); if(ax == bx &amp;amp;&amp;amp; ay == by) return new Pair(true, 1); boolean canWin = false; int minTurn = (int) 1e9, maxTurn = 0; for(int i = 0; i &amp;lt; 4; i++) { int nx = ax + dx[i]; int ny = ay + dy[i]; if(!inRange(nx, ny) || board[nx][ny] == 0) continue; board[ax][ay] = 0; Pair pair = dfs(board, bx, by, nx, ny); board[ax][ay] = 1; if(!pair.canWin) { canWin = true; minTurn = Math.min(minTurn, pair.count); } else { maxTurn = Math.max(maxTurn, pair.count); } } int turn = canWin ? minTurn : maxTurn; return new Pair(canWin, turn + 1); } public int solution(int[][] board, int[] aloc, int[] bloc) { N = board.length; M = board[0].length; return dfs(board, aloc[0], aloc[1], bloc[0], bloc[1]).count; }}코드 분석아래 코드를 보면, 지는 경우 에는(4개의 면이 막힘) false, 0 울 반환하고, 이기는 경우에는 true, 1 을 반환한다.이 때 1을 반환하는 이유는 다음 턴에 한칸 더 이동해야 승리로 판단되기 때문이다. private Pair dfs(int[][] board, int ax, int ay, int bx, int by){ // 지는 경우 if(isFinished(board,ax,ay))return new Pair(false,0); // 이기는 경우 if(ax==bx&amp;amp;&amp;amp;ay==by)return new Pair(true,1); ... }다음은 최대와 최소 구별이다. 이기는 쪽은 최소 턴 수를, 지는 쪽은 최대 턴 수를 가져가려 하기 떄문에 다음과 같은 변수를 통해 판단하려한다.private Pair dfs(int[][] board, int ax, int ay, int bx, int by) { ... // 여기 boolean canWin = false; int minTurn = (int) 1e9, maxTurn = 0; ... }for문을 돌면서 4개의 방향에 대해서 이동한다. 이동 한 이후의 칸은 0으로 만들어주고, aloc과 bloc의 위치를 변경하여 dfs를 수행한다.dfs를 수행한 결과는 이전까지의 turn 수와 이기고 지는 것에 대한 boolean이 들어있다. if문을 보면, canWin이false 라면 다음턴은 이기는 상황이기 때문에 최소값을, true라면 다음턴은 지는 상황이기 때문에 최대값을 가져와 +1 한 값을 return하는 모습을 볼 수 있다. private Pair dfs(int[][] board, int ax, int ay, int bx, int by) { ... for(int i = 0; i &amp;lt; 4; i++) { int nx = ax + dx[i]; int ny = ay + dy[i]; if(!inRange(nx, ny) || board[nx][ny] == 0) continue; board[ax][ay] = 0; Pair pair = dfs(board, bx, by, nx, ny); board[ax][ay] = 1; if(!pair.canWin) { canWin = true; minTurn = Math.min(minTurn, pair.count); } else { maxTurn = Math.max(maxTurn, pair.count); } } int turn = canWin ? minTurn : maxTurn; return new Pair(canWin, turn + 1); }" }, { "title": "BOJ 회의 준비 문제 풀이", "url": "/posts/BOJ2610/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-26 09:19:29 +0800", "snippet": "문제BOJ 회의 준비 문제 링크내 생각논리는 아래와 같습니다. 플로이드 워셜 알고리즘을 통해 모든 경로의 최단 거리를 구한다. bfs를 통해 위원회를 그룹핑한다. 그룹핑한 위원회에서 리더를 선출한다.코드package boj_2610;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.Queue;import java.util.StringTokenizer;public class Main { static final int INF = (int) 1e9; static int N, M; static int committeeCount = 0; static boolean[] visited; static int[][] graph; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; N = Integer.parseInt(br.readLine()); M = Integer.parseInt(br.readLine()); graph = new int[N + 1][N + 1]; for (int i = 1; i &amp;lt;= N; i++) { Arrays.fill(graph[i], INF); } for (int i = 1; i &amp;lt;= N; i++) { for (int j = 1; j &amp;lt;= N; j++) { if (i == j) graph[i][j] = 0; } } for (int i = 0; i &amp;lt; M; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); graph[a][b] = 1; graph[b][a] = 1; } floydWarshell(); visited = new boolean[N + 1]; List&amp;lt;Integer&amp;gt; leaders = new ArrayList&amp;lt;&amp;gt;(); for (int i = 1; i &amp;lt;= N; i++) { if (!visited[i]) { committeeCount++; leaders.add(findCommittee(i)); } } Collections.sort(leaders); System.out.println(committeeCount); for (Integer i: leaders) { System.out.println(i); } } private static int findCommittee(int start) { Queue&amp;lt;Integer&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; committee = new ArrayList&amp;lt;&amp;gt;(); committee.add(start); q.offer(start); visited[start] = true; while (!q.isEmpty()) { int now = q.poll(); for(int j = 1; j &amp;lt;= N; j++) { if(!visited[j] &amp;amp;&amp;amp; graph[now][j] != INF) { q.offer(j); visited[j] = true; committee.add(j); } } } return findLeader(committee); } private static int findLeader(List&amp;lt;Integer&amp;gt; committee) { int minValue = Integer.MAX_VALUE; int index = 0; for(int i = 0; i &amp;lt; committee.size(); i++) { int start = committee.get(i); int decisionTime = 0; for(int j = 0; j &amp;lt; committee.size(); j++) { if(i == j) continue; decisionTime += graph[start][committee.get(j)]; } if(decisionTime &amp;lt;= minValue) { index = start; minValue = decisionTime; } } return index; } private static void floydWarshell() { for (int k = 1; k &amp;lt;= N; k++) { for (int i = 1; i &amp;lt;= N; i++) { for (int j = 1; j &amp;lt;= N; j++) { graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]); graph[j][i] = graph[i][j]; } } } }}" }, { "title": "다익스트라 알고리즘 이란?", "url": "/posts/dijkstra.md/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-25 09:57:29 +0800", "snippet": "다익스트라 알고리즘다익스트라 알고리즘은 그래프에서 여러 개의 노드가 있을 떄, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘입니다.다익스트라는 음의 간선 이 없을 때 정상적으로 동작하는데, 음의 간선이란 0보다 작은 값을 가지는 간선을 의미합니다.다익스트라 알고리즘은 그리디 알고리즘으로 분류됩니다. 매번 가장 비용이 적은 노드를 선택해서 임의의 과정을 반복하기 때문입니다. 과정은 다음과 같습니다. 출발 노드를 설정한다. 최단 거리 테이블을 초기화 한다. 방문하지 않은 노드 중에서 최단거리가 가장 짧은 노드를 선택한다. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다. 위 과정에서 3, 4를 반복한다.다익스트라 알고리즘은 최단 경로를 구하는 과정에서 각 노드에 대한 현재까지의 최단 거리 정보를 항상 1차원 리스트에 저장하며 리스트를 갱신한다는 특징이 있습니다. 매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인한 뒤, 현재 처리하고 있는 노드와 인접한 노드로 도달하는 더 짧은 경로를 찾으면 리스트를 갱신합니다.다익스트라 알고리즘은 방문하지 않는 노드 중에서 가장 최단 거리가 짧은 노드를 선택 하는 과정을 반복하는데, 이렇게 선택된 노드는 최단 거리 가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않습니다. 다시 말해 다익스트라 알고리즘은 한 단계당 출발지로 부터 하나의 노드에 대한 최단 거리를 확실히 찾는 것 의 반복으로 의미할 수 있습니다.위에서 리스트를 매번 갱신한다고 했는데, 갱신 방법은 보통 heap을 이용하여 복잡도를 줄입니다.import java.util.ArrayList;import java.util.Arrays;import java.util.PriorityQueue;import java.util.Scanner;class Node implements Comparable&amp;lt;Node&amp;gt; { private int index; private int distance; public Node(int index, int distance) { this.index = index; this.distance = distance; } public int getIndex() { return index; } public int getDistance() { return distance; } @Override public int compareTo(Node o) { if(this.distance &amp;lt; o.distance) { return -1; } return 1; }}public class Main { public static final int INF = (int) 1e9; public static int n, m, start; public static ArrayList&amp;lt;ArrayList&amp;lt;Node&amp;gt;&amp;gt; graph = new ArrayList&amp;lt;ArrayList&amp;lt;Node&amp;gt;&amp;gt;(); public static int[] d = new int[100001]; public static void main(String[] args) { Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); start = sc.nextInt(); for(int i = 0; i &amp;lt;= n; i++) { graph.add(new ArrayList&amp;lt;Node&amp;gt;()); } for (int i = 0; i &amp;lt; m; i++) { int a = sc.nextInt(); int b = sc.nextInt(); int c = sc.nextInt(); graph.get(a).add(new Node(b, c)); } Arrays.fill(d, INF); dijkstra(start); } private static void dijkstra(int start) { PriorityQueue&amp;lt;Node&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); pq.offer(new Node(start, 0)); d[start] = 0; while(!pq.isEmpty()) { Node node = pq.poll(); int dist = node.getDistance(); int now = node.getIndex(); if(d[now] &amp;lt; dist) continue; for(int i = 0; i &amp;lt; graph.get(now).size(); i++) { int cost = d[now] + graph.get(now).get(i).getDistance(); if(cost &amp;lt; d[graph.get(now).get(i).getIndex()]) { d[graph.get(now).get(i).getIndex()] = cost; pq.offer(new Node(graph.get(now).get(i).getIndex(), cost)); } } } }}" }, { "title": "전보 문제 풀이", "url": "/posts/jeonbo/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-25 09:07:29 +0800", "snippet": "내 생각전형적인 다익스트라 문제 풀이이다.코드package jeonbo;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.text.MessageFormat;import java.util.ArrayList;import java.util.Arrays;import java.util.PriorityQueue;import java.util.StringTokenizer;class Node implements Comparable&amp;lt;Node&amp;gt; { private int index; private int distance; public Node(int index, int distance) { this.index = index; this.distance = distance; } public int getIndex() { return index; } public int getDistance() { return distance; } @Override public int compareTo(Node o) { if (this.distance &amp;lt; o.distance) { return -1; } return 1; }}public class Main { public static int INF = (int) 1e9; public static int[] d; public static ArrayList&amp;lt;ArrayList&amp;lt;Node&amp;gt;&amp;gt; graph = new ArrayList&amp;lt;ArrayList&amp;lt;Node&amp;gt;&amp;gt;(); public static int n, m, start; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); start = Integer.parseInt(st.nextToken()); d = new int[n + 1]; Arrays.fill(d, INF); for (int i = 0; i &amp;lt;= n; i++) { graph.add(new ArrayList&amp;lt;&amp;gt;()); } for (int i = 0; i &amp;lt; m; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int a = Integer.parseInt(st.nextToken()); int b = Integer.parseInt(st.nextToken()); int c = Integer.parseInt(st.nextToken()); graph.get(a).add(new Node(b, c)); } dijkstra(start); int nodeCount = 0; int distCount = 0; for(int i = 1; i &amp;lt;= n; i++) { if(d[i] != INF) { nodeCount++; distCount = Math.max(distCount, d[i]); } } System.out.print(MessageFormat.format(&quot;{0} {1}&quot;, nodeCount - 1, distCount)); } private static void dijkstra(int start) { PriorityQueue&amp;lt;Node&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); pq.offer(new Node(start, 0)); d[start] = 0; while (!pq.isEmpty()) { Node node = pq.poll(); int dist = node.getDistance(); int now = node.getIndex(); if(d[now] &amp;lt; dist) continue; for (int i = 0; i &amp;lt; graph.get(now).size(); i++) { int cost = d[now] + graph.get(now).get(i).getDistance(); if(cost &amp;lt; d[graph.get(now).get(i).getIndex()]) { d[graph.get(now).get(i).getIndex()] = cost; pq.offer(new Node(graph.get(now).get(i).getIndex(), cost)); } } } }}" }, { "title": "프로그래머스 점프와 순간이동 풀이", "url": "/posts/prgrms12980/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-24 09:47:29 +0800", "snippet": "문제프로그래머스 점프와 순간 이동내 생각DP 라고 생각했다.. 그래서 bottom-top 방식으로 풀려고 하는데, dp방식으로 풀리지 않아서답을 참조했다… 수학문제더라 하하…이 문제는 N이 0이 될 때 까지, 짝수면 2로 나누고, 홀수면 -1을 하면 된다. 어찌됬는 순간이동을 하는게 가장 좋기 때문에 최우선순위를순간이동으로 생각하고 풀어야하는 그리디 유형의 문제였다.코드이 코드는 dp로 풀려다가 망해버린 코드이다(추후 기억 복기용) 답안은 조금 더 아래에 있다.import java.util.*;public class Solution { int[] dp; public int solution(int n) { dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for(int i = 3; i &amp;lt; n + 1; i++) { for(int j = 1; j &amp;lt; i; j++) { if(i % 2 == 0) { dp[i] = Math.min(dp[i], Math.min(dp[i - j] + j, dp[i / 2])); } else { dp[i] = Math.min(dp[i - j] + j, dp[i / 2]) } } System.out.println(dp[i]); } return dp[n]; }}답안import java.util.*;public class Solution { public int solution(int n) { int ans = 0; while(n &amp;gt; 0) { if(n % 2 == 0) { n /= 2; } else { n -= 1; ans++; } } return ans; }}" }, { "title": "프로그래머스 영어 끝말잇기 풀이", "url": "/posts/prgrms12981/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-21 07:04:29 +0800", "snippet": "문제프로그래머스 영어 끝말잇기 링크내 생각hash를 이용하여 단어가 중복이 되었는지, 끝말잇기의 조건이 충족되는지를 확인하면서 배열을 순회하면 됩니다코드import java.util.*;class Solution { Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public int[] solution(int n, String[] words) { map.put(words[0], words[0]); for(int i = 1; i &amp;lt; words.length; i++) { int r = (i / n) + 1; int c = (i % n) + 1; String prev = words[i - 1]; if(map.containsKey(words[i]) || prev.charAt(prev.length() - 1) != words[i].charAt(0)) { return new int[] {c, r}; } map.put(words[i], words[i]); } return new int[] {0, 0}; }}" }, { "title": "프로그래머스 여행 경로 풀이", "url": "/posts/prgrms43164/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-20 10:12:29 +0800", "snippet": "문제프로그래머스 여행 경로 링크내 생각여행경로를 bfs를 통해서 q를 이용하되, 경로가 중복된다면 알파벳 순으로 정렬한뒤에 가장 앞에 있는 path를 넣어주는 방식으로 했다. 허나 이 방식의 경우, 모든 경로를 들린다는 보장이 없기 때문에 모든 문제를 풀수 없었다.그래서 다른 방법을 생각해야했다. dfs를 통해서 모든 경로를 탐색 한뒤, 그 경로를 정렬하여가장 앞에있는 값을 리턴하면 됬다.코드bfs로 풀어보려다가 미국 가버린 코드입니다… 아래에 dfs를 통한 풀이를 참고하시면 감사하겠습니다.import java.util.*;class Path implements Comparable&amp;lt;Path&amp;gt;{ String start; String end; int index; Path(String start, String end, int index) { this.start = start; this.end = end; this.index = index; } @Override public int compareTo(Path o) { return this.end.compareTo(o.end); } @Override public String toString() { final StringBuilder sb = new StringBuilder(&quot;Path{&quot;); sb.append(&quot;start=&#39;&quot;).append(start).append(&#39;\\&#39;&#39;); sb.append(&quot;, end=&#39;&quot;).append(end).append(&#39;\\&#39;&#39;); sb.append(&#39;}&#39;); return sb.toString(); }}class Solution { boolean[] used; public String[] solution(String[][] tickets) { used = new boolean[tickets.length]; String[] answer = bfs(tickets); return answer; } private String[] bfs(String[][] tickets) { List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); result.add(&quot;ICN&quot;); Queue&amp;lt;Path&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); Path path = getPath(&quot;ICN&quot;, tickets); q.offer(path); result.add(path.end); int j = 1; while(j &amp;lt; tickets.length) { Path now = q.poll(); String end = now.end; Path next = getPath(end, tickets); used[now.index] = true; if(next == null) { for(int i = 0; i &amp;lt; tickets.length; i++) { if(!used[i]) result.add(tickets[i][1]); } break; } q.offer(next); result.add(next.end); j++; } for(int i = 0; i &amp;lt; result.size(); i++) { System.out.println(result.get(i)); } return result.toArray(new String[result.size()]); } private Path getPath(String start, String[][] tickets) { List&amp;lt;Path&amp;gt; sameDestinations = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; tickets.length; i++) { if(!used[i] &amp;amp;&amp;amp; tickets[i][0].equals(start)) { Path path = new Path(tickets[i][0], tickets[i][1], i); if(hasNext(path, tickets)) { sameDestinations.add(path); } } } Collections.sort(sameDestinations); return sameDestinations.size() &amp;gt; 0 ? sameDestinations.get(0) : null; } private boolean hasNext(Path path, String[][] tickets) { for(int i = 0; i &amp;lt; tickets.length; i++) { if(!used[i] &amp;amp;&amp;amp; tickets[i][0].equals(path.end)) { return true; } } return false; }}다시 고친 코드dfs를 통한 접근법입니다.import java.util.*;class Solution { List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); boolean[] visited; public String[] solution(String[][] tickets) { visited = new boolean[tickets.length]; dfs(0, &quot;ICN&quot;, &quot;ICN&quot;, tickets); Collections.sort(list); return list.get(0).split(&quot;/&quot;); } public void dfs(int depth, String start, String path, String[][] tickets) { if(depth == tickets.length) { list.add(path); return; } for(int i = 0; i &amp;lt; tickets.length; i++) { if(!visited[i] &amp;amp;&amp;amp; start.equals(tickets[i][0])) { visited[i] = true; dfs(depth + 1, tickets[i][1], path + &quot;/&quot; + tickets[i][1], tickets); visited[i] = false; } } }}" }, { "title": "프로그래머스 음양 더하기 풀이", "url": "/posts/prgrms76501/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-19 10:45:29 +0800", "snippet": "문제프로그래머스 음양 더하기 문제 링크내 생각부호가 true이냐, false이냐에 따라서 더하고 빼기를 해주면 된다.코드class Solution { public int solution(int[] absolutes, boolean[] signs) { int result = 0; for(int i = 0; i &amp;lt; signs.length; i++) { result += signs[i] ? absolutes[i] : -absolutes[i]; } return result; }}" }, { "title": "프로그래머스 프렌즈 4블록 풀이", "url": "/posts/prgrms17679/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-19 10:37:29 +0800", "snippet": "문제프로그래머스 프렌즈 4블록 문제 링크답안 링크내 생각구현 문제이다. 다음과 같은 방식으로 풀이했지만, 실력 부족으로 3개의 테스트 케이스에서 시간초과가 떴다. 삭제할 블록을 체크한다. 체크한 블록을 삭제한다. 삭제된 공간에 블럭을 내린다. 반복한다.답안과 논리는 같지만 구현실력에서 차이가 컸다. 당분간은 구현문제에 집중하려한다.코드import java.util.*;class Node { int x; int y; Node(int x, int y) { this.x = x; this.y = y; }}class Solution { char[][] map; int[] dx = {0, 1, 1}; int[] dy = {1, 0, 1}; boolean[][] deleted; public int solution(int m, int n, String[] board) { map = new char[m][n]; for(int i = 0; i &amp;lt; m; i++) { map[i] = board[i].toCharArray(); } int answer = 0; while(true) { deleted = new boolean[m][n]; for(int i = 0; i &amp;lt; m - 1; i++) { for(int j = 0; j &amp;lt; n - 1; j++) { if(map[i][j] != &#39;0&#39; &amp;amp;&amp;amp; map[i][j] == map[i][j + 1] &amp;amp;&amp;amp; map[i][j] == map[i + 1][j] &amp;amp;&amp;amp; map[i][j] == map[i + 1][j + 1]) { answer += bfs(i, j, m, n); } } } convert(m, n); for(int j = 0; j &amp;lt; n; j++) { for(int i = m - 1; i &amp;gt;= 0; i--) { if(map[i][j] == &#39;0&#39;) { for(int k = i - 1; k &amp;gt;= 0; k--) { if(map[k][j] != &#39;0&#39;) { map[i][j] = map[k][j]; map[k][j] = &#39;0&#39;; break; } } } } } if (check(m, n)) { break; } } return answer; } private void convert(int m, int n) { for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(deleted[i][j]) map[i][j] = &#39;0&#39;; } } } private int bfs(int x, int y, int m, int n) { int result = deleted[x][y] ? 0 : 1; Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(x, y)); deleted[x][y] = true; while(!q.isEmpty()) { Node now = q.poll(); x = now.x; y = now.y; int count = 0; for(int i = 0; i &amp;lt; 3; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;gt;= m || nx &amp;lt; 0 || ny &amp;gt;= n || ny &amp;lt; 0) continue; if(map[x][y] == map[nx][ny]) count++; } if(count == 3) { result += deleteCheck(x, y); q.offer(new Node(x, y + 1)); q.offer(new Node(x + 1, y)); q.offer(new Node(x + 1, y + 1)); } } return result; } private int deleteCheck(int x, int y) { int result = 0; if(!deleted[x][y]) { deleted[x][y] = true; result += 1; } for(int i = 0; i &amp;lt; 3; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(!deleted[nx][ny]) { deleted[nx][ny] = true; result += 1; } } return result; } private boolean check(int m, int n) { for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(deleted[i][j]) { return false; } } } return true; }}답안다른 사람들의 풀이를 보니 굳이 bfs를 사용하지 않고 깔끔하게 풀었다.import java.util.*;class Solution { public int solution(int m, int n, String[] board) { int answer = 0; char[][] map = new char[m][n]; for(int i = 0 ; i &amp;lt; m ; ++i) { map[i] = board[i].toCharArray(); } while(true) { int cnt = checkBlock(m, n, map); if(cnt == 0) break; answer += cnt; dropBlock(m, n, map); } return answer; } private void dropBlock(int m, int n, char[][] map) { for(int c = 0 ; c &amp;lt; n ; ++c) { for(int r = m - 1 ; r &amp;gt;= 0 ; --r) { if(map[r][c] == &#39;.&#39;) { for(int nr = r - 1 ; nr &amp;gt;= 0 ; --nr) { if(map[nr][c] != &#39;.&#39;) { map[r][c] = map[nr][c]; map[nr][c] = &#39;.&#39;; break; } } } } } } private int checkBlock(int m, int n, char[][] map) { int cnt = 0; boolean[][] isChecked = new boolean[m][n]; for(int i = 0 ; i &amp;lt; m - 1 ; ++i) { for(int j = 0 ; j &amp;lt; n - 1 ; ++j) { if(map[i][j] == &#39;.&#39;) continue; checkFour(map, isChecked, i, j); } } for(int i = 0 ; i &amp;lt; m ; ++i) { for(int j = 0 ; j &amp;lt; n ; ++j) { if(isChecked[i][j]) { cnt++; map[i][j] = &#39;.&#39;; } } } return cnt; } private void checkFour(char[][] map, boolean[][] isChecked, int i, int j) { char block = map[i][j]; for(int r = i ; r &amp;lt; i + 2 ; ++r) { for(int c = j ; c &amp;lt; j + 2 ; ++c) { if(map[r][c] != block) return; } } for(int r = i ; r &amp;lt; i + 2 ; ++r) { for(int c = j ; c &amp;lt; j + 2 ; ++c) { isChecked[r][c] = true; } } }}" }, { "title": "디자인 패턴(9) - Iterator 패턴", "url": "/posts/design(9).md/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-18 19:57:22 +0800", "snippet": "Design Pattern(9) - 이터레이터 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.문제 이해객체 마을 식당과 펜케이크 하우스가 합병을 합니다. 하지만 아직 매뉴를 합치는데 어려움을 겪고 있습니다. 그 이유는 식당의 경우 매뉴가 배열로 저장되어있지만, 펜케이크 하우스는 ArrayList에 저장이 되있네요. 바꾸기에는 양쪽 다 너무 많은 코드가 있다고 합니다. 어떻게 해야할까요?일단 두 식당 모두 메뉴 항목을 나타내는 MenuItem 을 구현하는 방법에 대해서는 합의를 봤습니다.public class MenuItem { String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public String getDescription() { return description; } public boolean isVegetarian() { return vegetarian; } public double getPrice() { return price; }}하지만 양쪽의 메뉴 리스트는 각각 ArrayList, Array 입니다.public class PancakeHouseMenu { List&amp;lt;MenuItem&amp;gt; menuItems; public PancakeHouseMenu() { menuItems = new ArrayList&amp;lt;&amp;gt;(); addItem(&quot;K&amp;amp;B 팬케이크 세트&quot;, &quot;스크램블드 에그와 토스트가 곁들어진 펜케이크&quot;, true, 2.99); addItem(&quot;레귤러 팬케이크 세트&quot;, &quot;달걀 후라이와 소시지가 곁들여진 펜케이크&quot;, false, 2.99); addItem(&quot;블루베리 팬케이크&quot;, &quot;신선한 블루베리와 블루베리 시럽으로 만든 펜케이크&quot;, true, 3.49); addItem(&quot;와플&quot;, &quot;와플, 취향에 따라 블루베리나 딸기를 얹을 수 있습니다.&quot;, true, 3.59); } public void addItem(String name, String description, boolean vegeterian, double price) { MenuItem menuItem = new MenuItem(name, description, vegeterian, price); menuItems.add(menuItem); } public List&amp;lt;MenuItem&amp;gt; getMenuItems() { return menuItems; }}public class DinnerMenu { static final int MAX_ITEMS = 6; int numberOfItems = 0; MenuItem[] menuItems; public DinnerMenu() { menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;채식주의자용 BLT&quot;, &quot;토마토를 얹은 메뉴&quot;, true, 2.99); addItem(&quot;BLT&quot;, &quot;통밀 위에 베이컨, 상추 , 토마토를 얹은 매뉴&quot;, false, 2.99); addItem(&quot;오늘의 스프&quot;, &quot;감자 셀러드를 곁들인 오늘의 스프&quot;, false, 3.29); addItem(&quot;핫도그&quot;, &quot;사워크라우트 갖은 양념, 양파, 치즈가 곁들여진 핫도그&quot;, false, 3.05); } public void addItem(String name, String description, boolean vegeterian, double price) { MenuItem menuItem = new MenuItem(name, description, vegeterian, price); if(numberOfItems &amp;gt;= MAX_ITEMS) { System.err.println(&quot;죄송합니다. 메뉴가 꽉 찼습니다.&quot;); } else { menuItems[numberOfItems] = menuItem; numberOfItems++; } }}이 두개의 메뉴판을 써야하는 웨이트리스는 난감합니다. for 반복문을 각각의 자료형마다 돌려줘야하는데요 이런 반복을 캡슐화 할 수는 없을까요?이터레이터 패턴이쯤에서 이터레이터 패턴을 만나봅시다. 가장 먼저 알아야할 것은 Iterator 라는 인터페이스에 의존한다는 점입니다. Iterator 인터페이스는 다음과 같습니다.public interface Iterator { boolean hasNext(); Object next();}이 인터페이스가 있으면 배열, 리스트, 해시테이블은 물론, 어떤 종류의 객체 컬렉션에 대해서도 반복자를 구현할 수 있습니다. 이제 Iterator를 이용하여 DinnerMenu 에 적용해 봅시다.public class DinnerMenuIterator implements Iterator{ MenuItem[] items; int position = 0; public DinnerMenuIterator(MenuItem[] items) { this.items = items; } @Override public boolean hasNext() { return position &amp;lt; items.length &amp;amp;&amp;amp; items[position] != null; } @Override public Object next() { MenuItem menuItem = items[position]; position++; return menuItem; }}public class DinnerMenu { static final int MAX_ITEMS = 6; int numberOfItems = 0; MenuItem[] menuItems; public DinnerMenu() { menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;채식주의자용 BLT&quot;, &quot;토마토를 얹은 메뉴&quot;, true, 2.99); addItem(&quot;BLT&quot;, &quot;통밀 위에 베이컨, 상추 , 토마토를 얹은 매뉴&quot;, false, 2.99); addItem(&quot;오늘의 스프&quot;, &quot;감자 셀러드를 곁들인 오늘의 스프&quot;, false, 3.29); addItem(&quot;핫도그&quot;, &quot;사워크라우트 갖은 양념, 양파, 치즈가 곁들여진 핫도그&quot;, false, 3.05); } // 앞으로는 이 메서드를 통해 Itertator를 만듦으로써 모든 컬랙션에 대해서 반복가능함 public Iterator createIterator() { return new DinnerMenuIterator(menuItems); } public void addItem(String name, String description, boolean vegeterian, double price) { MenuItem menuItem = new MenuItem(name, description, vegeterian, price); if(numberOfItems &amp;gt;= MAX_ITEMS) { System.err.println(&quot;죄송합니다. 메뉴가 꽉 찼습니다.&quot;); } else { menuItems[numberOfItems] = menuItem; numberOfItems++; } }}웨이트리스는 앞으로 해당 Iterator를 통해서 메뉴를 전달하면 됩니다.public class Waitress { PancakeHouseMenu pancakeHouseMenu; DinnerMenu dinnerMenu; public Waitress(PancakeHouseMenu pancakeHouseMenu, DinnerMenu dinnerMenu) { this.pancakeHouseMenu = pancakeHouseMenu; this.dinnerMenu = dinnerMenu; } public void printMenu() { Iterator pancakeIterator = pancakeHouseMenu.createIterator(); Iterator dinnerIterator = dinnerMenu.createIterator(); System.out.println(&quot;메뉴\\n-----\\n아침메뉴&quot;); printMenu(pancakeIterator); System.out.println(&quot;\\n점심 메뉴&quot;); printMenu(dinnerIterator); } private void printMenu(Iterator iterator) { while(iterator.hasNext()) { MenuItem menuItem = (MenuItem) iterator.next(); System.out.println(menuItem.getName() + &quot;, &quot;); System.out.println(menuItem.getPrice() + &quot;, &quot;); System.out.println(menuItem.getDescription()); } }}간단하게 테스트를 해봅시다.public class MenuTestDrive { public static void main(String[] args) { PancakeHouseMenu pancakeHouseMenu = new PancakeHouseMenu(); DinnerMenu dinnerMenu = new DinnerMenu(); Waitress waitress = new Waitress(pancakeHouseMenu, dinnerMenu); waitress.printMenu(); }}요약이터레이터 패턴은 서로다른 객체의 컬랙션들을 Iterator 라는 인터페이스를 통해서 각각의 반복을 돌릴 필요없이 Iterator를 사용하는 것으로 같은 메서드로 반복을 사용할 수 있게 해줍니다." }, { "title": "프로그래머스 단어변환 풀이", "url": "/posts/prgrms43163/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-18 08:37:29 +0800", "snippet": "문제단어 변환 문제 링크내 생각 DFS, BFS 의 전형적인 풀이로 풀 수 있습니다. 허나 DFS, BFS 풀이 법이라고 떠올리는게 어렵다고 판단되어 Level3 난이도가 주어진듯합니다. 로직은 다음과 같습니다 begin 문자열을 시작으로 dfs를 통해 문자 차이가 1개가 나는 문자열이 있을 경우, count를 올리고 해당 문자열로 넘어갑니다. 그러다가 문자열이 target과 같을 때, answer와 최솟값 비교를 합니다. return answer != (int) 1e9 ? answer : 0; 를 통해 정답을 리턴합니다. 코드class Solution { private boolean[] visited; private int answer = (int) 1e9; public int solution(String begin, String target, String[] words) { visited = new boolean[words.length]; dfs(begin, target, 0, words); return answer != (int) 1e9 ? answer : 0; } public void dfs(String begin, String target, int count, String[] words) { if(begin.equals(target)) { answer = Math.min(answer, count); return; } for(int i = 0; i &amp;lt; words.length; i++) { if(!visited[i] &amp;amp;&amp;amp; isDiffOneChar(begin, words[i])) { visited[i] = true; dfs(words[i], target, count + 1, words); visited[i] = false; } } } private boolean isDiffOneChar(String origin, String other) { int count = 0; for(int i = 0; i &amp;lt; origin.length(); i++) { count = origin.charAt(i) != other.charAt(i) ? count + 1 : count; } return count == 1; }}" }, { "title": "프로그래머스 피로도 풀이", "url": "/posts/prgrms87946/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-17 09:09:29 +0800", "snippet": "문제프로그래머스 피로도 문제 링크내 생각완전 탐색 문제이므로 dfs를 통해서 구현하는게 가장 편하다. 다음과 같이 풀었다. dfs를 위한 boolean[] visited를 만든다. dfs를 통해서 입장 가능한지 확인하고 그렇지 않으면 answer값과 비교한다. answer를 통해 가장 큰 값을 찾는다.코드class Solution { public static int answer; public static boolean[] visited; public int solution(int k, int[][] dungeons) { answer = 0; // 1 visited = new boolean[dungeons.length]; dfs(k, 0, dungeons); return answer; } public void dfs(int k, int count, int[][] dungeons) { for(int i = 0; i &amp;lt; dungeons.length; i++) { // 2 if(!visited[i] &amp;amp;&amp;amp; k &amp;gt;= dungeons[i][0]) { visited[i] = true; dfs(k - dungeons[i][1], count + 1, dungeons); visited[i] = false; } } // 3 answer = Math.max(answer, count); }}느낀 점보통 dfs를 사용할 때, if문을 통한 backtracking을 많이 썼었는데 이 문제는 그렇게하면 오히려 코드가 더 복잡해졌다. 기초적인 dfs 부터 좀 더 다지고 들어가야겠다." }, { "title": "프로그래머스 배달 풀이", "url": "/posts/prgrms12978/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-17 08:18:29 +0800", "snippet": "문제배달 문제 링크내 생각이 문제는 한 지점에서 다른 모든 지점의 최단 경로를 묻는 문제이다. 한 지점에서 다른 모든지점을 묻는다는 것은 플로이드-워셜 알고리즘을 쓰라는 뜻이다. 물론 다익스트라를 써도된다.다음과 같이 문제를 해결했다. map을 만들고, 모든 값을 INF(1e9) 로 설정한다. 자기 자신(map[i][i]) 는 0으로 설정한다. road[][] 를 순회하면서 road의 값을 map에 넣어준다. 단, 이 때 양방향인 것을 주의해야한다. 플로이드-워셜 알고리즘을 사용하여 최단거리를 구한다. 최단거리를 통해서 정답을 유추한다.코드import java.util.*;class Solution { public static final int INF = (int) 1e9; public static int[][] map; public int solution(int N, int[][] road, int K) { int answer = 0; map = new int[N + 1][N + 1]; // 1 for(int i = 0; i &amp;lt; N + 1; i++) { Arrays.fill(map[i], INF); } // 2 for(int i = 1; i &amp;lt; N + 1; i++) { map[i][i] = 0; } // 3 for(int[] r: road) { map[r[0]][r[1]] = Math.min(map[r[0]][r[1]], r[2]); map[r[1]][r[0]] = Math.min(map[r[1]][r[0]], r[2]); } // 4 for(int k = 1; k &amp;lt; N + 1; k++) { for(int i = 1; i &amp;lt; N + 1; i++) { for(int j = 1; j &amp;lt; N + 1; j++) { map[i][j] = Math.min(map[i][j], map[i][k] + map[k][j]); } } } // 5 for(int j = 1; j &amp;lt; N + 1; j++) { answer = map[1][j] &amp;lt;= K ? answer + 1 : answer; } return answer; }}" }, { "title": "프로그래머스 괄호 회전하기 풀이", "url": "/posts/prgrms76502/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-15 08:46:29 +0800", "snippet": "문제내 생각주어진 문자열에 앞뒤로 문자 연산을 해주고, 회전 시킨뒤 stack을 이용하여 옳은 괄호인지 판단하면된다코드import java.util.*;class Solution { Map&amp;lt;Character, Character&amp;gt; map; public int solution(String s) { int length = s.length(); map = new HashMap&amp;lt;&amp;gt;(); map.put(&#39;[&#39;, &#39;]&#39;); map.put(&#39;{&#39;, &#39;}&#39;); map.put(&#39;(&#39;, &#39;)&#39;); int answer = 0; for(int i = 0; i &amp;lt; length; i++) { s = new StringBuilder(s.substring(1, length)).append(s.charAt(0)).toString(); answer = isCorrect(s) ? answer + 1 : answer; } return answer; } private boolean isCorrect(String s){ Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; s.length(); i++) { if(map.containsKey(s.charAt(i))) { stack.push(s.charAt(i)); } else { if(stack.isEmpty()) return false; Character c = stack.pop(); if(map.get(c) != s.charAt(i)) { return false; } } } return stack.isEmpty(); }}답안프로그래머스에서 많은 좋아요를 받은 코드이다. 코드가 간결하고 이쁘다.import java.util.Stack;class Solution { private final Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;(); public int solution(String s) { int answer = 0; StringBuilder stringBuilder = new StringBuilder(s); for (int i = 0; i &amp;lt; s.length(); i++) { stringBuilder.append(stringBuilder.charAt(0)); stringBuilder.deleteCharAt(0); if (correctParenthesis(stringBuilder.toString().toCharArray())) answer++; } return answer; } private boolean correctParenthesis(char[] s) { for (char c : s) { if (!(check(c, &#39;(&#39;, &#39;)&#39;) &amp;amp;&amp;amp; check(c, &#39;[&#39;, &#39;]&#39;) &amp;amp;&amp;amp; check(c, &#39;{&#39;, &#39;}&#39;))) return false; } return stack.isEmpty(); } private boolean check(char c, char a, char b) { if (c == a) stack.push(a); else if (c == b) if (!stack.isEmpty() &amp;amp;&amp;amp; stack.peek() == a) stack.pop(); else return false; return true; }}" }, { "title": "프로그래머스 신고 결과 받기 풀이", "url": "/posts/prgrms92334/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-14 13:22:29 +0800", "snippet": "문제신고 결과 받기 문제 링크내 생각다음과 같은 로직으로 풀었다. Map&amp;lt;신고 당한 사람, set&amp;lt;신고한 사람&amp;gt;&amp;gt; 으로 매핑하여, 신고를 한 사람에게 여러번해도 set 자료구조로 중복제거가 되게 한다. map을 순회하며 set&amp;lt;신고한 사람&amp;gt; 의 크기가 k 이상이면 answer[신고한 사람] += 1 을 해준다.코드import java.util.*;import java.util.Map.Entry;class Solution { Map&amp;lt;String, HashSet&amp;lt;String&amp;gt;&amp;gt; map; public int[] solution(String[] id_list, String[] report, int k) { map = new HashMap&amp;lt;&amp;gt;(); int[] answer = new int[id_list.length]; for(String id: id_list) { map.put(id, new HashSet&amp;lt;&amp;gt;()); } for(String str: report) { String[] split = str.split(&quot; &quot;); Set&amp;lt;String&amp;gt; reportList = map.get(split[1]); reportList.add(split[0]); } Iterator iterator = map.entrySet().iterator(); while(iterator.hasNext()) { Entry entry = (Entry) iterator.next(); HashSet&amp;lt;String&amp;gt; value = (HashSet&amp;lt;String&amp;gt;) entry.getValue(); if(value.size() &amp;gt;= k) { for(String str: value) { answer[Arrays.asList(id_list).indexOf(str)] += 1; } } } return answer; }}" }, { "title": "프로그래머스 후보키 풀이", "url": "/posts/prgrms42890/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-14 09:45:29 +0800", "snippet": "문제프로그래머스 후보키 문제 링크내 생각다음과 같이 문제를 풀었다. dfs를 통한 조합으로 튜플 쌍을 만든다. 이 때, 길이를 고려해서 만들어준다. 만든 튜플 쌍을 토대로, 기존에 유일성과 최소성을 만족시킨 튜플 쌍을 포함하는지 확인한다. 포함된다면 이미 최소성 충족이 안되기 때문에 return 포함되지 않는다면 유일성 검사를 진행한다. 유일성도 만족되면 keySetList에 넣고 이를 계속 반복한다. keySetList 의 길이를 구한다.코드import java.util.*;class Solution { ArrayList&amp;lt;HashSet&amp;lt;Integer&amp;gt;&amp;gt; keySetList; public int solution(String[][] relation) { keySetList = new ArrayList&amp;lt;&amp;gt;(); int c = relation[0].length; for(int i = 1; i &amp;lt;= c; i++) { combination(0, i, 0, c, new HashSet&amp;lt;&amp;gt;(), relation); } return keySetList.size(); } private void combination(int depth, int max, int start, int end, HashSet&amp;lt;Integer&amp;gt; keySet, String[][] relation) { if(depth == max) { for(HashSet&amp;lt;Integer&amp;gt; key: keySetList) { if(keySet.containsAll(key)) { return; } } if(isUnique(keySet, relation)) { keySetList.add(keySet); } else { } return; } for(int i = start; i &amp;lt; end; i++) { HashSet&amp;lt;Integer&amp;gt; newKeySet = new HashSet&amp;lt;&amp;gt;(keySet); newKeySet.add(i); combination(depth + 1, max, i, end, newKeySet, relation); } } private boolean isUnique(HashSet&amp;lt;Integer&amp;gt; keySet, String[][] relation) { Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int r = 0; r &amp;lt; relation.length; r++) { String key = &quot;&quot;; for(int c: keySet) { key += relation[r][c]; } if(map.containsKey(key)) { return false; } else { map.put(key, key); } } return true; }}느낀 점dfs를 통해 순열, 조합을 하는 것이 아직도 안익숙하다. 특정 기간동안은 bfs, dfs 문제를 계속 풀면서익숙해져야겠다.또한 Collections.containsAll() 메서드는 처음 쓰는데, 유용하게 쓸 것 같다" }, { "title": "프로그래머스 순위 검색 풀이", "url": "/posts/prgrms72412/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-13 13:19:29 +0800", "snippet": "문제순위 검색 문제 링크내 생각주어진 문자열을 파싱해서 list에 넣은다음 단순 비교를 통해서 문제를 풀었다. 정확도는 만점이지만 효율성에서 떨어지고 말았다… 너무 단순하게 생각했나보다. 지원자의 크기가 50000, query가 100000 이니단순 비교하면 50억번의 연산이 일어난다. 단순 비교가 아닌 다른 방식을 생각해야만 했다.코드아래는 정확도는 맞았지만 효율성은 광탈 당한 코드이다.import java.util.*;class Applicant { String language; String field; String career; String soulFood; int score; public Applicant(String language, String field, String career, String soulFood, int score) { this.language = language; this.field = field; this.career = career; this.soulFood = soulFood; this.score = score; } public boolean doesFitCondition(String language, String field, String career, String soulFood, int score) { if(!this.language.equals(language) &amp;amp;&amp;amp; !language.equals(&quot;-&quot;)) { return false; } if(!this.field.equals(field) &amp;amp;&amp;amp; !field.equals(&quot;-&quot;)) { return false; } if(!this.career.equals(career) &amp;amp;&amp;amp; !career.equals(&quot;-&quot;)) { return false; } if(!this.soulFood.equals(soulFood) &amp;amp;&amp;amp; !soulFood.equals(&quot;-&quot;)) { return false; } if(score &amp;gt; this.score) { return false; } return true; }}class Solution { List&amp;lt;Applicant&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public int[] solution(String[] info, String[] query) { for(String str: info) { String[] split = str.split(&quot; &quot;); list.add(new Applicant(split[0], split[1], split[2], split[3], Integer.parseInt(split[4]))); } int[] answer = new int[query.length]; for(int i = 0; i &amp;lt; query.length; i++) { String[] split = query[i].split(&quot; and | &quot;); int count = 0; for(int j = 0; j &amp;lt; list.size(); j++) { Applicant applicant = list.get(j); if(applicant.doesFitCondition( split[0], split[1], split[2], split[3], Integer.parseInt(split[4]) )) { count++; } } answer[i] = count; } return answer; }}답안답안에서는 다음과 같이 해결했다. 답안 링크 점수를 제외한 query에 뽑힐 수 있는 모든 경우의 수를 만든다. 점수를 기준으로 정렬한다. 이진탐색을 통해 query[]에 해당하는 인원수를 찾는다.import java.util.*;class Solution { static Map&amp;lt;String, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; allInfo; static ArrayList&amp;lt;Integer&amp;gt; in; public int[] solution(String[] info, String[] query) { int[] answer = new int[query.length]; allInfo = new HashMap&amp;lt;&amp;gt;(); // 1. info 모든 경우의 수 map에 저장 for(int i=0; i&amp;lt;info.length; i++) { dfs(&quot;&quot;,0, info[i].split(&quot; &quot;)); } // 2. map에 저장된 점수 list 오름차순으로 정렬 List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(allInfo.keySet()); for(int i=0; i&amp;lt;list.size(); i++) { List&amp;lt;Integer&amp;gt; scoreList = allInfo.get(list.get(i)); Collections.sort(scoreList); } for(int i=0; i&amp;lt;query.length; i++) { query[i] = query[i].replaceAll(&quot; and &quot;, &quot;&quot;); String[] str = query[i].split(&quot; &quot;); int score = Integer.parseInt(str[1]); answer[i] = search(str[0], score); } return answer; } static void dfs(String pos, int depth, String[] info) { if(depth == 4) { if(!allInfo.containsKey(pos)) { in = new ArrayList&amp;lt;&amp;gt;(); in.add(Integer.parseInt(info[4])); allInfo.put(pos, in); }else { allInfo.get(pos).add(Integer.parseInt(info[4])); } return; } dfs(pos+&quot;-&quot;, depth+1, info); dfs(pos+info[depth], depth+1, info); } // 이분 탐색 static int search(String str, int score) { if(!allInfo.containsKey(str)) return 0; List&amp;lt;Integer&amp;gt; scoreList = allInfo.get(str); int start= 0, end = scoreList.size()-1; while(start&amp;lt;=end) { int mid =(start+end)/2; if(scoreList.get(mid) &amp;lt;score) { start = mid+1; }else { end = mid-1; } } return scoreList.size()-start; }}" }, { "title": "프로그래머스 전화번호 목록 풀이", "url": "/posts/prgrms42577/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-13 12:18:29 +0800", "snippet": "문제전화번호 목록 문제 링크내 생각주어진 전화번호부를 모두 map의 키로 등록 한 뒤, 전화번호부를 순회하며 전화번호를 하나씩 잘라 키에 있는지 확인한다.단, 전화번호를 자를 때, 해당 전화번호가 검색되지 않도록 length - 1 까지만 잘라준다.코드import java.util.*;class Solution { public boolean solution(String[] phone_book) { Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; phone_book.length; i++) { map.put(phone_book[i], i); } for(int i = 0; i &amp;lt; phone_book.length; i++) { for(int j = 1; j &amp;lt; phone_book[i].length(); j++) { if (map.containsKey(phone_book[i].substring(0, j))) { return false; } } } return true; }}" }, { "title": "프로그래머스 없는 숫자 더하기 풀이", "url": "/posts/prgrms86051/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-12 14:16:29 +0800", "snippet": "문제없는 숫자 더하기 문제 링크내 생각0 ~ 9 중에 없는 숫자의 값을 찾는 것이기 때문에 0 ~ 9를 모두 더한 45에 주어진 배열의 총합을 빼면 된다.코드import java.util.*;class Solution { public int solution(int[] numbers) { return 45 - Arrays.stream(numbers).sum(); }}느낀 점stream().reduce((x, y) -&amp;gt; x, y) 는 리턴값으로 Optional 를 주고, 앞에 accumulator가 있으면(`stream().reduce(0, (x, y) -&amp;gt; x, y)`) 그냥 int를 준다는 것을 알았다.또한 stream().sum() 함수는 몰랐는데 이번에 알게되어 유용하게 쓸 것 같다." }, { "title": "프로그래머스 빛의 경로 사이클 풀이", "url": "/posts/prgrms86502/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-12 14:03:29 +0800", "snippet": "문제빛의 경로 사이클 문제 링크내 생각문제를 제대로 이해조차 하지 못했다. 아니 읽기는 했으나 문제를 해결할 방법을 생각하지 못했다. 4개의 방향으로 오는 것을 어떻게 판단해야할지 몰라 결국제대로된 풀이 전에 정답을 봤고, 정답을 보고도 이해하느라 꽤 오랜시간을 썼다.아래 코드는 4개의 방향을 boolean[] 내의 4개의 boolean으로 판단했다. visited 라는 배열을통해 해당 방향으로 왔었는가를 판단하면서 문제를 풀이했다.코드이 답안의 링크는 아래와 같다. 설명도 상세하게 해주셔서 많은 도움을 받았다.정답 링크import java.util.*;class Solution { static int[] dx = {-1, 0, 1, 0}; static int[] dy = {0, -1, 0, 1}; static int X; static int Y; static boolean[][][] visited; public int[] solution(String[] grid) { List&amp;lt;Integer&amp;gt; answer = new ArrayList&amp;lt;&amp;gt;(); X = grid.length; Y = grid[0].length(); visited = new boolean[X][Y][4]; for(int i = 0 ; i &amp;lt; X; i++) { for(int j = 0; j &amp;lt; Y; j++) { for(int d = 0; d &amp;lt; 4; d++) { if(!visited[i][j][d]) { answer.add(draw(i, j, d, grid)); } } } } Collections.sort(answer); return answer.stream().mapToInt(i-&amp;gt;i).toArray(); } private int draw(int x, int y, int d, String[] grid) { int cnt = 0; while(true) { if(visited[x][y][d]) { break; } cnt++; visited[x][y][d] = true; if(grid[x].charAt(y) == &#39;L&#39;) { d = d == 0 ? 3 : d - 1; } else if(grid[x].charAt(y) == &#39;R&#39;) { d = d == 3 ? 0 : d + 1; } x = (x + dx[d] + X) % X; y = (y + dy[d] + Y) % Y; } return cnt; }}" }, { "title": "디자인 패턴(7) - Adapter 패턴", "url": "/posts/design(7).md/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-11 16:44:22 +0800", "snippet": "Design Pattern(7) : Adaptor 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.객체지향 어댑터어댑터는 클라이언트로부터 요청을 받아서 새로운 업체에서 제공하는 클래스에서 받아들일 수 있는 형태의 요청으로 변환시켜주는 중개인 역할을 합니다.예시를 하나 들어봅시다. 1장에서 살펴보았던 오리를 조금 단순화 시켜 사용해보겠습니다.public interface Duck { void quack(); void fly();}이 때 새로 등장한 가금류가 있다면 어떻게 될까요?public interface Turkey { void gobble(); void fly();}이 둘은 호환이 서로 안됩니다(다른 인터페이스이기 때문에). 여기서 이 둘을 호환시키게 하는 것이 어댑터 패턴입니다. 아래 예시를 보시죠// 적용시킬 대상의 인터페이스를 구현해야합public class TurkeyAdapter implements Duck{ private final Turkey turkey; public TurkeyAdapter(Turkey turkey) { this.turkey = turkey; } @Override public void quack() { turkey.gobble(); } @Override public void fly() { for (int i = 0; i &amp;lt; 5; i++) { // 칠면조는 오리처럼 날지 못합니다. Turkey의 fly() 메소드를 Duck의 fly() // 에 대응시키기 위해서 5번 호출시킵니다. turkey.fly(); } }}변환 목적 대상의 인터페이스를 구현하고, 변환 시켜야하는 대상의 인스턴스를 가져서 목적대상의 메소드가 호출될 때, 인스턴스에 메소드를 실행시켜주면 됩니다." }, { "title": "프로그래머스 숫자 문자열과 영단어 풀이", "url": "/posts/prgrms81301/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-11 10:32:29 +0800", "snippet": "문제숫자 문자열과 영단어 풀이 문제 링크내 생각zero ~ nine 까지를 map을 통해서 찾아 넣는 방식으로 생각했다.코드import java.util.*;class Solution { Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); public int solution(String s) { inputData(); StringBuilder sb = new StringBuilder(); StringBuilder answer = new StringBuilder(); for(int i = 0; i &amp;lt; s.length(); i++) { char c = s.charAt(i); if(Character.isDigit(c)) { if(sb.length() &amp;gt; 0) { answer.append(map.get(sb.toString())); sb = new StringBuilder(); } answer.append(c); } else { sb.append(c); if(map.containsKey(sb.toString())) { answer.append(map.get(sb.toString())); sb = new StringBuilder(); } } } return Integer.parseInt(answer.toString()); } private void inputData() { map.put(&quot;zero&quot;, &quot;0&quot;); map.put(&quot;one&quot;, &quot;1&quot;); map.put(&quot;two&quot;, &quot;2&quot;); map.put(&quot;three&quot;, &quot;3&quot;); map.put(&quot;four&quot;, &quot;4&quot;); map.put(&quot;five&quot;, &quot;5&quot;); map.put(&quot;six&quot;, &quot;6&quot;); map.put(&quot;seven&quot;, &quot;7&quot;); map.put(&quot;eight&quot;, &quot;8&quot;); map.put(&quot;nine&quot;, &quot;9&quot;); }}답안replaceAll 을 생각했다면 너무 쉽게 풀 문제였다…class Solution { public int solution(String s) { String[] strArr = {&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;}; for(int i = 0; i &amp;lt; strArr.length; i++) { s = s.replaceAll(strArr[i], Integer.toString(i)); } return Integer.parseInt(s); }}" }, { "title": "프로그래머스 수식 최대화 풀이", "url": "/posts/prgrms67257/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-11 09:57:29 +0800", "snippet": "문제프로그래머스 수식 최대화 문제 링크내 생각처음에는 리스트에 있는 long과 연산자를 이용한 계산에 실패하여 답을 봤다.답을 보고 해당 부분의 문제를 해결하니 쉽게 풀리는 문제였다.문제 풀이는 다음과 같았다. 주어진 expression을 숫자와 특수문자로 쪼개어 각각 보관한다. 연산자의 조합 6개를 계산한 뒤, 해당 값들을 비교하여 가장 큰 값을 정답에 넣는다.코드import java.util.*;class Solution { public long solution(String expression) { String[] split = expression.split(&quot;((?=[*+-])|(?&amp;lt;=[*+-]))&quot;); List&amp;lt;Long&amp;gt; numbers = new ArrayList&amp;lt;&amp;gt;(); List&amp;lt;Character&amp;gt; operators = new ArrayList&amp;lt;&amp;gt;(); for(String str: split) { if(Character.isDigit(str.charAt(0))) { numbers.add(Long.parseLong(str)); } else { operators.add(str.charAt(0)); } } long[] result = new long[6]; result[0] = operation(numbers, operators, &#39;+&#39;, &#39;-&#39;, &#39;*&#39;); result[1] = operation(numbers, operators, &#39;+&#39;, &#39;*&#39;, &#39;-&#39;); result[2] = operation(numbers, operators, &#39;-&#39;, &#39;+&#39;, &#39;*&#39;); result[3] = operation(numbers, operators, &#39;-&#39;, &#39;*&#39;, &#39;+&#39;); result[4] = operation(numbers, operators, &#39;*&#39;, &#39;-&#39;, &#39;+&#39;); result[5] = operation(numbers, operators, &#39;*&#39;, &#39;+&#39;, &#39;-&#39;); long answer = 0; for(int i = 0; i &amp;lt; 6; i++) { answer = Math.max(answer, Math.abs(result[i])); } return answer; } public long calc(long a, long b, char op) { switch(op) { case(&#39;+&#39;) : return a + b; case(&#39;-&#39;) : return a - b; case(&#39;*&#39;) : return a * b; } return 0; } public void calc(List&amp;lt;Long&amp;gt; numbers, List&amp;lt;Character&amp;gt; ops, char op) { for(int i = 0; i &amp;lt; ops.size(); i++) { if(ops.get(i) == op) { long num1 = numbers.get(i); long num2 = numbers.get(i + 1); long result = calc(num1, num2, op); numbers.remove(i); numbers.remove(i); numbers.add(i, result); ops.remove(i); i--; } } } public long operation(List&amp;lt;Long&amp;gt; nums, List&amp;lt;Character&amp;gt; opers, char op1, char op2, char op3) { ArrayList&amp;lt;Long&amp;gt; numbers = new ArrayList&amp;lt;&amp;gt;(nums); ArrayList&amp;lt;Character&amp;gt; ops = new ArrayList&amp;lt;&amp;gt;(opers); calc(numbers, ops, op1); calc(numbers, ops, op2); calc(numbers, ops, op3); return numbers.get(0); }}느낀 점" }, { "title": "프로그래머스 거리두기 확인하기 풀이", "url": "/posts/prgrms81302/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-10 10:21:29 +0800", "snippet": "문제거리두기 확인하기 문제 링크내 생각bfs, dfs 등을 이용한 문제이다. 나의 경우는 쉬운해결을 위해 각각의 조건을 dx, dy의 배열을 이용하여 문제를 풀었다.허나 이렇게 풀었을 경우, 코드가 꽤 많이 길어진다는 안좋은 점이 있다. 다른 사람의 dfs 를 이용한 풀이는 내 절반정도의 코드 길이를 가지고있다.심지어 속도도 더 빠르다…코드//1. 대기실을 순회한다//2. 대기실을 순회하면서 거리두기를 판단한다.import java.util.*;class Solution { int[] dxDistOne = {-1, 0, 1, 0}; int[] dyDistOne = {0, 1, 0, -1}; int[] dxStraight = {-2, 0, 2, 0}; int[] dyStraight = {0, 2, 0, -2}; int[] dxDiagonal = {-1, -1, 1, 1}; int[] dyDiagonal = {-1, 1, 1, -1}; public int[] solution(String[][] places) { int length = places.length; int[] answer = new int[length]; for(int i = 0; i &amp;lt; length; i++) { String[][] map = getMap(places[i], length); answer[i] = isKeeping(map, length) ? 1 : 0; } return answer; } private boolean search(int x, int y, int n, String[][] map) { for(int i = 0; i &amp;lt; 4; i++) { int nx = x + dxDistOne[i]; int ny = y + dyDistOne[i]; if(nx &amp;gt;= n || nx &amp;lt; 0 || ny &amp;gt;= n || ny &amp;lt; 0) continue; if(map[nx][ny].equals(&quot;P&quot;)) return false; } for(int i = 0; i &amp;lt; 4; i++) { int nx = x + dxStraight[i]; int ny = y + dyStraight[i]; int partitionX = x + dxDistOne[i]; int partitionY = y + dyDistOne[i]; if(nx &amp;gt;= n || nx &amp;lt; 0 || ny &amp;gt;= n || ny &amp;lt; 0) continue; if(map[nx][ny].equals(&quot;P&quot;) &amp;amp;&amp;amp; !map[partitionX][partitionY].equals(&quot;X&quot;)) return false; } for(int i = 0; i &amp;lt; 4; i++) { int nx = x + dxDiagonal[i]; int ny = y + dyDiagonal[i]; if(nx &amp;gt;= n || nx &amp;lt; 0 || ny &amp;gt;= n || ny &amp;lt; 0) continue; if(map[nx][ny].equals(&quot;P&quot;) &amp;amp;&amp;amp; (map[x][ny].equals(&quot;O&quot;) || map[nx][y].equals(&quot;O&quot;))) return false; } return true; } private boolean isKeeping(String[][] map, int length) { for(int i = 0; i &amp;lt; length; i++) { for(int j = 0; j &amp;lt; length; j++) { if(map[i][j].equals(&quot;P&quot;)) { if(!search(i, j, length, map)) { return false; } } } } return true; } private String[][] getMap(String[] arr, int length) { String[][] result = new String[length][length]; for(int i = 0; i &amp;lt; length; i++) { String[] split = arr[i].split(&quot;&quot;); for(int j = 0; j &amp;lt; split.length; j++) { result[i][j] = split[j]; } } return result; }}답안프로그래머스에 나온 가장 많은 좋아요를 받은 답안이다.class Solution { static int[] dx = {-1, 0, 1, 0}; static int[] dy = {0, 1, 0, -1}; static boolean[][] visit; static int[] answer; public void dfs(int num, int x, int y, int count, String[] places){ if (count &amp;gt; 2) return; if (count &amp;gt; 0 &amp;amp;&amp;amp; count &amp;lt;= 2 &amp;amp;&amp;amp; places[x].charAt(y) == &#39;P&#39;){ //2칸 범위내에 다른 응시자가 있을 경우 거리두기 미준수로 0처리 answer[num] = 0; return; } for (int i = 0; i &amp;lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; //배열 범위 밖으로 초과하는지 여부 검사, 파티션으로 분리되어 있는 경우 상관 없음. if (nx &amp;gt;= 0 &amp;amp;&amp;amp; nx &amp;lt; 5 &amp;amp;&amp;amp; ny &amp;gt;= 0 &amp;amp;&amp;amp; ny &amp;lt; 5 &amp;amp;&amp;amp; places[nx].charAt(ny) != &#39;X&#39;) { if (visit[nx][ny]) continue; //이미 방문한 곳일 경우 생략 visit[nx][ny] = true; dfs(num, nx, ny, count + 1, places); visit[nx][ny] = false; } } } public int[] solution(String[][] places) { answer = new int[places.length]; for (int i = 0; i &amp;lt; places.length; i++) { answer[i] = 1; } for (int i = 0; i &amp;lt; places.length; i++) { visit = new boolean[5][5]; for (int j = 0; j &amp;lt; 5; j++) { for (int k = 0; k &amp;lt; 5; k++) { if (places[i][j].charAt(k) == &#39;P&#39;){ visit[j][k] = true; dfs(i, j, k, 0, places[i]); visit[j][k] = false; } } } } return answer; }}" }, { "title": "디자인 패턴(6) - Command 패턴", "url": "/posts/design(6).md/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-09 14:22:22 +0800", "snippet": "Design Pattern(6) - Command 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.문제 이해이번에는 홈 오토메이션 리모컨의 API 디자인을 의뢰받았습니다. 이 리모컨에는 7가지 프로그래밍이 관한 슬롯과 각 슬롯에 대한 온 / 오프 스위치가 있습니다. 각 슬롯은 다른 서로 다른 가정용 기기에 연결할 수 있습니다. 리모컨에는 작업 취소(undo) 버튼도 있습니다.가전제품 제작사에서 준 클래스들을 살펴보니 on(), off() 메서드가 있는 TV, Stereo 같은 클래스 들도 있지만 그 외에 arm(), disarm() 같은 메서드들을 가진 SecurityControl 같은 클래스들도 있습니다. 같은 인터페이스로 묶여있는 상황이 아닌 것 같습니다.물리적인 버튼은 on / off 밖에 없고 메서드 이름은 제 각각 이니 머리가 아프네요.커멘드 패턴커멘트 패턴은 작업을 요청한 쪽과 처리하는 쪽을 분리시킬 수 있습니다. 리모컨에서 작업을 요청하고 업체에서 공급한 클래스에서 그 작업을 처리한다고 한다면 이 둘을 분리시킬 수 있겠네요.식당으로 예를 들어봅시다. 고객이 점원에게 하는 주문은 요청입니다. 점원이 주방장에게 하는 주문은 처리 입니다. 고객과 주방장 사이에 있는 점원이 요청과 처리를 분리시켜주고 있네요. 딱 저희가 생각하는 그림인 것 같습니다.아래 그림은 커멘드 패턴에 다이어그램입니다.구현일단 Command 인터페이스와 구상체 부터 만들어보죠.public interface Command { void execute();}public class Light { public void on() { System.out.println(&quot;Light on&quot;); } public void off() { System.out.println(&quot;Light off&quot;); }}public class LightOnCommand implements Command { private Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.on(); }}이제 이 커멘드를 사용할 리모컨을 만들어봅시다.public class RemoteControl { Command[] onCommands; Command[] offCommands; public RemoteControl() { this.onCommands = new Command[7]; this.offCommands = new Command[7]; } public void setCommands(int slot, Command onCommand, Command offCommand) { onCommands[slot] = onCommand; offCommands[slot] = offCommand; } public void onButtonWasPushed(int slot) { onCommands[slot].execute(); } public void offButtonWasPushed(int slot) { offCommands[slot].execute(); }}간단한 테스트 코드입니다public class RemoteControlTest { public static void main(String[] args) { SimpleRemoteControl remote = new SimpleRemoteControl(); Light light = new Light(); LightOnCommand lightOn = new LightOnCommand(light); remote.setCommand(lightOn); remote.buttonWasPressed(); }}UNDO 기능 추가이번에는 UNDO 기능을 추가해봅시다. 커멘드에서 작업 취소 기능을 지원하려면 execute() 메소드하고 비슷한 undo() 가 있어야합니다. execute()에서 한 작업의 정반대를 처리하면 될 것입니다.public interface Command { void execute(); void undo();}public class LightOnCommand implements Command { private Light light; public LightOnCommand(Light light) { this.light = light; } @Override public void execute() { light.on(); } @Override public void undo() { light.off(); }}이제 RemoteControl 클래스에 사용자가 마지막으로 누른 버튼을 기록하고, UNDO 버튼이 눌렸을 때 필요한 작업을 처리하기 위한 코드를 추가해야합니다. NoCommand 는 널 객체입니다.public class NoCommand implements Command { @Override public void execute() { } @Override public void undo() { }}public class RemoteControl { Command[] onCommands; Command[] offCommands; Command undoCommand; public RemoteControl() { this.onCommands = new Command[7]; this.offCommands = new Command[7]; for (int i = 0; i &amp;lt; 7; i++) { onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); } undoCommand = new NoCommand(); } public void setCommands(int slot, Command onCommand, Command offCommand) { onCommands[slot] = onCommand; offCommands[slot] = offCommand; } public void onButtonWasPushed(int slot) { onCommands[slot].execute(); undoCommand = onCommands[slot]; } public void offButtonWasPushed(int slot) { offCommands[slot].execute(); undoCommand = onCommands[slot]; } public void undoButtonWasPressed() { undoCommand.undo(); }}정리커멘드 패턴은 요청들을 객체로 캡슐화하여 클라이언트를 서로 다른 요청 내역에 따라 매개변수화 할 수 있습니다. 요청을 큐에 저장하거나 로그로 기록할 수도 있고 작업 취소 기능을 지원할 수도있습니다." }, { "title": "프로그래머스 뉴스 클러스터링 풀이", "url": "/posts/prgrms17677/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-09 14:08:33 +0800", "snippet": "문제뉴스 클러스터링 문제 링크내 생각구현 문제로, 문자열을 2자리 씩 자른 뒤, 영문만 있는지 확인한 뒤에 교집합을 구하면 되는 문제이다.코드import java.util.*;class Solution { public int solution(String str1, String str2) { String[] str1Split = parse(str1); String[] str2Split = parse(str2); int intersection = getIntersection(str1Split, str2Split); int union = str1Split.length + str2Split.length - intersection; double answer = union == 0 ? 1 : ((double) intersection / union); return (int) (65536 * answer); } private String[] parse(String str) { List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; str.length() - 1; i++) { String subStr = str.substring(i, i + 2); if(subStr.matches(&quot;^[a-zA-Z]*$&quot;)) { result.add(subStr.toLowerCase()); } } return result.toArray(new String[result.size()]); } private int getIntersection(String[] arr1, String[] arr2) { int result = 0; boolean[] visited1 = new boolean[arr1.length]; boolean[] visited2 = new boolean[arr2.length]; for(int i = 0; i &amp;lt; arr1.length; i++) { for(int j = 0; j &amp;lt; arr2.length; j++) { if(arr2[j].equals(arr1[i]) &amp;amp;&amp;amp; !(visited1[i] || visited2[j])) { visited1[i] = true; visited2[j] = true; result++; } } } return result; }}느낀 점정규식을 본적은 많지만 제대로 공부하거나 파본 경험이 없기 때문에 문제 풀이 중에정규식 관련하여 많이 해맸다. 또한 교집합을 구할 때, boolean 배열을 이용하여 구했는데, list를이용하여 원소제거로 구하는 방식은 어떠했을지 궁금하다." }, { "title": "프로그래머스 매뉴 리뉴얼 풀이", "url": "/posts/prgrms72411/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-08 13:56:33 +0800", "snippet": "문제매뉴 리뉴얼 문제 풀이내 생각주어진 주문을 가지고 dfs를 통한 조합을 뽑아서 해당 조합을 map의 key로 등록한다. 그 후에다른 주문들을 통해 해당 조합이 나오면 value + 1을 하는 방식으로 가능한 코스 조합을 완전 탐색한다.코드import java.util.*;class Solution { Map&amp;lt;String, Integer&amp;gt; courseMap = new HashMap&amp;lt;&amp;gt;(); List&amp;lt;String&amp;gt; courses = new ArrayList&amp;lt;&amp;gt;(); public String[] solution(String[] orders, int[] course) { for(String order: orders) { String[] split = order.split(&quot;&quot;); Arrays.sort(split); for(int i: course) { addCourse(split, new String[i], 0, 0, i); } } for(int i: course) { confirmCourse(i); } String[] answer = courses.toArray(new String[courses.size()]); Arrays.sort(answer); return answer; } private void confirmCourse(int length) { int max = 0; for(String key: courseMap.keySet()) { int value = courseMap.get(key); if(key.length() == length &amp;amp;&amp;amp; value &amp;gt; 1) { max = Math.max(max, value); } } for(String key: courseMap.keySet()) { int value = courseMap.get(key); if(key.length() == length &amp;amp;&amp;amp; value == max) { courses.add(key); } } } private void addCourse(String[] arr, String[] output, int start, int depth, int r) { if (depth == r) { String course = String.join(&quot;&quot;, output); if(courseMap.containsKey(course)) { courseMap.put(course, courseMap.get(course) + 1); } else { courseMap.put(course, 1); } return; } for(int i = start; i &amp;lt; arr.length; i++) { output[depth] = arr[i]; addCourse(arr, output, i + 1, depth + 1, r); } }}" }, { "title": "프로그래머스 타겟넘버 풀이", "url": "/posts/prgrms43165/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-07 09:11:33 +0800", "snippet": "문제타겟 넘버 문제 링크내 생각문제를 보고 바로 dfs다 라는 생각이 들어야한다. 정말 누가봐도 dfs로 풀라는 의도의 문제였다.초기값을 0으로 주고, + 와 - 에 대해서 dfs를 진행해주면 된다.코드class Solution { private int count = 0; public int solution(int[] numbers, int target) { return dfs(0, 0, numbers, target); } public int dfs(int depth, int value, int[] numbers, int target) { if(depth == numbers.length) { if(value == target) { return 1; } return 0; } return dfs(depth + 1, value + numbers[depth], numbers, target) + dfs(depth + 1, value - numbers[depth], numbers, target); }}" }, { "title": "프로그래머스 입국심사 풀이", "url": "/posts/prgrms43238/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-06 10:21:33 +0800", "snippet": "문제입국심사 문제 링크내 생각아무것도 못했다… 문제 상단에 이분 탐색이라고 적혀있는데도 이게 왜 이분탐색이지 라는 생각을 할 정도로 문제의 포인트를 짚지 못했다.입국 심사관이 어떻게 심사를 하든간에, 최소 시간만 구하면 되는 것이기 때문에 최저 시간(0)과 최고 시간(가장 오래걸리는 심사관 * 입국 심사 받는 사람의 수)을 left, right으로 잡아서 이분탐색을 하며 나온시간과 인원으로 문제를 해결하면 되는 것이였다.코드이분 탐색은 재귀, 반복을 통해서 가능한데, 여기서는 반복을 썼다. 아래 답안 코드에서 가져왔다.import java.util.Arrays;class Solution { public long solution(int n, int[] times) { Arrays.sort(times); long answer = 0; long left = 0; long right = (long) n * times[times.length - 1]; while(left &amp;lt;= right) { long mid = (left + right) / 2; long sum = 0; for(int i = 0; i &amp;lt; times.length; i++) { sum += mid / times[i]; } if(sum &amp;lt; n) { left = mid + 1; } else { right = mid - 1; answer = mid; } } return answer; }}느낀 점확실히 알고리즘을 안한지 오래되다보니 빈도수가 적은 다익스트라, union find, 이분 탐색 등의 문제는 포인트를 잡지 못하고있다. 이코테를 다시봐야하나…답안 링크https://youngest-programming.tistory.com/499" }, { "title": "프로그래머스 카카오 프렌즈 컬러링북 풀이", "url": "/posts/prgrms1829/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-06 09:23:33 +0800", "snippet": "문제카카오 프렌즈 컬러링푹 문제 링크내 생각전형적인 bfs 문제이다. 배열의 원소가 0인경우는 색칠되지 않으니 제외하되, 같은 원소끼리로 bfs를 이용하면 된다.코드import java.util.*;class Node { int x; int y; public Node(int x, int y) { this.x = x; this.y = y; }}class Solution { int[] dx = {-1, 1, 0, 0}; int[] dy = {0, 0, -1, 1}; boolean[][] visited; public int[] solution(int m, int n, int[][] picture) { int areaCount = 0; int maxArea = 0; visited = new boolean[m][n]; for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(picture[i][j] != 0 &amp;amp;&amp;amp; !visited[i][j]) { maxArea = Math.max(maxArea, bfs(i, j, m, n, picture)); areaCount++; } } } return new int[]{areaCount, maxArea}; } public int bfs(int x, int y, int m, int n, int[][] picture) { int result = 1; Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(x, y)); visited[x][y] = true; while(!q.isEmpty()) { Node now = q.poll(); x = now.x; y = now.y; for(int i = 0; i &amp;lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;gt;= m || nx &amp;lt; 0 || ny &amp;gt;= n || ny &amp;lt; 0) continue; if(picture[nx][ny] == picture[x][y] &amp;amp;&amp;amp; !visited[nx][ny]) { visited[nx][ny] = true; q.offer(new Node(nx, ny)); result++; } } } return result; }}" }, { "title": "디자인 패턴(5) - Singleton 패턴", "url": "/posts/design(5)/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-05 14:46:22 +0800", "snippet": "Design Pattern(5) - 싱글톤 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.나는 유일무이하다싱글톤 패턴은 객체의 인스턴스는 하나 뿐임을 보장하는 패턴입니다. 따라서 쓰레드 풀이나, 캐시, 설정 등의 하나만 있으면 되는 객체에 많이 적용됩니다. 그리고 싱글톤 패턴을 사용하면 전역 변수를 쓸 때 처럼 어디서든 해당 객체 인스턴스를 엑세스 할 수 있습니다.하지만 이렇게 프로그램이 시작될 때 메모리에 할당되는 객체가 크고 무거운데, 사용빈도 수가 적다면 프로그램 자원의 낭비일 것입니다. 이 부분을 어떻게 해결하는지 함께 알아봅시다.고전적인 싱글톤 패턴 구현고전적인 싱글톤 패턴을 구현해봅시다. 자기 자신을 static 변수로 두어서 static 영역에 하나만 존재하게 한 뒤, 생성자는 private으로 막아놓고 static 메서드를 활용합니다.이 경우의 장점을 보면 클래스가 로딩 될 때, 인스턴스가 바로 메모리에 오르지 않고, getInstance 메소드가 호출 될 때, 인스턴스가 올라가는 것을 알 수 있습니다. 이렇게 인스턴스가 프로그램이 실행될 때 바로 올라가지 않고 필요시에 올라가는 방식을 Lazy instantiation 이라고 부릅니다.public class Singleton { public static Singleton instance; private Singleton() { } public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; }}문제 이해이제 예시를 통해 싱글톤 패턴을 적용해봅시다.요즘은 거의 모든 초콜릿 공장에서 초콜릿을 끊이는 장치를 컴퓨터로 제어합니다. 이 보일러에서는 초콜릿과 우유를 받아서 끓이고 초코바를 만드는 단계로 넘겨줍니다. 여기에 초코홀릭 사의 최신형 초콜릿 보일러를 제어하기 위한 클래스가 나와있습니다. 코드를 잘 보면 아직 끓지 않는 500 갤런이나 되는 재료를 그냥 흘려버린다거나 보일러가 가득 차 있는 상태에서 새로운 원료를 붓는다거나 빈 보일러에 불을 지핀다거나 하는 실수를 하지 않도록 꽤 세심한 주의를 기울였다는 것을 알 수 있습니다.public class ChocolateBoiler { private boolean empty; private boolean boiled; public ChocolateBoiler() { empty = true; boiled = false; } public void fill() { if(isEmpty()) { empty = false; boiled = false; } } public void drain() { if(!isEmpty() &amp;amp;&amp;amp; isBoiled()) { // next empty = true; } } public void boil() { if(!isEmpty() &amp;amp;&amp;amp; !isBoiled()) { boiled = true; } } public boolean isEmpty() { return empty; } public boolean isBoiled() { return boiled; }}초코홀릭의 코드를 보면 위험한 일이 생기지 않도록 세심한 주의를 기울였음을 느낄 수 있습니다. 허나 두개의 인스턴스가 따로 돌아가게 되면 어떻게 될까요? 보일러는 하나인데 인스턴스가 2개인 상황이라면 논리가 우당탕탕 일 것입니다. 위에서 배운 싱글톤 패턴을 적용해봅시다.public class ChocolateBoiler { private boolean empty; private boolean boiled; private static ChocolateBoiler uniqueInstance; private ChocolateBoiler() { empty = true; boiled = false; } public static ChocolateBoiler getInstance() { if(uniqueInstance == null) { uniqueInstance = new ChocolateBoiler(); } return uniqueInstance; }...}이렇게 되면 초콜릿 보일러가 하나뿐임이 보장되니 보일러에 문제가 생길일은 없겠죠?하지만 실제 실행해보니 우유하고 초콜릿이 넘쳐 흘렀습니다. 무슨일이 일어난 것일까요?JVM이 되어보자문제를 알아보니 2개의 쓰레드에서 getInstance() 를 했더니 2개의 인스턴스가 생성되는 상황이 발생했습니다. 분명 우리는 하나뿐임을 보장하는 싱글톤 패턴을 사용했는데 이게 무슨 일일까요?코드를 따라가보니 2개의 쓰레드가 getInstance 메서드를 호출하는 텀이 짧아서 null 조건을 통과해버렸습니다.알고보니 우리가 공부한 고전적인 singleton 방식은 싱글쓰레드에서만 동작하게 되있습니다. 멀티쓰레드를 위해서 synchorized 키워드를 사용하는 것은 어떨까요?public class Singleton { public static Singleton instance; private Singleton() { } public static synchronized Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; }}이렇게 되면 멀티쓰레드 문제는 해결되지만, synchronized 키워드를 붙이면 한 쓰레드가 이 메서드를 사용하는 동안 다른 쓰레드에서는 사용하지 못하니, 처음 인스턴스를 만들 때를 제외하고는 오버헤드가 증가하는 상황입니다.더 효율적인 방법만약 getInstance() 의 속도가 중요하지 않다면, 그냥 두는 것도 괜찮습니다. 아니면 다음과 같이 처음부터 만드는 방법도 있습니다.public class Singleton { public static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; }}이렇게 되면 클래스가 로딩될 때 JVM에서 인스턴스를 생성해주겠네요. 사용하지 않을 때도 메모리에 존재하는 것은 아쉽지만, 크기가 크지 않다면 괜찮은것 같습니다.DCL(Double-checking Locking)말 그대로 2번 체크하는 방식입니다. 인스턴스가 생성되어 있는지 확인한 다음 생성되어 있지 않았을 때만 동기화를 할 수 있습니다. 이렇게 하면 처음에만 동기화를 하고 나중에는 동기화를 하지 않습니다.public class Singleton { public volatile static Singleton instance; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }}volatile 키워드를 통해서 CPU 캐시로 인한 동시성 문제를 방지할 수 있습니다.Holder : 이너 클래스의 사용public class Singleton { private Singleton() { } public static Singleton getInstance() { return InnerInstance.instance; } public static class InnerInstance { private static final Singleton instance = new Singleton(); }}JVM의 클래스 로더 방식과 클래스의 로드 시점을 이용하여 내부 클래스를 통해 생성 시킴으로써 쓰레드간 동기화 문제를 해결합니다. final 키워드를 통해서 객체 변경이 불가능한 것을 볼 수 있습니다.위 방법이 현재 java에서 싱글톤 생성에서 사용되는 대표적인 방법입니다." }, { "title": "프로그래머스 로또의 최고 순위와 최저 순위 풀이", "url": "/posts/prgrms77484/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-05 12:31:33 +0800", "snippet": "문제로또의 최고 순위와 최저 순위 문제 링크내 생각풀이는 다음과 같이 했다. 로또번호를 contains 메서드로 확인한다. 최소, 최대를 구한다. 등수를 구한다.코드import java.util.*;class Solution { public int[] solution(int[] lottos, int[] win_nums) { int count = 0; for(int i = 0; i &amp;lt; win_nums.length; i++) { if(contain(win_nums, lottos[i])) count++; } int min = getGrade(count); int max = getGrade(count + countZero(lottos)); return new int[]{max, min}; } private boolean contain(int[] arr, int key) { return Arrays.stream(arr).anyMatch(i -&amp;gt; i == key); } private int countZero(int[] arr) { return (int) Arrays.stream(arr).filter(i -&amp;gt; i == 0).count(); } private int getGrade(int count) { switch(count) { case 6 : { return 1; } case 5 : { return 2; } case 4 : { return 3; } case 3 : { return 4; } case 2 : { return 5; } default : { return 6; } } }}느낀 점분명 더 좋게 만들 수 있을 것 같다. contain 메서드를 쓰는것이 아니라 Map을 통해서도 가능할 것 같다.답안을 보니 역시 그런 방식으로 이루어져있다. 또한 switch문을 활용하지 않고 숫자를 이용하는 방식도 고려할 만 하다.답안import java.util.HashMap;import java.util.Map;class Solution { public int[] solution(int[] lottos, int[] win_nums) { Map&amp;lt;Integer, Boolean&amp;gt; map = new HashMap&amp;lt;Integer, Boolean&amp;gt;(); int zeroCount = 0; for(int lotto : lottos) { if(lotto == 0) { zeroCount++; continue; } map.put(lotto, true); } int sameCount = 0; for(int winNum : win_nums) { if(map.containsKey(winNum)) sameCount++; } int maxRank = 7 - (sameCount + zeroCount); int minRank = 7 - sameCount; if(maxRank &amp;gt; 6) maxRank = 6; if(minRank &amp;gt; 6) minRank = 6; return new int[] {maxRank, minRank}; }}" }, { "title": "프로그래머스 오픈채팅방 풀이", "url": "/posts/prgrms42888/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-05 08:32:33 +0800", "snippet": "문제오픈채팅방 문제 링크내 생각이전에 한번 풀었던 문제라서 풀이법이 기억이 났다. Map&amp;lt;id, username&amp;gt; 을 통해서 변경되는 username을 저장해두고 있고, result에는 일단 id를 넣어논뒤change가 끝나면 result에 있는 id를 username으로 변경하면됬다.코드// 1. Map을 통해서 아이디와 닉네임을 받는다.// 2. result 에 닉네임이 아닌 id를 우선 집어넣는다.// 3. 순회가 끝난뒤, 다시한번 순회하면서 id를 닉네임으로 변경한다.import java.util.*;class Solution { public String[] solution(String[] record) { List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); Map&amp;lt;String, String&amp;gt; userInfo = new HashMap&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; record.length; i++) { String[] splited = record[i].split(&quot; &quot;); String command = splited[0]; String id = splited[1]; switch(command) { case(&quot;Enter&quot;) : { String username = splited[2]; userInfo.put(id, username); result.add(id + &quot;님이 들어왔습니다.&quot;); break; } case(&quot;Change&quot;) : { String username = splited[2]; userInfo.put(id, username); break; } case(&quot;Leave&quot;) : { result.add(id + &quot;님이 나갔습니다.&quot;); break; } } } String[] answer = new String[result.size()]; for(int i = 0; i &amp;lt; result.size(); i++) { String info = result.get(i); String id = info.substring(0, info.indexOf(&quot;님&quot;)); String username = userInfo.get(id); answer[i] = info.replace(id, username); } return answer; }}문제를 풀고내 코드를 보면 switch 문에 중복코드가 많이 보이는 것을 볼 수 있다. 또한 result에 들어가는 문구가 하드코딩 되어있다.답안에서는 이 부분을 해결하였다.답안import java.util.ArrayList;import java.util.HashMap;import java.util.List;public class Solution { public String[] solution(String[] record) { HashMap&amp;lt;String, String&amp;gt; codeMap = new HashMap&amp;lt;String, String&amp;gt;(); codeMap.put(&quot;enter&quot;,&quot;들어왔습니다.&quot;); codeMap.put(&quot;leave&quot;,&quot;나갔습니다.&quot;); HashMap&amp;lt;String, String&amp;gt; uidMap = new HashMap&amp;lt;String, String&amp;gt;(); List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;(); for(String str:record){ String[] split = str.split(&quot;\\\\s+&quot;); String code = split[0]; String uid = split[1]; if(split.length &amp;gt; 2) { String name = split[2]; uidMap.put(uid, name); } if(!&quot;Change&quot;.equalsIgnoreCase(code)){ list.add(code +&quot; &quot;+uid); } } String[] answer = new String[list.size()]; for(int i=0;i&amp;lt;answer.length;i++){ String[] split = list.get(i).split(&quot;\\\\s+&quot;); String name = uidMap.get(split[1]); answer[i] = name+&quot;님이 &quot;+ codeMap.get(split[0].toLowerCase()); } return answer; }}" }, { "title": "디자인 패턴(4.2) - Factory 패턴", "url": "/posts/design(4.2)/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-04 16:46:22 +0800", "snippet": "Design Pattern(4.2) : 팩토리 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.문제 이해PizzaStore 디자인이 이제 슬슬 모양새를 갖춰가고 있습니다. 유연한 프레임워크도 만들어졌고, 디자인 원칙도 충실하게 지키고 있습니다.지금까지 객체마을 피자가 큰 성공을 이룬 배경에는 신선하고 품질 좋은 재료가 숨어있었습니다. 최근에 들어온 정보에 따르면, 몇몇 분점에서 자잘한 재료들을 더 싼 재료로 바꿔서 원가를 줄이고 마진을 올린다고 합니다.이를 해결하기 위해서 원재료를 생산하는 공장을 만들어 분점까지 재료를 배달하려합니다.허나 이 계획에도 문제점이 있습니다. 분점이 서로 멀리 떨어져있고, 뉴욕의 레드소스와 시카고의 레드소스는 서로 다릅니다. 그래서 뉴욕으로 배달되는 재료들과 시카고로 배달되는 재료들이 서로 달라집니다.원재료 공장 만들기일단 원재료를 생산할 공장을 만들어봅시다.public interface PizzaIngredientFactory { public Dough createDough(); public Sauce createSauce(); public Cheese createCheese(); public Veggies[] createVeggies(); public Pepperoni createPepperoni(); public Clams createClam();}뉴욕 원재료 공장은 다음과 같습니다. 지역마다 같은 재료를 쓸 수도, 다른 재료를 쓰기도 합니다.public class NYIngredientFactory implements PizzaIngredientFactory { @Override public Dough createDough() { return new ThinCrustDough(); } @Override public Sauce createSauce() { return new MarinaraSauce(); } @Override public Cheese createCheese() { return new ReggianoCheese(); } @Override public Veggies[] createVeggies() { return new Veggies[]{ new Garlic(), new Onion(), new Mushroom(), new RedPepper() }; } @Override public Pepperoni createPepperoni() { return new SlicedPepperoni(); } @Override public Clams createClam() { return new FreshClams(); }}이제 Pizza 를 바꿔봅시다.public abstract class Pizza { String name; Dough dough; Sauce sauce; Veggies[] veggies; Cheese cheese; Pepperoni pepperoni; Clams clams; List&amp;lt;String&amp;gt; toppings = new ArrayList&amp;lt;&amp;gt;(); abstract void prepare(); void bake() { System.out.println(&quot;Bake for 25 minutes at 350&quot;); } void cut() { System.out.println(&quot;Cutting the pizza into diagonal slices&quot;); } void box() { System.out.println(&quot;Place pizza in official PizzaStore box&quot;); } public String getName() { return name; }}이제 Pizza 의 구현체들은 원재료 공장에서 물건을 받아와서 사용하게 됩니다.public class NYCheesePizza extends Pizza { private final PizzaIngredientFactory pizzaIngredientFactory; public NYCheesePizza(PizzaIngredientFactory pizzaIngredientFactory) { this.pizzaIngredientFactory = pizzaIngredientFactory; name = &quot;NY Style Sauce and Cheese Pizza&quot;; } @Override void prepare() { System.out.println(&quot;Preparing ... &quot; + name); dough = pizzaIngredientFactory.createDough(); sauce = pizzaIngredientFactory.createSauce(); cheese = pizzaIngredientFactory.createCheese(); }}public class NYPizzaStore extends PizzaStore { @Override Pizza createPizza(String item) { PizzaIngredientFactory ingredientFactory = new NYIngredientFactory(); if(Objects.equals(item, &quot;cheese&quot;)) { return new NYCheesePizza(ingredientFactory); } else if(item.equals(&quot;greek&quot;)) { return new NYGreekPizza(ingredientFactory); } else if(item.equals(&quot;pepperoni&quot;)) { return new NYPappernoniPizza(ingredientFactory); } else { return null; } }}지금까지 한 것을 정리해보면 다음과 같습니다. 원재료 공장이 다르기 때문에 추상화를 시켰다(PizzaIngredientFactory) Pizza 의 구현체에 PizzaIngredientFactory를 구성(Composition) 하여 외부에서 원재료 공장을 받을 수 있게 하였다. 뉴욕이면, 뉴욕 원재료 공장을, 시카고면 시카고 원재료 공장을 주입시켰다.이와 같은 방식을 통해서 원재료 공장 코드는 피자의 코드와 분리되어 있기 때문에 다른 공장을 사용하기만 하면 다른 결과를 얻을 수 있습니다. 공장은 공장대로 확장가능하고, 피자는 피자대로 확장 가능합니다.이렇게 클라이언트와(피자) 팩토리(원재료 공장) 를 분리하는 방식을 추상 팩토리 패턴이라고 합니다. 이 방식을 통해 피자는 원재료 공장을 신경쓰지 않고 피자를 만들 수 있습니다." }, { "title": "프로그래머스 문자열 압축 풀이", "url": "/posts/prgrms60057/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-04 09:27:33 +0800", "snippet": "문제데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.내 생각아래와 같은 순서로 진행했다. 단위길이 별로 자른다. 앞에서 부터 단위 문자열을 비교하며 더해간다 길이를 비교한다.코드import java.util.*;class Solution { public int solution(String s) { int unitLength = (s.length() / 2) + 1; int maxLength = s.length(); int answer = maxLength; for (int i = 1; i &amp;lt; unitLength; i++) { List&amp;lt;String&amp;gt; strings = new ArrayList&amp;lt;&amp;gt;(); for (int j = 0; j &amp;lt; maxLength; j += i) { String unit = (j &amp;gt; maxLength - i) ? s.substring(j, maxLength) : s.substring(j, j + i); strings.add(unit); } StringBuilder strBuilder = new StringBuilder(); int count = 1; for (int j = 0; j &amp;lt; strings.size(); j++) { if (j == strings.size() - 1) { if (strings.get(j - 1).equals(strings.get(j))) { strBuilder.append(count).append(strings.get(j)); } else { strBuilder.append(strings.get(j)); } } else { if (strings.get(j).equals(strings.get(j + 1))) { count++; } else { if (count &amp;gt; 1) { strBuilder.append(count).append(strings.get(j)); } else { strBuilder.append(strings.get(j)); } count = 1; } } } answer = Math.min(answer, strBuilder.length()); } return answer; }}답안프로그래머스에서 가장 많은 좋아요를 받은 답안이다. 재귀를 사용할 수는 있겠거니 했지만 막상 코드로 보니 굉장히 어렵다.class Solution { public int solution(String s) { int answer = 0; for(int i=1; i&amp;lt;=(s.length()/2)+1; i++){ int result = getSplitedLength(s, i, 1).length(); answer = i==1 ? result : (answer&amp;gt;result?result:answer); } return answer; } public String getSplitedLength(String s, int n, int repeat){ if(s.length() &amp;lt; n) return s; String result = &quot;&quot;; String preString = s.substring(0, n); String postString = s.substring(n, s.length()); // 불일치 -&amp;gt; 현재까지 [반복횟수 + 반복문자] 조합 if(!postString.startsWith(preString)){ if(repeat ==1) return result += preString + getSplitedLength(postString, n, 1); return result += Integer.toString(repeat) + preString + getSplitedLength(postString, n, 1); } return result += getSplitedLength(postString, n, repeat+1); }}느낀 점이 문제는 파이썬으로도 JS로도 풀어본 적 있는 문제이다. JAVA로 풀었을 때 시간이 더 오래걸렸다(푸는 시간). 코드를 봐도 풀이에는 성공을 했지만, if문 범벅에 난잡하기만 한 코드이다.조만간 다시 한번 풀어보되, 재귀를 이용한 방법으로 풀어봐야겠다." }, { "title": "디자인 패턴(4.1) - Factory 패턴", "url": "/posts/design(4)/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-03 15:07:22 +0800", "snippet": "Design Pattern(4.1) : 팩토리 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.이 장에서는 객체의 인스턴스를 만드는 작업이 항상 공개되어 있어야 하는 것은 아니며, 모든 것을 공개했다가는 결합과 관련된 문제가 생길 수 있다는 것을 배우게 될 것입니다.문제 이해우리는 피자 가게를 운영하고 있습니다. 그래서 다음과 같은 코드를 만들었다고 가정합니다.Pizza orderPizza(){ Pizza pizza=new Pizza(); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;}하지만 피자 종류는 한 두가지 가 아닙니다. 이를 위한 코드도 추가해줘야합니다.Pizza orderPizza(String type) { Pizza pizza = new Pizza(); if(type == &quot;cheese&quot;) { pizza = new CheesePizza(); } else if(type.equals(&quot;greek&quot;)) { pizza = new GreekPizza(); } else if(type.equals(&quot;pepperoni&quot;)) { pizza = new PappernoniPizza(); } pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;}위의 if 문 코드는 피자에 새로운 제품을 추가하거나 뺄 때, 매번 코드 수정이 일어나야합니다. 디자인원칙인 변화하는 부분과 변화하지 않는 부분을 나눠라에서, 전형적인 변화에 해당하는 예시일 것입니다. 이 부분을별도로 캡슐화 해야합니다.객체 생성을 처리하는 기능를 팩토리라고 부릅니다. 일단 SimplePizzaFactory 클래스를 만들고 나면 orderPizza() 메서드는 새로 만든 객체의 클라이언트가 됩니다. orderPizza()는 Pizza 의 종류에 상관없이 그저 팩토리에게 부탁해서 피자를 얻어와 주문작업을 이어가면됩니다.구현간단한 피자 팩토리를 만들어봅시다.public class SimplePizzaFactory { public Pizza createPizza(String type) { Pizza pizza = null; if(Objects.equals(type, &quot;cheese&quot;)) { pizza = new CheesePizza(); } else if(type.equals(&quot;greek&quot;)) { pizza = new GreekPizza(); } else if(type.equals(&quot;pepperoni&quot;)) { pizza = new PappernoniPizza(); } return pizza; }}언뜻보기에는 그냥 if관련한 메서드만 따로 때놓은것 같습니다. 무슨 장점이 있을까요?orderPizza() 메서드 안에 이 로직이 있다면 재사용이 불가능합니다. 예를 들어, 피자 가격만 얻으려는데 orderPizza를 호출하는건 이상하니까요. 피자를 생성하는 작업을 한 클래스에 캡슐화 시켜놓으면구현을 변경해야하는 경우에 여기저기 다 들어가서 고칠 필요 없이 팩토리 클래스만 고치면 될 것입니다. 정적팩토리 메서드 좀 뜬금없긴 하지만 팩토리를 static 메서드를 활용해서 만들기도 합니다. 그렇게 하면 별도의 객체의 인스턴스를 만들필요없이 메서드를 호출하기만 하면되는 장점이있습니다. 하지만 서브클래스를 만들어서 객체 생성메서드의 행동을 변경할 수 없다는 단점이 있다는 것도 꼭 기억해두시면 좋을 것 같습니다. 이제 PizzaStore 를 고쳐봅시다.public class PizzaStore { SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory) { this.factory = factory; } public Pizza orderPizza(String type) { Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } ...}사실 이런 간단한 팩토리를 디자인 패턴이라고 할 수는 없습니다. 프로그래밍을 하는데 있어서 자주 쓰이는 관용구에 가깝다고 할 수 있습니다.피자 프랜차이즈 사업PizzaStore 가 큰 성공을 거둬서 인기를 끌게 되고 나니 많은 사람들이 자기 동네에도 PizzaStore있었으면 좋겠다는 바램을 가지게 되었습니다. 프랜차이즈를 운영하게 되면서, 지금까지 잘 써왔던 코드를 다른 지점에서 쓸 수 있도록 만들기로 했습니다.하지만 지역별로 조금씩 입맛이 다릅니다. 그 지역의 특성과 입맛을 반영하여 다른 스타일의 피자(뉴욕 스타일, 시카고 스타일) 을 만들어야합니다.Just Do It일단 한번 해봅시다. 기존의 SimplePizzaFactory 를 뺴고 세가지 서로 다른 팩토리를 만들어 PizzaStore 에서 적당한 팩토리를 사용하도록 하면 분점에서도 전혀 문제없이 쓸 수 있을것입니다.NYPizzaFactory factory = new NYPizzaFactory();PizzaStore nyStore = new PizzaStore(nyFactory);nyStore.order(&quot;Veggie&quot;);하지만 분점에서 우리가 만든 팩토리를 써서 피자를 만들긴 하는데, 독자적인 방법들을 추가해서 사용하기 시작했습니다.이 문제를 다시 한번 생각해보니, 피자 가게와 피자 제작 과정 전체를 하나로 묶어주는 프레임워크를 만들어야 되겠다는 결론에 도달했습니다. 물론 그렇게 하면서도 유연성을 잃어버리면 안되겠죠.피자 가게 프레임 워크피자를 만드는 활동 자체는 전부 PizzaStore 클래스에 국한시키면서도 분점마다 고유의 스타일을 살릴 수 있도록 하는 방법이 있습니다.public abstract class PizzaStore { public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } abstract Pizza createPizza(String type);}이렇게 하면 각 분점을 위한 서브클래스에서 피자의 스타일을 결정할 것입니다.public class NYPizzaStore extends PizzaStore { @Override Pizza createPizza(String item) { if(Objects.equals(item, &quot;cheese&quot;)) { return new NYCheesePizza(); } else if(item.equals(&quot;greek&quot;)) { return new NYGreekPizza(); } else if(item.equals(&quot;pepperoni&quot;)) { return new NYPappernoniPizza(); } else { return null; } }}이제 Pizza 인스턴스를 만드는 일은 팩토리 역할을 하는 메소드 createPizza() 에서 맡아서 처리합니다.이제 피자를 만들어봅시다.public class PizzaTestDrive { public static void main(String[] args) { PizzaStore nyStore = new NYPizzaStore(); PizzaStore chicagoStore = new ChicagoPizzaStore(); Pizza pizza = nyStore.orderPizza(&quot;cheese&quot;); System.out.println(&quot;Rosa ordered a &quot; + pizza.getName() + &quot;\\n&quot;); pizza = chicagoStore.orderPizza(&quot;cheese&quot;); System.out.println(&quot;Ian ordered a &quot; + pizza.getName() + &quot;\\n&quot;); }}요약이렇게 슈퍼 클래스에서 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하는 방법을 템플릿 메소드 패턴 이라고 한다. 또한 PizzaStore 의 예시 처럼, 서브클래스에서 구체적인 오브젝트 생성방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 부르기도 한다." }, { "title": "디자인 패턴(3) - Decorator 패턴", "url": "/posts/design(3)/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-02 15:01:22 +0800", "snippet": "Design Patten(3) : 데코레이터 패턴이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.데코레이터 패턴은 실행중에 클래스를 꾸미는(데코레이션하는) 방법입니다. 데코레이터 패턴을 배우고 나면 원래 클래스의 코드는 전혀 바꾸지 않고도 여러 객체에 새로운 임무를 부여할 수 있습니다.문제이해스타버즈 커피는 엄청난 속도로 성장한 초대형 커피 전문점으로 유명합니다. 심지어 어떤 동네에는 스타버즈가 두 세 개씩 있기도 합니다.스타버즈 커피샵은 워낙 빠르게 성장했기 땜누에 다양한 음료들을 모두 포괄하는 주문 시스템을 이제서야 겨우 갖추려고 하는 중입니다.처음에 사업을 시작할 무렵에 만들어진 클래스들은 다음과 같은 식으로 구성되었습니다.하지만 커피를 주문할 때는 스팀 우유나 두유, 모카(초콜릿)을 추가하고, 그 위에 휘핑크림을 올리기도 합니다. 그래서 처음에는 이렇게 했습니다. 이렇게 할 경우에 클래스의 개수는 폭팔적으로 늘고 말 것입니다.분명 위의 방식은 문제가 있어보입니다. 만약 모든 음료에 카라멜을 추가할 수 있다면 클래스는 배로 증가할 것입니다. 그렇다면 Beverage라는 수퍼 클래스를 만들어보는 것은 어떨까요?이 경우에는 코드의 변경이 일어나기 쉽습니다. 첨가물 가격이 변경되면 코드 수정을 해야하고, 첨가물의 종류가 바뀌면 cost() 메서드도 변경해줘야 할 것입니다. 간단하게 이야기하면 OCP를 위반하고 있습니다.OCP(Open-closed principal) : 확장에 대해서는 열려있고, 수정에 대해서는 닫혀있어야한다.2장에서 배운 Observer 패턴을 보면 Subject 자체에 코드를 추가하지 않으면서도 언제든지 확장 할 수 있습니다. 그렇다고 모든 코드에 OCP를 적용하는 것은 많은 노력이 필요합니다. 또한 OCP를 지키려고 하면 새로운 단계의 추상화가 필요한 경우가 생기는데, 그렇게되면 코드가 필요 이상으로 복잡해질수도 있습니다. 가성비 있게, 우리가 디자인한 것중에서 가장 바뀔 확률이 높은 부분을 중점적으로 살펴보고 원칙을 적용하는 방법이 가장 현명합니다.데코레이터 패턴우리가 사용할 방법은 다음과 같습니다. 우선 특정 음료에서 시작해서, 첨가물로 그 음료를 장식할 것입니다. 아래와 같은 방식이겠네요. DarkRoast 객체를 가져온다. Mocha 객체로 장식한다. Whip 객체로 장식한다. cost() 메서드를 호출한다. 이 때, 첨가물의 가격을 계산하는 일은 해당 객체들에게 위임된다.그림으로 보면 이런 느낌일 것 입니다. 데코레이터의 수퍼클래스는 자신이 장식하고 있는 객체의 수퍼클래스와 같습니다.가격을 구할 때는 가장 바깥쪽에 있는 Whip의 cost()를 호출하면 됩니다. 그러면 Whip 에서는 그 객체가 장식하고 있는 객체에게 가격 계산을 위임합니다. 가격이 구해지고 나면, 구해진 가격에 휘핑크림의 가격을 더한다음 그 결과를 리턴합니다. Whip cost() 호출 Whip에서 Mocha의 cost() 호출 Mocha에서 DarkRoast의 cost() 호출 DarkRoast의 cost() 에서 가격 리턴 Mocha에서 가격 리턴 Whip에서 가격 리턴다음으로 정의를 살펴봅시다. 데코레이터 패턴에서는 객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.정의를 보면 추가기능을 붙이는 것이구나 라고 생각할 수 있습니다. 하지만 실제 코드로는 어떻게 구현해야할지는 애매모호합니다. 아래 그림으로 같이 보시죠구현이제 구현을 해봅시다. 일단 음료와 첨가물 데코레이터를 먼저 구현합니다. CondimentDecorator 의 getDescription은 데코레이터의 구현체에서 자세하게 쓰기 위해서 오버라이드 해왔습니다.public abstract class Beverage { String description = &quot;제목없음&quot;; public String getDescription() { return description; } public abstract double cost();}public abstract class CondimentDecorator extends Beverage{ @Override public abstract String getDescription();}다음은 음료를 구현합니다. 여기서는 HouseBlend 와 Espresso 만 만들겠습니다.public class HouseBlend extends Beverage { public HouseBlend() { super.description = &quot;하우스 블랜드 커피&quot;; } @Override public double cost() { return 0.89; }}public class Espresso extends Beverage { public Espresso() { super.description = &quot;에스프레소&quot;; } @Override public double cost() { return 1.99; }}다음은 데코레이터 패턴을 적용할 첨가물입니다. 코드를 보면 Beverage 를 상속함과 동시에 composition을 하고 있는 것을 볼 수 있습니다.public class Mocha extends CondimentDecorator { private final Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 0.20 + beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;, 모카&quot;; }}public class SteamMilk extends CondimentDecorator { private final Beverage beverage; public SteamMilk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 0.10 + this.beverage.cost(); } @Override public String getDescription() { return this.beverage.description + &quot;, 스팀밀크&quot;; }}public class Whip extends CondimentDecorator { private final Beverage beverage; public Whip(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 0.25 + this.beverage.cost(); } @Override public String getDescription() { return this.beverage.description + &quot;, 휘핑크림&quot;; }}public class Soy extends CondimentDecorator { private final Beverage beverage; public Soy(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return 0.19 + this.beverage.cost(); } @Override public String getDescription() { return this.beverage.getDescription()+ &quot;, 두유&quot;; }}이제 테스트 코드를 만들어봅시다.public class StarbuzzCoffee { public static void main(String[] args) { Beverage espresso = new Espresso(); System.out.println(espresso.getDescription() + &quot; $&quot; + espresso.cost()); Beverage houseBlend = new HouseBlend(); houseBlend = new Mocha(houseBlend); houseBlend = new Mocha(houseBlend); houseBlend = new Whip(houseBlend); System.out.println(houseBlend.getDescription() + &quot; $&quot; + houseBlend.cost()); }}사진을 보면 정상적으로 기능이 잘 나오는 것을 볼 수 있습니다.. 허나 모카, 모카 라고 하는 부분을 더블모카로 바꾸면 더 좋을 것 같습니다. 이 부분은 CondimentPrettyPrint 의 이름으로 데코레이터를 만들어서 적용해보면 좋을 것 같습니다." }, { "title": "프로그래머스 추석 트래픽 풀이", "url": "/posts/prgrms17676/", "categories": "algorithm, java", "tags": "algorithm", "date": "2022-01-02 09:56:33 +0800", "snippet": "문제이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.입력형식 solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다. 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다. 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다. 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 “2016년 9월 15일 오전 3시 10분 33.010초”부터 “2016년 9월 15일 오전 3시 10분 33.020초”까지 “0.011초” 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함) 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다. lines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.내 생각문자열을 사용하는 구현 문제였다. 문자열 파싱을 잘하면 쉽게 풀 수 있다는데, 나는 푸는데 실패했다…내 생각(틀린 풀이)은 응답 시간과 처리시간을 LocalTime 객체로 만들어 빼서 요청시간을 구하고, 요청 시간과 응답시간을 토대로 답을 유추하려 했지만, LocalTime 끼리의 빼기가 잘 되지 않아 답안을 보는 것을 선택했다.답안에서는 입력으로 주어지는 문자열이 종료시점을 기준으로 정렬되서 넘어오기 때문에 가장 빨리 끝나는 로그부터 비교해서 counting을 해주면 된다고 한다.코드이거는 내가 풀다가 다 풀지 못한 코드이다 기록용으로 남겨논다.import java.time.LocalTime;import java.util.List;import java.time.format.DateTimeFormatter;class Solution { public int solution(String[] lines) { parse(lines); return 0; } public void parse(String[] lines) { DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(&quot;HH:mm:ss.SSS&quot;); DateTimeFormatter secondFormatter = DateTimeFormatter.ofPattern(&quot;00:00:ss.SSS&quot;); for(int i = 0; i &amp;lt; lines.length; i++) { String[] splitedLine = lines[i].split(&quot; &quot;); LocalTime responseTime = LocalTime.parse(splitedLine[1], timeFormatter); LocalTime processingTime = parseProcessingTime(splitedLine[2].substring(0, splitedLine[2].length() - 1)); } } public LocalTime parseProcessingTime(String time) { if(time.contains(&quot;.&quot;)) { String[] splitedProcessingTime = time.split(&quot;\\\\.&quot;); int second = Integer.parseInt(splitedProcessingTime[0]); int nanoSecond = Integer.parseInt(splitedProcessingTime[1]) * 1_000_000; return LocalTime.of(0, 0, second, nanoSecond); } else { return LocalTime.of(0, 0, Integer.parseInt(time)); } }}다음은 답안의 코드이다. 초를 double로 parsing한 뒤에 비교하는 모습이다 굉장히 쉽게 풀이해 낸 모습을 볼 수 있다.import java.text.SimpleDateFormat;import java.util.*;class Solution { public int solution(String[] lines) throws Exception { SimpleDateFormat format = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;); int[] counts = new int[lines.length]; int max = 0; for(int i = 0; i &amp;lt; lines.length; i++) { String[] pre = lines[i].split(&quot; &quot;); Date preEndDate = format.parse(pre[1]); long preEnd = preEndDate.getTime(); for(int j = i; j &amp;lt; lines.length; j++) { String[] next = lines[j].split(&quot; &quot;); Date nextEndDate = format.parse(next[1]); double sec = Double.parseDouble(next[2].substring(0, next[2].length() -1)); long nextStart = (long) (nextEndDate.getTime() - sec * 1000 + 1); if(preEnd + 1000 &amp;gt; nextStart) { counts[i] += 1; max = Math.max(max, counts[i]); } } } return max; }}느낀 점시간이라고 생각해서 무턱대고 시간끼리의 비교를 토대로 문제를 진행하려다가 문제해결에 실패했다. 문자열 파싱은 비슷했으나, 시간 객체를 통한 비교가 아닌 double값의 비교로 깔끔하게 푼 풀이를 보고 많이 배웠다. 내일 한번 더 도전해서 풀어봐야한다.참고https://wellbell.tistory.com/98" }, { "title": "Java SE? Java EE? 차이가 뭐지?", "url": "/posts/java(1)/", "categories": "Java", "tags": "Java", "date": "2022-01-01 17:07:33 +0800", "snippet": "자바 프로그래밍 언어 플랫폼자바의 프로그래밍 언어 플랫폼은 4가지가 있습니다. 표준 에디션의 자바 플랫폼(Java SE) 엔터프라이즈 에디션의 자바 플랫폼(Java EE) 마이크로 에디션의 자바 플랫폼(Java ME) JavaFX모든 자바 플랫폼들은 JVM(자바 가상 머신)과 API로 구성되어 있습니다.Java SEStandard Edition 답게, 자바라고 하면 대부분은 JavaSE를 생각하게 됩니다. JavaSE의 API는 자바에서의 핵심 기능들을 제공합니다. 기초적인 타입부터, 네트워킹, 보안, 데이터 베이스 처리, GUI 개발과 같은 기능을 제공합니다.주요패키지로는 java.lang., java.util., java.awt., javax.rmi., javax.net.* 등이 있습니다.Java EEEnterprise Edition으로 SE 플랫폼을 기반으로 그 위에 탑재됩니다. 기업용이기 때문에 대규모, 다계층, 확장성, 신뢰성, 보안 네트워킹에 대한 환경 및 API를 제공하고 있습니다.주요패키지로는 JSP, Servlet을 비롯하여, JDBC, JNDI, JTA, EJB 등의 기술이 포함되어있습니다.Java SE의 API에 추가로 lib 디렉토리에 포함되어있는 JAR 파일들의 차이입니다." }, { "title": "디자인 패턴(2) - Observer 패턴", "url": "/posts/design(2)/", "categories": "design patterns", "tags": "design patterns", "date": "2022-01-01 14:24:22 +0800", "snippet": "Design Pattern(2) - Observer이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.문제 이해우리는 기상 모니터링 어플리케이션을 만듭니다. 습도, 온도, 압력 센서로 부터의 데이터를 WeatherData 객체로 받아 디스플레이 장비에 표시합니다. 이 외에도 기상 통계, 기상 예보등을 보여줄 수 있어야합니다.WeatherData 소스 파일을 보니 온도, 습도, 압력은 Getter를 통해서 제공해주고 있습니다. 우리는 measurementsChanged 메서드로 현재 조건, 기상 통계, 예보를 갱신할 수 있도록 구현해야합니다.Just Do it일단 구현을 해봅시다.public class WeatherData { ... public void measurementsChanged() { float temp = this.getTemperature(); float humidity = this.getHumidity(); float pressure = this.getPressure(); currentConditionsDisplay.update(temp, humidity, pressure); statisticsDisplay.update(temp, humidity, pressure); forecastDisplay.update(temp, humidity, pressure); } ...}이렇게 코딩 했을 때의 문제를 저번 챕터에서 배운 지식을 활용해서 찾아봅시다. 일단, 이 메서드는 분명 변경 요소가 많습니다. 따라서 변경해야하는 것과 변경되지 않는 것을 구분해줘야할 것 같습니다. 또한 구제적인 구현을 바탕으로 코딩이 되어있습니다.그래도 update라는 메서드가 공통적으로 들어가 있는 것을 보니 Display들은 공통된 인터페이스를 공유하고 있는 것 같습니다.Observer 패턴이제 옵저버 패턴을 알아봅시다. Observer 패턴은 구독-알림 시스템에서 많이 적용됩니다. 구독해 놓은 객체에 변동이 생기면 구독자에게 알림이 가는 방식입니다. 구독해놓은 객체를 subject(주제), 구독자를 observer 라고 부릅니다. 정의하면 다음과 같습니다. 옵져서 패턴에서는 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한태 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다느슨한결합두 객체가 느슨하게 결합되어 있다는 것은, 그 둘이 상호작용을 하긴 하지만 서로에 대해 서로 잘 모른다는 것을 의미합니다. 옵져버 패턴에서는 주제와 옵저버가 느슨하게 결합되어 있는 객체 디자인을 제공합니다. 주제가 옵저버에 대해 아는 것은 옵저버가 특정 인터페이스를 구현한다는 것 뿐입니다. 옵저버의 구상클래스가 무엇인지, 옵저버가 무엇을 하는지 등에 대해서는 알 필요가 없습니다. 옵저버는 언제든지 새로 추가할 수 있습니다. 새로운 형식의 옵저버를 추가하려고 할 때도 주제를 변경할 필요가없습니다. 주제와 옵저버는 서로 독립적으로 재사용할 수있습니다. 주제나 옵저버가 바뀌어도 서로한태 영향을 미치지는 않습니다.이를 위해서는 주제와 옵저버 모두 인터페이스를 이용하여 결합해줘야합니다. 그래야 서로가 바뀌더라도 상관이 없으니까요. 코드로 보면 아래와 같습니다.public interface Subject { void registerObserver(Observer o); void removeObserver(Observer o); void notifyObservers();}public interface Observer { void update(float temp, float humidity, float pressure);}구현weatherData 는 옵저버 패턴에서 주제에 해당합니다. 따라서 Subject 클래스를 implements 하여 사용합니다.public class WeatherData implements Subject { private float temperature; private float humidity; private float pressure; private List&amp;lt;Observer&amp;gt; observers; public WeatherData() { observers = new ArrayList&amp;lt;&amp;gt;(); } @Override public void registerObserver(Observer o) { observers.add(o); } @Override public void removeObserver(Observer o) { observers.remove(o); } @Override public void notifyObservers() { observers.forEach(o -&amp;gt; o.update(temperature, humidity, pressure)); } public void measurementsChanged() { notifyObservers(); } public void setMeasurements(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); } public float getTemperature() { return temperature; } public float getHumidity() { return humidity; } public float getPressure() { return pressure; }}이제 weatherData에서 현재 조건(온도, 습도, 기압) 등이 변경되면 알아서 모든 옵져버들에게서 update 메서드를 수행하라고 할 것입니다. 이제 이를 표시할 디스플레이 부분을 만들어봅시다.디스플레이 장비는, weatherData에게서 정보를 전달받고, 이를 장비에 표시합니다. 정보를 전달받는 것, 보여주는 것, 2가지의 행위를 가지고 있는 것입니다. 이 2가지 행위를 인터페이스로 분리하여 각각 확장할 수 있게 합시다.public interface DisplayElement { void display();}현재조건을 보여주는 기능만 구현합니다. Observer의 생성자를 통해서 Subject의 registerObserver를 호출하여 만들어지면서 등록되는 모습을 볼 수 있습니다.그렇다면 weatherData 의 참조를 CurrentConditionDisplay에서 쓰지 않는데 가지고 있을 이유가 있을까요? 지금 당장은 사용하는 곳이 없지만, 옵저버 목록을 탈퇴하는 메서드에서는 가지고 있어야 하기에 필요할 것 같습니다.import java.text.MessageFormat;public class CurrentConditionDisplay implements Observer, DisplayElement{ private float temperature; private float humidity; private Subject weatherData; public CurrentConditionDisplay(Subject weatherData) { this.weatherData = weatherData; weatherData.registerObserver(this); } @Override public void update(float temp, float humidity, float pressure) { this.temperature = temp; this.humidity = humidity; display(); } @Override public void display() { System.out.println( MessageFormat.format( &quot;Current conditions - temperature({} F degree), humidity({} %)&quot;, temperature, humidity) ); }}테스트할 main 메서드를 만들어봅시다.public class WeatherStation { public static void main(String[] args) { WeatherData weatherData = new WeatherData(); CurrentConditionDisplay conditionDisplay = new CurrentConditionDisplay(weatherData); weatherData.setMeasurements(82, 22, 30.4f); weatherData.setMeasurements(85, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.7f); }}" }, { "title": "내가 모르던 git(7)", "url": "/posts/git(7)/", "categories": "git", "tags": "git", "date": "2021-12-31 16:24:29 +0800", "snippet": "내가 모르던 git(7)이 글은 팀 개발을 위한 Git, GitHub 시작하기 를 읽고 제가 모르는 부분을 정리한 문서입니다.Git의 내부 동작 원리.git 내부를 파보자. git init 을 통해 만든 .git 내부는 다음과 같다.워킹 트리에 cat.txt 파일을 만들고 git status 명령을 통해 확인하면 아래 그림과 같다. 사실 git status 는 워킹트리와 스테이지, 그리고 HEAD가 가리키고 있는 커밋 세 가지 저장 공간의 차이를 비교해서 보여준다.이제 만든 파일의 체크섬을 확인해보자. 체크섬이란, 단일 파일에 데이터를 암호화 해시 함수라고 하는 알고리즘으로 실행한 결과이다. 즉, 같은 내용이면 같은 체크섬이 나올 것이다. 체크섬 확인 명령어는 git hash-object 이다.이제 git add 를 통해 cat.txt를 스테이지 위로 올리면 .git 내부에 index 라는 파일이 생긴다.file .git/index 명령을 통해서 index 파일을 살펴보면 다음과 같다. file 은 리눅스 명령어로, 지정된 파일의 종류를 확인하는 명령어이다.Git index는 stage의 다른 이름이다. 이 index 파일이 바로 Git 스테이지이다.다른 것도 살펴보자. Objects 폴더는 Git 객체가 있는 폴더이다. 파일 체크섬의 앞에 2자리/나머지 체크섬 을 구조로 가지고 있다.객체 타입은 git cat-file -t &amp;lt;체크섬&amp;gt; 을 통해서 알 수 있다.정리해보면, git add 명령은 해당 파일의 체크섬 값과 동일한 이름을 가지는 blob 객체가 생성되고, 이 객체는 .git/objects 파일에 저장된다. 그리고 스테이지 내용은 .git/index 에 기록된다.Git commit의 동작원리cat.txt를 커밋하고 .git 폴더 내부를 확인해보자. 현재 우리가 한 커밋은 8496107… 이다(커밋마다 체크섬은 고유하니 다 다를것이다).ls -a .git/objects 명령어를 통해 git 객체들을 보면 아래와 같다. ff/ 는 git add 로 만들어진것이고, 84/ 는 git commit 으로 만들어진것 같은데, 7a는 그럼 무엇일까?git show 명령을 통해 어떤 객체인지 확인해보자. git show &amp;lt;체크섬&amp;gt; 은 해당 체크섬을 가진 객체의 내용을 표시한다. 아래 사진을 보면 tree 객체라는 것을 알 수 있다.tree 객체의 내용을 봐보자 git ls-tree &amp;lt;체크섬&amp;gt; 명령을 통해서 볼 수 있다.스테이지와 내용이 동일한 것을 볼 수 있다.다음은 커밋을 봐보자. git cat-file commit 커밋체크섬 명령을 통해서 커밋 객체 내용을 볼 수 있다. 보면, 트리와 커밋 메세지를 가지고 있는 것을 볼 수 있다.즉 커밋을 하면 스테이지의 객체로 트리가 만들어지고, 커밋에는 커밋 메세지와 트리객체가 포함된다.즉 커밋은 커밋 메세지 + 트리객체 로 이루어진다는 것을 알 수 있다." }, { "title": "BOJ_10825 국영수 문제풀이", "url": "/posts/BOJ10825/", "categories": "algorithm, java", "tags": "algorithm", "date": "2021-12-30 15:30:29 +0800", "snippet": "문제도현이네 반 학생 N명의 이름과 국어, 영어, 수학 점수가 주어진다. 이때, 다음과 같은 조건으로 학생의 성적을 정렬하는 프로그램을 작성하시오. 국어 점수가 감소하는 순서로 국어 점수가 같으면 영어 점수가 증가하는 순서로 국어 점수와 영어 점수가 같으면 수학 점수가 감소하는 순서로 모든 점수가 같으면 이름이 사전 순으로 증가하는 순서로 (단, 아스키 코드에서 대문자는 소문자보다 작으므로 사전순으로 앞에 온다.) 내 생각 java의 Comparable 인터페이스를 통한 정렬을 할 줄 안다면 쉽게 풀수 있는 문제이다. 코드 ```javapackage boj_10825; import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.StringTokenizer;class Student implements Comparable {String name;int koreanScore;int englishScore;int mathScore;public Student(String name, int koreanScore, int englishScore, int mathScore) { this.name = name; this.koreanScore = koreanScore; this.englishScore = englishScore; this.mathScore = mathScore;}@Overridepublic int compareTo(Student o) { if(this.koreanScore == o.koreanScore &amp;amp;&amp;amp; this.englishScore == o.englishScore &amp;amp;&amp;amp; this.mathScore == o.mathScore) { return this.name.compareTo(o.name); } if(this.koreanScore == o.koreanScore &amp;amp;&amp;amp; this.englishScore == o.englishScore) { return Integer.compare(o.mathScore, this.mathScore); } if(this.koreanScore == o.koreanScore) { return Integer.compare(this.englishScore, o.englishScore); } return Integer.compare(o.koreanScore, this.koreanScore);}}public class BOJ_10825 {public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st; List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;(); int n = Integer.parseInt(br.readLine()); for (int i = 0; i &amp;lt; n; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); String name = st.nextToken(); int koreanScore = Integer.parseInt(st.nextToken()); int englishScore = Integer.parseInt(st.nextToken()); int mathScore = Integer.parseInt(st.nextToken()); students.add(new Student(name, koreanScore, englishScore, mathScore)); } Collections.sort(students); students.forEach(s -&amp;gt; System.out.println(s.name));} }```" }, { "title": "BOJ 14502 연구소 문제풀이", "url": "/posts/BOJ14502/", "categories": "algorithm, java", "tags": "algorithm", "date": "2021-12-30 14:13:32 +0800", "snippet": "문제인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.2 1 0 0 1 1 01 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 1 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0바이러스가 퍼진 뒤의 모습은 아래와 같아진다.2 1 0 0 1 1 21 0 1 0 1 2 20 1 1 0 1 2 20 1 0 0 0 1 20 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.내 생각이 문제는 bfs, dfs 를 연습하기 아주 좋은 문제이다. 벽을 3개 만드는 부분은 dfs로, 바이러스를 퍼트리는 부분은 bfs로 풀면 쉽게 풀 수 있다.코드package boj_14502;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.LinkedList;import java.util.Queue;import java.util.StringTokenizer;class Node { private final int x; private final int y; public Node(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; }}public class BOJ_14502 { static int n, m; static int[][] map; static int maxSafeAreaCount = 0; static int[] dx = {-1, 1, 0, 0}; static int[] dy = {0, 0, -1, 1}; public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); n = Integer.parseInt(st.nextToken()); m = Integer.parseInt(st.nextToken()); map = new int[n][m]; for (int i = 0; i &amp;lt; n; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); for (int j = 0; j &amp;lt; m; j++) { map[i][j] = Integer.parseInt(st.nextToken()); } } makeWall(0); System.out.println(maxSafeAreaCount); } private static void makeWall(int depth) { if (depth == 3) { int[][] copyWall = copyWall(map); spreadVirus(copyWall); checkSafeArea(copyWall); return; } for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (map[i][j] == 0) { map[i][j] = 1; makeWall(depth + 1); map[i][j] = 0; } } } } private static void checkSafeArea(int[][] copyWall) { int result = 0; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if(copyWall[i][j] == 0) { result++; } } } maxSafeAreaCount = Math.max(maxSafeAreaCount, result); } private static int[][] copyWall(int[][] map) { int[][] copyWall = new int[n][m]; for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { copyWall[i][j] = map[i][j]; } } return copyWall; } private static void spreadVirus(int[][] map) { for (int i = 0; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; m; j++) { if (map[i][j] == 2) { bfs(i, j, map); } } } } private static void bfs(int x, int y, int[][] map) { Queue&amp;lt;Node&amp;gt; q = new LinkedList&amp;lt;&amp;gt;(); q.offer(new Node(x, y)); while(!q.isEmpty()) { Node now = q.poll(); x = now.getX(); y = now.getY(); for (int i = 0; i &amp;lt; 4; i++) { int nx = x + dx[i]; int ny = y + dy[i]; if(nx &amp;gt;= n || nx &amp;lt; 0 || ny &amp;gt;= m || ny &amp;lt; 0) continue; if(map[nx][ny] == 0) { map[nx][ny] = 2; q.offer(new Node(nx, ny)); } } } }}" }, { "title": "내가 모르던 git(5)", "url": "/posts/git(5)/", "categories": "git", "tags": "git", "date": "2021-12-29 16:49:29 +0800", "snippet": "내가 모르던 git(5)이 글은 팀 개발을 위한 Git, GitHub 시작하기 를 읽고 제가 모르는 부분을 정리한 문서입니다.git config : 옵션 확인Git의 옵션에는 지역 옵션 과 전역 옵션, 시스템 환경 옵션 의 세 종류가 있습니다. 시스템 환경 옵션 : PC 전체 사용자를 위한 옵션 전역 옵션 : 현재 사용자를 위한 옵션 지역 옵션 : 현재 Git 저장소에서만 유효한 옵션우선 순위는 지역 &amp;gt; 전역 &amp;gt; 시스템 옵션 순입니다.기본명령어 git add 파일1 파일2 … : 파일들을 스테이지에 추가 git add . : 모든 파일 스테이지에 추가 git commit -a : add 명령을 생략하고 바로 커밋, 단 untracked인 파일은 커밋되지 않음 git push [-u] [원격저장소별명] [브랜치이름] : 현재 브랜치에서 새로 생성한 커밋들을 원격저장소에 업로드 합니다. -u 옵션으로 브랜치의 업스트림을 등록할 수 있습니다. 한 번 등록한 후에는 git push만 입력해도 됩니다. git fetch [원격저장소별명] [브랜치이름] : 원격저장소의 브랜치와 커밋들을 로컬 저장소와 동기화 합니다. 옵션을 생략하면 모든 원격저장소에서 모든 브랜치를 가져옵니다. git merge 브랜치이름 : 지정한 브랜치의 커밋들을 현재 브랜치 및 워킹트리에 반영합니다.reset 명령으로 스테이지 취소하기git rm --cached &amp;lt;file&amp;gt; ... 명령으로 스테이지에서 내릴 수 있습니다. 허나 이 명령보다 git reset 을 더 많이 사용합니다. git reset [파일명] ... : 특정 옵션을 주지 않으면 mixed reset이기 때문에 스테이지 영역에 있는 파일들을 스테이지에서 내립니다. 워킹트리의 내용은 변경되지 않습니다. 워킹 트리 : 작업이 일어나는 곳 커밋 메세지 요령커밋 제목과 본문 사이에 한 줄을 띄우는것이 관습입니다.또한 커밋 메세지를 쓸 때는 다음과 같이 적어주는 것이 좋습니다. 제목과 본문을 빈 줄로 분리한다 제목은 50자 이내로 쓴다. 제목을 영어로 쓸 경우 첫 글자는 대문자로 쓴다. 제목에는 마침표를 넣지 않는다. 제목을 영어로 쓸 경우 동사원형(현재형)으로 시작한다. 본문을 72자 단위로 줄바꿈한다. 어떻게 보다 무엇과 왜를 설명한다.Upstream : 원격저장소의 브랜치git push origin master 를 매번 쓰는 것은 귀찮으니 git push 명령으로만 push되게 해봅시다.git push 를 쓰려고 하면은 우선 로컬 저장소 브랜치의 담당 원격 브랜치인 upstream branch 를 지정해 줘야합니다.지정하기 위해서는 첫 push를 할 때, 다음과 같은 명령어를 사용하면됩니다.git push --set-upstream [원격저장소별명] [원격브랜치이름]이 때, —set-upstream은 단축옵션인 -u로 줄 수 있습니다." }, { "title": "디자인 패턴(1) - 디자인 패턴의 소개", "url": "/posts/design(1)/", "categories": "design patterns", "tags": "design patterns", "date": "2021-12-28 17:43:22 +0800", "snippet": "Design Pattern(1) - 디자인 패턴의 소개이 글은 Head First Design Patterns 을 읽고 정리한 글입니다.SimuDuck 어플리케이션은 오리 시뮬레이션 게임입니다. 이 시스템을 처음 만든 사람은 표준적인 객체지향 기법을 사용하여 Duck 이라는 수퍼 클래스를 만든다음, 그 클래스를 확장하여 다른 모든 종류의 오리를 만들었습니다.public abstract class Duck { private String name; private int weight; public Duck(String name, int weight) { this.name = name; this.weight = weight; } public void quack(){} public void swim(){} public void display(){} public String getName() { return name; } public int getWeight() { return weight; } public void setName(String name) { this.name = name; } public void setWeight(int weight) { this.weight = weight; }}public class RedheadDuck extends Duck { public RedheadDuck(String name, int weight) { super(name, weight); } @Override public void display() { System.out.println(&quot;RedheadDuck display&quot;); }}public class MallardDuck extends Duck { public MallardDuck(String name, int weight) { super(name, weight); } @Override public void display() { System.out.println(&quot;Mallard Duck display&quot;); }}그런데 갑자기 회사에서 오리들이 날아다닐 수 있도록 해야 한다는 결정을 내렸습니다.그래서 Duck 클래스에 fly() 메서드를 추가하여 모든 오리들이 날 수 있도록 만들었습니다.public abstract class Duck { ... public void fly(){ System.out.println(&quot;Duck fly&quot;); } ...}하지만 기획에서 모든 오리들이 날 수 있는 것은 아니라고 결론이 났습니다. 따라서 위의 방식을 사용 할 경우, 날지 못하는 오리들은 fly() 메서드를 오버라이드 해서 아무것도 하지 못하게 해줘야합니다.public class MallardDuck extends Duck { ... @Override public void fly() { // do nothing }}이런 방식의 경우, 모든 오리들의 행동을 개발자가 알고있어야합니다. 새로 추가될때마다 오버라이드를 해줘야 하고요. 이러한 방식이 맞을까요?디자인 원칙 : 어플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리 시킨다.fly() 메서드에 경우, 클래스에 따라서 다른 행동을 가지게 됩니다. 날 수도 있고, 날지 못 할수도 있습니다. 이런 변화가 일어나는 부분을 따로 때어내서 다뤄야합니다.바뀐부분과 그렇지 않은 부분 분리하기fly() 와 quack()을 제외하면 Duck 클래스는 잘 작동하고 있으며, 나머지 부분은 자주 달라지거나 바뀌지 않습니다. 그러므로 몇 가지 자잘한 변경 사항을 제외하면 Duck 클래스는 그대로 두는 게 좋습니다.그럼 이제 오리의 행동 디자인을 해봅시다. 최대한 유연하게 만드는 것이 좋겠죠?디자인 원칙 : 구현이 아닌 인터페이스(추상체)에 맞춰서 프로그래밍한다.나는 행동과 꽥꽥 거리는 행동은 이제 Duck 클래스에서 구현하지 않습니다. 대신 특정 행동만을 목적으로 하는 클래스의 집합을 만들도록 하겠습니다.새로운 디자인을 사용하면 Duck의 서브클래스에는 인터페이스로 표현되는 행동을 사용하게 됩니다.public abstract class Duck { private FlyBehavior flyBehavior; private QuackBehavior quackBehavior; public Duck(FlyBehavior flyBehavior, QuackBehavior quackBehavior) { this.flyBehavior = flyBehavior; this.quackBehavior = quackBehavior; } public void quack(){} public void swim(){} public void display(){} public void fly(){ System.out.println(&quot;Duck fly&quot;); } public void setFlyBehavior(FlyBehavior flyBehavior) { this.flyBehavior = flyBehavior; } public void setQuackBehavior(QuackBehavior quackBehavior) { this.quackBehavior = quackBehavior; }}public interface FlyBehavior { void fly();}public class FlyWithWings implements FlyBehavior { @Override public void fly() { System.out.println(&quot;날고 있어요!&quot;); }}public class FlyNoWay implements FlyBehavior { @Override public void fly() { System.out.println(&quot;저는 날 수 없어요&quot;); }}public interface QuackBehavior { void quack();}public class Quack implements QuackBehavior { @Override public void quack() { System.out.println(&quot;꽥&quot;); }}public class MuteQuack implements QuackBehavior { @Override public void quack() { System.out.println(&quot;조용~&quot;); }}디자인 원칙 : 상속 보다는 구성을 활용한다.오리는 FlyBehavior와 QuackBehavior가 있으며, 각각 나는 행동과 꽥꽥 거리는 행동을 위임 받습니다. 두 클래스가 이런 식으로 합치는 것을 구성(Composition)을 이용하는 것이라고 부릅니다.지금까지 봐 왔던 것 처럼, 구성을 이용하여 시스템을 만들면, 유연성을 크게 향상 시킬 수 있습니다. 단순히 알고리즘 군을 별도의 클래스의 집합으로 캡슐화 할 수 있도록 만들어주는 것 뿐 아니라, 구성요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행시에 행동을 바꿀 수도 있게 해줍니다." }, { "title": "내가 모르던 git(4)", "url": "/posts/git(4)/", "categories": "git", "tags": "git", "date": "2021-12-28 14:56:32 +0800", "snippet": "내가 모르던 git(4)원격 저장소 까지 amend 된 것을 바꾸려면 force push를 쓰자amend 는 가장 최근의 커밋을 정정 할 수 있는 기능입니다.. 로컬에서 커밋을 정정할 때는 그냥 amend 옵션을 주면되지만 만약 원격까지 push를 한 상황에 로컬에서 amend를 한 상황이라면 아래와 같은 상태일것입니다.로컬 저장소에 변경사항을 원격저장소에 강제로 덮어씌우며 push 하는 명령이 force push입니다. 허나 이는 강제적이기 때문에 여럿이서 사용하는 브랜치에서 하는 것은 좋지않습니다.Cherry-pick : 특정 커밋만 똑 때서 다른데에 붙여야지만약 latest에 급하게 버그가 생겨서 hotfix를 따야하는 상황이라고 가정해봅시다. 이 때, latest 브랜치에 직접 수정을 가하는 게 옳은 행위일까요?latest 브랜치는 배포 브랜치로, master에서 일어난 굵직굵직한 일을 반영해 실 사용서버에 배포하는 용도로 쓰입니다. 즉, master에서 수정된 것을 들고오는 것이기 때문에 직접 수정하는 행위는 옳지 않습니다.cherry-pick은 이러한 상황에서 도움을 줍니다. 특정 커밋만 따서 다른 브랜치에 반영할 수 있습니다.지금같은 상황에서는 bug와 관련된 구현을 한 master 브랜치의 특정 커밋을 cherry-pick 하여 latest에 반영하면 될 것입니다.실제로는 master 브랜치에서 버그 관련 브랜치 생성 후 기능구현, master에 병합, cherry-pick으로 latest에 반영 의 순서로 진행될 것 입니다.아래 사진을 보면 feat/a, feat/b 브랜치가 보입니다. 현재 상황은 feat/b 브랜치가 feat/a 의 두 번째 커밋만 cherry-pick 하여 가져온 모습을 볼 수 있습니다. 이 때, feat/a의 두 번째 커밋과 feat/b의 두번째 커밋은 내용은 같지만 다른 커밋입니다.Reset : 과거의 이력으로 돌아가자Reset도 여러 종류가 있습니다. Soft : 특정 이력으로 돌아가되, 특정 이력 이후의 변경했던 코드들은 스테이지 위로 올라가있습니다 Mixed : Soft와 같이 특정이력으로 돌아기지만, 변경했던 코드들은 스테이지 아래에 있습니다. Hard : 특정이력으로 돌아가면서 변경했었던 모든 코드들도 지워집니다." }, { "title": "내가 모르던 git(3)", "url": "/posts/git(3)/", "categories": "git", "tags": "git", "date": "2021-12-28 13:08:29 +0800", "snippet": "내가 모르던 git(3)이 글은 팀 개발을 위한 Git, GitHub 시작하기 를 읽고 제가 모르는 부분을 정리한 문서입니다.여러 원격 저장소 히스토리를 한눈에 보자 : 리모트 추가내 원격 저장소외에도 다른 원격 저장소의 히스토리를 함께 볼 수 있다.아래 예제의 경우, 2개의 원격 저장소를 같이 보고있는 경우이다. 이런 식으로, 내 브랜치와 원본 저장소를 같이 봄으로써 원격저장소의 변경사항을 빠르게 이해하고 내 것에 반영하는데 도움을 줄 수 있다.소스트리를 사용하여, 저장소 → 원격 저장소 추가에 들어가서 추가해보도록하자.이 때, 원격 이름은 관용적으로 upstream 이라는 이름을 사용한다.원격 저장소를 추가하면 소스트리 화면 좌측에 원격 → upstream 이 생성된 것을 볼 수 있다.fetch 를 통해서 가져오면 아래와 같이 원본 저장소의 상황과 내 저장소의 상황이 함께 보이는 것을 볼 수 있다.묵은 커밋을 새 커밋으로 이력 조작하기(rebase)merge 의 경우, fast-forward 가 아니라면 커밋 이력이 남는다. 개발자가 여럿이라면 이러한 커밋 이력은 가만히 나누기에는 너무 많은 양 일 것이다. 다행히 git은 이러한 상황에 대해 해결책을 가지고 있다. 그게 바로 rebase 이다.rebase 는 내가 처음 브랜치를 딴 base 커밋을 조작하는 것이다. 아래 사진을 보자.너구리는 0번 커밋을 base 로 커밋이력을 갱신하고 있다. 허나 고양이의 upstream/master에 merge 를 하려니 confilct로 인해 merge 커밋이력이 쌓이고 만다.rebase 는 이러한 상황에서 base 인 0번 커밋을 3번 커밋으로 바꿔버리는 방식이다.이러면, fast-forward 방식이기 때문에 별도의 커밋이력이 남지 않는 효과를 가지고 올 수 있다.허나 이러한 rebase 는 이력을 조작 하는 것이기에 굉장히 조심해야한다. 만약 다른 사람과 같이 쓰는 branch에서 rebase 를 했다면 동료 개발자는 갑자기 바뀐 이력에 어지러워 할 것이다. 그러니 rebase는 반드시 혼자만 쓰는 브랜치에서 수행해야 한다.아래 사진을 보면, 붉은 색의 origin/master 의 커밋베이스는 좋아요 기능 추가 였으나, upstream/master의 개발자 목록에 너구리 추가 로 커밋 베이스를 옮긴 것을 볼 수 있다.하지만 이건 로컬에서만 반영 된 것이고 원격에는 반영되지 않았다. 따라서 push를 통해 반영해야하는데 rebase 는 이력을 조작한 것이기 때문에 보통 push로는 안되고 force push를 해줘야한다." }, { "title": "내가 모르던 git(2)", "url": "/posts/git(2)/", "categories": "git", "tags": "git", "date": "2021-12-27 15:57:33 +0800", "snippet": "이 글은 팀 개발을 위한 Git, GitHub 시작하기 를 읽고 제가 모르는 부분을 정리한 문서입니다.커밋은 Delta(차이점)가 아니라 SnapshotGit은 커밋에 바뀐 것만 저장하는 것이 아니라 전체 코드를 저장한다.Git으로 관리하는 파일의 4가지 상태 untracked : 아직 git이 관리하고 있지 않음 staged : 스테이지 위에 올림, git이 보고있음 unmodified : 커밋에 의해서 스냅샷에 찍힌 후에, 수정한 적이 없음 modified : 커밋에 의해서 스냅샷에 찍힌 후에, 수정된 상태브랜치브랜치는 커밋에 대한 길이 아니라 단순한 포인터이다. 길 처럼 보인 이유는, 새로운 커밋이 이전 커밋을 가리키는 화살표 때문이다. 그러한 화살표는 브랜치와는 아무런 연관이 없다.브랜치는 물리적인 길이 아니고 단순한 포인터이기 때문에 SVN 등에 비해 가볍고 빠르다는 특징이있다.만약 위의 그림과 같이 2개의 브랜치가 존재한다면, 분명 우리는 둘 중 하나를 보고있어야하며, 서로 다른 2개의 브랜치를 넘나들수 있어야한다. 이를 위해서는 이 브랜치를 가리키고 있는 포인터가 하나 더 필요하다. 그게 HEAD 이다.아래 그림을 보면, HEAD 가 master 를 보고 있으면 커밋 5를, 고양이 를 보고있으면 커밋 4를 볼 수 있음을 짐작할 수 있다.병합의 3가지병합은 두 버전의 합집합을 구하는 것이다. 상황에 따라 3가지의 경우가 나온다 병합 커밋 : 1버전과 2버전의 합집합이 나오게 된다. 새로운 커밋이 생기게된다. Fast-forward : 1개의 버전이 다른 버전에 집합관계이기 때문에 새로운 커밋을 만들어줄 필요없이 상태를 바꿔주기만한다. Confilct : 1버전과 2버전이 동일 파일을 변경할 경우, 어떠한 것을 커밋해야할지 몰라 생기게 된다. 개발자가 수작업으로 해결해야한다.풀은 실제 코드를 내려받고, 패치는 그래프만 업데이트 해준다소스트리는 10분에 한 번씩 자동으로 패치를 하기 때문에 그래프가 매번 새로워보인다.태그도 포인터이다.태그는 별다른 특정 기능을 하는것이 아닌 그저 포인터의 일환이다." }, { "title": "내가 모르던 git(1)", "url": "/posts/git(1)/", "categories": "git", "tags": "git", "date": "2021-12-27 13:31:29 +0800", "snippet": " git log는 최신 순으로 내림차순 정렬된다. 원격저장소 명령어는 git remote add 원격저장소이름(보통 origin) 원격저장소주소이다git remote add origin https://github.com/sirin0762/git-tutorial.git Detached HEAD우선 HEAD를 알아보자. git은 HEAD 라는 포인터를 하나 가지고 있다. 이 포틴터는 지금 작업하는 로컬 브랜치를 가리킨다. 즉, 현재 작업하고있는 브랜치의 마지막 커밋이다.보통 브랜치는 특정 커밋의 revision number를 기리키고, HEAD가 이 브랜치를 가리킨다. 이러한 HEAD → 브랜치 → 특정 커밋 순서로 commit을 가리키는 상태를 attached HEAD 상태 라고 한다. Detached HEAD란 HEAD가 브랜치를 통해 간접적으로 commit을 가리키지 않고, 직접 커밋을 가리키는 것을 말한다.현재 나는 첫번 쨰 커밋으로 checkout한 상태이다. 따라서 HEAD가 첫번 쨰 커밋을 직접 가리키고 있어 Detached HEAD 상태이다.git log를 보면 두번쨰 커밋이 사라진 것을 알 수있다.이렇게 커밋이 사라졌을 때는 git log가 아닌 git reflog를 통해서 HEAD의 이동경로를 파악하여 되돌리면 된다.보면 두번쨰 커밋 revision number가 보이기 때문에 해당 번호로 이동하면 된다.허나 이경우 HEAD만 옮긴 것이고 아직 브랜치와 head가 연결된 상태는 아니다.이를 해결하기 위해서는 새로운 브랜치를 만들어 head와 연결 후 기존의 master 브랜치와 합쳐준다.이 방식 외에도 기존 브랜치에 커밋을 붙이는 방식도 가능하다. git reflog 로 떠다니는 커밋의 id를 확인 git checkout 기존 브랜치 기존 브랜치로 이동 git cherry-pick 커밋 id 떠다니던 커밋을 기존 브랜치에 붙이기방식이 어떠하든 결국 둥둥 떠잇는 커밋을 브랜치에 붙이는게 핵심이다." }, { "title": "BOJ_12904 A와 B 문제 풀이", "url": "/posts/BOJ12904/", "categories": "algorithm, java", "tags": "algorithm", "date": "2021-12-27 10:58:29 +0800", "snippet": "문제수빈이는 A와 B로만 이루어진 영어 단어가 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.문자열의 뒤에 A를 추가한다.문자열을 뒤집고 뒤에 B를 추가한다.주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오.입력첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 999, 2 ≤ T의 길이 ≤ 1000, S의 길이 &amp;lt; T의 길이)출력S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.내 생각이 문제는 전형적인 재귀를 통해서 조건을 판단하는 문제이다. t를 s로 만드는 방향으로 코드를 짜면 된다. 내 생각은 다음과 같다. t -&amp;gt; s 로 만들때 2가지를 선택할 수 있다. 이를 계속 반복한다. 만약 t.endsWith(“A”) = true 라면, 뒤에서 A를 빼주면된다. false 라면, t.endSWith(“B”) = true 이기 때문에, 뒤에서 B를 빼주고 문자열을 뒤집는다. 그 후 t.length() == s.length() 상태까지 오게 되면, equals() 를 통해서 같은 지 확인한다.코드package boj_12904;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class BOJ_12904 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String s = br.readLine(); String t = br.readLine(); if(isTransform(s, t)) { System.out.println(1); } else { System.out.println(0); } } private static boolean isTransform(String s, String t) { if(t.length() == s.length()) { return t.equals(s); } if(t.endsWith(&quot;A&quot;)) { return isTransform(s, t.substring(0, t.length() - 1)); } else { return isTransform(s, new StringBuilder(t.substring(0, t.length() - 1)).reverse().toString()); } }}느낀 점문제를 읽고, 재귀를 써야하는구나를 느꼈지만 재귀에 대해서 막연한 두려움이 있었다. 그런데 코드로 옮기니 생각 이상으로 쉬운 문제였다. 역시 코딩은 Just Do it이다.재귀를 두려워하는 누군가를 위해, 나는 재귀를 사용할 때 2가지를 미리 정하고 코드를 짠다. 이게 맞는지는 모르겠다. 종료 조건을 먼저 적어라. 어떤 상태에서 종료시킬 것인지를 명확하게 하면 반복할 때 햇갈리지 않는다. 반복 조건을 적고 구현한다." }, { "title": "BOJ_1753 최단경로 문제 풀이", "url": "/posts/BOJ1753/", "categories": "algorithm, java", "tags": "algorithm", "date": "2021-01-25 09:49:29 +0800", "snippet": "문제BOJ 최단 경로 문제 링크내 생각다익스트라 알고리즘을 알고 있냐? 를 묻는 문제이다. 다익스트라 알고리즘을 아는 사람은 문제를 보자마자 유추할 수있는 정도의 문제였다.코드package boj_1753;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.util.ArrayList;import java.util.Arrays;import java.util.PriorityQueue;import java.util.StringTokenizer;class Node implements Comparable&amp;lt;Node&amp;gt; { private int index; private int distance; public Node(int index, int distance) { this.index = index; this.distance = distance; } public int getIndex() { return index; } public int getDistance() { return distance; } @Override public int compareTo(Node o) { if(this.distance &amp;lt; o.distance) { return -1; } return 1; }}public class Main { public static final int INF = (int) 1e9; public static int v, e, start; public static int[] d; public static ArrayList&amp;lt;ArrayList&amp;lt;Node&amp;gt;&amp;gt; GRAPH = new ArrayList&amp;lt;&amp;gt;(); public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); StringTokenizer st = new StringTokenizer(br.readLine(), &quot; &quot;); v = Integer.parseInt(st.nextToken()); e = Integer.parseInt(st.nextToken()); start = Integer.parseInt(br.readLine()); d = new int[v + 1]; Arrays.fill(d, INF); for(int i = 0; i &amp;lt;= v; i++) { GRAPH.add(new ArrayList&amp;lt;&amp;gt;()); } for (int i = 0; i &amp;lt; e; i++) { st = new StringTokenizer(br.readLine(), &quot; &quot;); int start = Integer.parseInt(st.nextToken()); int end = Integer.parseInt(st.nextToken()); int weight = Integer.parseInt(st.nextToken()); GRAPH.get(start).add(new Node(end, weight)); } dijkstra(start); for (int i = 1; i &amp;lt;= v; i++) { if(d[i] == INF) { System.out.println(&quot;INF&quot;); } else { System.out.println(d[i]); } } } private static void dijkstra(int start) { PriorityQueue&amp;lt;Node&amp;gt; pq = new PriorityQueue&amp;lt;&amp;gt;(); pq.offer(new Node(start, 0)); d[start] = 0; while(!pq.isEmpty()) { Node node = pq.poll(); int dist = node.getDistance(); int now = node.getIndex(); if(d[now] &amp;lt; dist) continue; for(int i = 0; i &amp;lt; GRAPH.get(now).size(); i++) { int cost = d[now] + GRAPH.get(now).get(i).getDistance(); if(cost &amp;lt; d[GRAPH.get(now).get(i).getIndex()]) { d[GRAPH.get(now).get(i).getIndex()] = cost; pq.offer(new Node(GRAPH.get(now).get(i).getIndex(), cost)); } } } }}" }, { "title": "생활코딩 web 3 - node.js chapter 8. Not Fonud 구현", "url": "/posts/8/", "categories": "node js", "tags": "", "date": "2020-12-11 00:00:00 +0800", "snippet": "8. Not Fonud 구현이번에 할 것은 사용자가 우리가 원하지 않는 URL로 들어왔을 때를 대비한 Not Found를 구현할 것이다. 로직은 이렇다. url을 따서 거기에 pathname을 확인, 우리가 만들어 놓은 것과 일치하면 화면을 보여주고 아니면 404에러를 보여주면된다.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var url = require(&#39;url&#39;);var app = http.createServer(function(request,response){ var _url = request.url; var queryData = url.parse(_url, true).query; //바뀐부분 var pathName = url.parse(_url, true).pathname; var title = queryData.id //바뀐 부분 if(pathName === &#39;/&#39;){ fs.readFile(`data/${title}`, &#39;utf8&#39;, (err, desc) =&amp;gt;{ var template = ` &amp;lt;!doctype html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;WEB1 - ${title}&amp;lt;/title&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;WEB&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=HTML&quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=CSS&quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=JavaScript&quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;h2&amp;gt;${title}&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;${desc}&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ` response.end(template); }) } else{ response.writeHead(404); response.end(&#39;Not Found&#39;); } });app.listen(3000);또한 우리는 현재 home 을 구현하지 않았다. 이번에는 home 도 구현해보자. 현재 home의 경우 쿼리스트링이 없어서 title, desc 모두 undefined 가 나온다. 그러니 undefined 이면 홈이라는 뜻이다 이를 이용해서 구현해보자.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var url = require(&#39;url&#39;);var app = http.createServer(function(request,response){ var _url = request.url; var queryData = url.parse(_url, true).query; var pathName = url.parse(_url, true).pathname; if(pathName === &#39;/&#39;){ //바뀐 부분 if(queryData.id === undefined){ fs.readFile(`data/${queryData.id}}`, &#39;utf8&#39;, (err, desc) =&amp;gt;{ var title = &#39;Welcome&#39;; desc = &quot;Hello, Node.js&quot;; var template = ` &amp;lt;!doctype html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;WEB1 - ${title}&amp;lt;/title&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;WEB&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=HTML&quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=CSS&quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=JavaScript&quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;h2&amp;gt;${title}&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;${desc}&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ` response.end(template); }) //바뀐 부분 }else{ fs.readFile(`data/${queryData.id}`, &#39;utf8&#39;, (err, desc) =&amp;gt;{ var title = queryData.id var template = ` &amp;lt;!doctype html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;WEB1 - ${title}&amp;lt;/title&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;WEB&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=HTML&quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=CSS&quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=JavaScript&quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;h2&amp;gt;${title}&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;${desc}&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ` response.end(template); }) } } else{ response.writeHead(404); response.end(&#39;Not Found&#39;); } });app.listen(3000);" }, { "title": "생활코딩 web 3 - node.js chapter 7. 콘솔에서의 입력값", "url": "/posts/7/", "categories": "node js", "tags": "", "date": "2020-12-11 00:00:00 +0800", "snippet": "7. 콘솔에서의 입력값이번에는 node js를 실행할 때의 입력값에 대해서 알아보자. nodejs 폴더 아래에 console.js라는 파일을 만들고 아래와 같이 실행해보자.var args = process.argv;console.log(args);//결과[ &#39;C:\\\\Program Files\\\\nodejs\\\\node.exe&#39;, &#39;C:\\\\Users\\\\tlsdy\\\\Documents\\\\Shin\\\\블로그\\\\sirin0762.github.io\\\\_posts\\\\생활코딩 node js\\\\nodejs\\\\console.js&#39;]보면 node js를 실행시킨 argument 들이 나온다. 이게 process.argv 이다. 이렇게 console 에서의 입력 값의 변화를 통해서 다른 파일을 불러올 수도, 다른 로직을 구상할 수도 있다." }, { "title": "생활코딩 web 3 - node.js chapter 6. 파일을 이용해 본문 구현", "url": "/posts/6/", "categories": "node js", "tags": "", "date": "2020-12-11 00:00:00 +0800", "snippet": "6. 파일을 이용해 본문 구현html 파일 안에 본문을 빼내와 data 폴더에 txt 파일로 넣어놓고, readFile 함수를 통해서 불러온다. 이때 매개변수를 queryData.id를 이용함으로써 파일마다의 구분이 가능하다. 아래 코드를 보자.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var url = require(&#39;url&#39;);var app = http.createServer(function(request,response){ var _url = request.url; var queryData = url.parse(_url, true).query; var title = queryData.id if(_url == &#39;/&#39;){ title = &#39;Welcome&#39;; } if(_url == &#39;/favicon.ico&#39;){ response.writeHead(404); response.end(); return; } response.writeHead(200); fs.readFile(`data/${title}`, &#39;utf8&#39;, (err, desc) =&amp;gt;{ var template = ` &amp;lt;!doctype html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;WEB1 - ${title}&amp;lt;/title&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;WEB&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=HTML&quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=CSS&quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=JavaScript&quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;h2&amp;gt;${title}&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;${desc}&amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ` response.end(template); })});app.listen(3000);" }, { "title": "생활코딩 web 3 - node.js chapter 5. Nodejs의 파일 읽기 기능", "url": "/posts/5/", "categories": "node js", "tags": "", "date": "2020-12-11 00:00:00 +0800", "snippet": "5. Nodejs의 파일 읽기 기능readfile.js 라는 파일을 만들어서 예제를 보여주겠다.const fs = require(&quot;fs&quot;);fs.readFile(&#39;nodejs/sample.txt&#39;, &#39;utf8&#39;, (err, data) =&amp;gt; { if(err){ throw err; } console.log(data)})파일을 넣어주면 파일을 읽어서 내 맘대로 처리가 가능하다. 파일이 깨져서 나오면 utf8을 추가해줘라." }, { "title": "생활코딩 web 3 - node.js chapter 4. 동적인 웹페이지 만들기", "url": "/posts/4/", "categories": "node js", "tags": "", "date": "2020-12-10 00:00:00 +0800", "snippet": "4. 동적인 웹페이지 만들기아래 코드를 보자.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var url = require(&#39;url&#39;);var app = http.createServer(function(request,response){ var _url = request.url; var queryData = url.parse(_url, true).query; var title = queryData.id if(_url == &#39;/&#39;){ title = &#39;Welcome&#39;; } if(_url == &#39;/favicon.ico&#39;){ response.writeHead(404); response.end(); return; } response.writeHead(200); // 바뀐부분 var template = ` &amp;lt;!doctype html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;WEB1 - ${title}&amp;lt;/title&amp;gt; &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;&amp;lt;a href=&quot;/&quot;&amp;gt;WEB&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=HTML&quot;&amp;gt;HTML&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=CSS&quot;&amp;gt;CSS&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;?id=JavaScript&quot;&amp;gt;JavaScript&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;h2&amp;gt;${title}&amp;lt;/h2&amp;gt; &amp;lt;p&amp;gt;&amp;lt;a href=&quot;https://www.w3.org/TR/html5/&quot; target=&quot;_blank&quot; title=&quot;html5 speicification&quot;&amp;gt;Hypertext Markup Language (HTML)&amp;lt;/a&amp;gt; is the standard markup language for &amp;lt;strong&amp;gt;creating &amp;lt;u&amp;gt;web&amp;lt;/u&amp;gt; pages&amp;lt;/strong&amp;gt; and web applications.Web browsers receive HTML documents from a web server or from local storage and render them into multimedia web pages. HTML describes the structure of a web page semantically and originally included cues for the appearance of the document. &amp;lt;img src=&quot;coding.jpg&quot; width=&quot;100%&quot;&amp;gt; &amp;lt;/p&amp;gt;&amp;lt;p style=&quot;margin-top:45px;&quot;&amp;gt;HTML elements are the building blocks of HTML pages. With HTML constructs, images and other objects, such as interactive forms, may be embedded into the rendered page. It provides a means to create structured documents by denoting structural semantics for text such as headings, paragraphs, lists, links, quotes and other items. HTML elements are delineated by tags, written using angle brackets. &amp;lt;/p&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; ` response.end(template); });app.listen(3000);복잡해보이지만 사실은 어려울 꺼 하나없다. 그냥 1.html을 복사해서 타이틀 부분에 querydata id의 value를 넣어준게 전부이다. node js를 실행시켜보면. 다음과 같이 나오는 것을 알 수있다. undefined 가 나오는 이유는 현재 url이 1.html 이기 때문에 queryData가 없어서 아예 나오지 않는 것이다. 이번 강좌를 통해서 우리는 동적으로 웹페이지를 보여주기 시작했다. 앞으로 더 재밌어질 것같다." }, { "title": "생활코딩 web 3 - node.js chapter 3. URL을 통해서 입력된 값 사용하기", "url": "/posts/3/", "categories": "node js", "tags": "", "date": "2020-12-10 00:00:00 +0800", "snippet": "3. URL을 통해서 입력된 값 사용하기 이번 강좌는 저 쿼리 스트링에 우리의 파일들을 넣어보는 시간이다. 쿼리 스트링에 따라 다른 정보들을 보여주는걸 해보자. 우리가 처음 해야할 것은 당연히 쿼리 스트링의 분석이다. 아래 코드를 봐보자.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);// 바뀐 부분 var url = require(&#39;url&#39;);var app = http.createServer(function(request,response){ var _url = request.url; // 바뀐 부분 var queryData = url.parse(_url, true).query; console.log(queryData); if(_url == &#39;/&#39;){ _url = &#39;/index.html&#39;; } if(_url == &#39;/favicon.ico&#39;){ response.writeHead(404); response.end(); return; } response.writeHead(200); response.end(fs.readFileSync(__dirname + _url)); });app.listen(3000);천천히 코드를 분석해보자. 일단 require 는 모듈을 불러오는 방법이다. 의미는 이렇다. url이라는 변수에 url이라는 모듈을 담아 놓을게 라는 뜻으로 이해하면된다. 이제 해당 모듈의 사용은 url이라는 변수를 사용하면 된다. 다음 바뀐 부분을 보자. query문의 정보를 들고 오는 것이다. 아래 사진에 자세한 사용법이 나와있다.url 문자열을 객체로 변환해주는 친구이다. 변환 해서 정보를 얻어보면.Url { protocol: null, slashes: null, auth: null, host: null, port: null, hostname: null, hash: null, search: null, query: [Object: null prototype] {}, pathname: &#39;/coding.jpg&#39;, path: &#39;/coding.jpg&#39;, href: &#39;/coding.jpg&#39;}이렇게 다양한 정보를 얻을 수 있다. 우리는 그 중에 퀴리라는 변수를 알아내면 된다. 그렇게 쿼리를 뽑아내면 [Object: null prototype] { id: &#39;HTML&#39; } 라는 object가 나온다(그냥 실행하면 나오지 않는다. url에 1.html 대신 ?id=HTML을 넣어서 보여지게 끔 한것이다). 이걸 보면 우리는 url을 통해서 쿼리스트링을 뽑아 낼 수 있는 것을 알 수 있다. 이번엔 url에 http://localhost:3000/?id=HTML 을 넣어보자. 그리고 코드를 살짝 수정하면.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var url = require(&#39;url&#39;);var app = http.createServer(function(request,response){ var _url = request.url; var queryData = url.parse(_url, true).query; console.log(queryData); if(_url == &#39;/&#39;){ _url = &#39;/index.html&#39;; } if(_url == &#39;/favicon.ico&#39;){ response.writeHead(404); response.end(); return; } response.writeHead(200); //바뀐 부분 response.end(queryData.id); });app.listen(3000); 우리가 적었던 id의 value가 나오는 것을 알 수 있다. 이렇게 우리가 url을 들고오는 방법에 대해서 알아봤다." }, { "title": "생활코딩 web 2 - node.js chapter 2. URL의 이해", "url": "/posts/2/", "categories": "node js", "tags": "", "date": "2020-12-10 00:00:00 +0800", "snippet": "2.URL의 이해본론으로 들어가기에 앞서 URL에 대해서 알아보자. 저번 강좌에서와 같이 main.js를 실행하고 localhost:3000으로 들어가보자. 그리고 각각의 a태그들을 클릭해보면, 우리는 4개의 파일을 가지고 있음을 알게된다. 그렇다면 만약에 1억개의 웹페이지가 있다면, 우리는 1억개의 파일을 들고있어야 하는 걸까? 당연히 아니다. 동적으로 보여주는거다. 그걸 알기 위해서 URL에 대해서 알아야한다. 아래 사진을과 글을 보자. protocol : 통신 규약입니다. 보내는 쪽과 받는 쪽이 어떻게 포멧을 설정할 것인가에 대한 내용입니다. host(domain name) : 인터넷의 접속되어 있는 각각의 컴퓨터를 말함(컴퓨터의 주소) port 번호 : 한 대의 컴퓨터 안에 여러개의 서버가 있다고 생각하면됨, 3000번 포트와 연결되어있는 서버와 통신하는 것이다. 웹서버는 80번을 쓴다. path : 어느 디렉토리의 어떤 파일인지 query string : ?(물음표로 시작) 사용자가 서버에게 질의 한다는 이름이다. 값과 값은 &amp;amp;를 쓰기로 되어있고 값의 이름과 값은 ‘=’으로 구분되어 있다.굉장히 중요한 정보이니 꼭 알아뒀으면 좋겠다." }, { "title": "생활코딩 web 2 - node.js chapter 1. 웹 서버 만들기", "url": "/posts/1/", "categories": "node js", "tags": "", "date": "2020-12-10 00:00:00 +0800", "snippet": "1. 웹 서버 만들기이번 시간에서는 web 1 internet의 뒤를 이은 web 2 node.js 강좌의 시작이다. 현재까지의 소스코드를 보면은 1.html, 2.html, 3.html, main.html 4개의 html 파일을 만들어서 한 페이지당 1개의 html을 만들었는데, 이제는 그렇게 하지 않는다. 각설하고 바로 시작해보자. 처음 해야할 것은 main.js 를 만드는 것이다. 안에 코드는 이렇게 작성하자.var http = require(&#39;http&#39;);var fs = require(&#39;fs&#39;);var app = http.createServer(function(request,response){ var url = request.url; if(request.url == &#39;/&#39;){ url = &#39;/index.html&#39;; } if(request.url == &#39;/favicon.ico&#39;){ response.writeHead(404); response.end(); return; } response.writeHead(200); response.end(fs.readFileSync(__dirname + url)); });app.listen(3000);이렇게 작성한뒤 브라우저에 localhost:3000을 입력하면 web 1의 홈페이지가 나올 것이다. 말 그대로 웹서버를 가동 시킨 것이다. 아직은 이게 무슨 소리인줄 모를것이다. 저거를 배우는게 이번 강좌의 핵심이다. 이제부터 저 코드가 뭔지, 어떻게 되는 건지를 알아보자." }, { "title": "Nomad_Coder CSS master 3.4 - Awesome Mixins and Conclusions", "url": "/posts/3.4/", "categories": "CSS", "tags": "", "date": "2020-12-05 00:00:00 +0800", "snippet": "3.4 Awesone Mixins and Conclusions이번 시간에는 반응형 디자인을 하는 방법에 대해서 알아본다. @content라는 속성을 이용하여 예제를 풀어나갈 것이다. 아래 예제를 보자. &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt;/*mixins.scss*/@mixin responsive($device) { @if $device == &quot;iphone&quot;{ @media screen and (max-width: 690px){ @content; } } @else if $device == &quot;Tablet&quot;{ @media screen and (min-width: 690px){ @content; } } }" }, { "title": "Nomad_Coder CSS master 3.3 - Extends", "url": "/posts/3.3/", "categories": "CSS", "tags": "", "date": "2020-12-05 00:00:00 +0800", "snippet": "3.3 Extends 우리가 할 것은 이 2개를 같은 디자인의 버튼으로 만드는 것이다. 보면 알겠지만, 왼쪽은 a태그 오른쪽은 버튼이다. 태그 자체가 다르기 때문에 공통된 디자인을 위해서는 같은 부분도 있지만 다른 부분도 있다. 이럴 경우 mixin 으로도 해결 되지만 이번에는 코드의 재사용성을 위해 extend 라는 것을 써보자. 일단 _buttons.scss 파일을 만들고 위의 2개가 가질 공통적인 속성을 넣어주자./*_buttons.scss*/%button{ font-size: 20px; background-color: peru; color: white; border-radius: 7px;}extend 를 사용할 수있는 scss를 만드는 방법은 ‘%’를 사용하는 것이다. 계속 보면,/*styles.scss*/@import &quot;_buttons&quot;;a { @extend %button;}button{ @extend %button;} 공통적으로 버튼 모양처럼 하고 이제 각 태그에 따른 속성만 설정해주면 된다. 계속해보면@import &quot;_buttons&quot;;a { text-decoration: none; @extend %button;}button{ border: none; @extend %button;} 이제 같은 모양이 되었다. 굉장히 놀라운 결과이다." }, { "title": "Nomad_Coder CSS master 3.2 - Mixins", "url": "/posts/3.2/", "categories": "CSS", "tags": "", "date": "2020-12-05 00:00:00 +0800", "snippet": "3.2 Mixinsmixins는 일종의 함수라고 생각하면 된다. 호출하면 함수에 있는것이 적용된다. 아래 예제를 보면 이해가 쉽다. &amp;lt;body&amp;gt; &amp;lt;a&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;a&amp;gt;Google&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt;/*mixins.scss*/@mixin link { text-decoration: none; display: block; }/*styles.scss*/@import &quot;_variables&quot;;@import &quot;_mixins&quot;;body{ background-color: $bg;}a{ @include link();} 현재 mixins 파일 내에서는 link라는 일종의 함수는 2가지의 속성을 가지고 있다. 원래 a는 inline이기 때문에 가로 1줄이 나와야하지만, 현재 styles 파일 내의 a 태그는 link를 들고있기 때문에 display: block이 되있다. 또한 mixin은 함수와 같이 매개변수를 줄 수도 있다. 아래 예제를 보자./*mixins.scss*/@mixin link($color) { text-decoration: none; display: block; color: $color;}@import &quot;_variables&quot;;@import &quot;_mixins&quot;;body{ background-color: white;}a:nth-child(odd){ @include link(pink);}a:nth-child(even){ @include link(blue);} 저렇게 변수를 넣어주게 되면 변수에 따라 바뀌는 것을 알 수있다. 물론 위의 a 태그 또한 합칠수 있다.a:nth-child(odd){ @include link(pink);}a:nth-child(even){ @include link(blue);}/*위 아래 동일 코드*/a{ &amp;amp;:nth-child(odd){ @include link(pink); } &amp;amp;:nth-child(even){ @include link(blue); }}자 이번에는 결과는 같지만 위의 코드를 if else 구문을 이용해보자.@mixin link($word) { text-decoration: none; display: block; @if $word == &quot;odd&quot;{ color: pink; } @else{ color: blue; }}@import &quot;_variables&quot;;@import &quot;_mixins&quot;;body{ background-color: white;}a:nth-child(odd){ @include link(&quot;odd&quot;);}a:nth-child(even){ @include link(&quot;even&quot;);}위의 방식처럼 if else문을 쓸 수도 있다. 우린 드디어 css 에서 logic을 짤 수있다." }, { "title": "Nomad_Coder CSS master 3.1 - Variables and Nesting", "url": "/posts/3.1/", "categories": "CSS", "tags": "", "date": "2020-12-05 00:00:00 +0800", "snippet": "3.1 Variables and Nesting우리가 깐 gulpfile.babel.js 파일에는 특정 파일을 주시하고 있다. 아래 코드를 봐보자.const routes = { css: { watch: &quot;src/scss/*&quot;, src: &quot;src/scss/styles.scss&quot;, dest: &quot;dist/css&quot; }};styles.scss 파일을 보고있는 것을 알 수있다. 즉 저 파일에서 하는 모든 코드는 css로 변환된다. 과정은 이렇다. html 파일은 styles.css 파일을 보고있고 styles.scss 파일에서 적은 것은 styles.css 파일에서 css로 변환된다. 1. Variable Variable은 보통 website에서 가장 중요한 colors나 가장 중요한 style을 저장하고 싶을 떄 쓴다. scss에서 변수를 사용하는 방법은 src/scss 아래에 _variables.scss 파일을 만들면된다. 사실 다른 이름으로 해도 된다. 허나 가장 중요한 것은 파일 앞에 밑줄이다. 밑줄이 있는 파일은 css로 변환되지 않는 파일이다. translate 되거나 complie 되지 않는다. 이 파일안에서 ‘$’를 넣으면 그게 변수이다. 아래 예제를 보자.$bg: #e7473c;bg라는 변수가 저 색깔이라는 뜻이다. 이제 import를 해주자.@import &quot;_variables&quot;;body{ background-color: $bg;}이렇게 하고 styles.css 파일을 보면body{background-color:#e7473c}이렇게 변환된 모습을 볼 수있다. ___ 2. Nesting Nesting은 코드르 더 정확하게 해준다. 정확하게 말하면, 너가 타겟하는 element를 더 정확하게 해준다. 에를 들어보자. &amp;lt;body&amp;gt; &amp;lt;h2&amp;gt;Title&amp;lt;/h2&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt; &amp;lt;h2&amp;gt;Another Title&amp;lt;/h2&amp;gt; &amp;lt;button&amp;gt;button&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;button&amp;gt;button&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt;만약 2개의 title이 존재하고 각각을 색상을 다르게 하고 싶다면, 일반적인 css 에서는 선택자를 조금 복잡하게 써야한다. 2개를 비교해보자. 1. CSSh2{ color: $bg;}.box h2{ color: blue;}button{ color: $bg}.box button{ color: blue;}2.SCSSh2{ color: $bg;}button{ color: $bg;}.box { h2 { color: blue; } button { color: red; }}코드의 양도 적어졌지만 가독성은 더 좋아진다. 정말 놀라운 기술이다." }, { "title": "Nomad_Coder CSS master 2.13 - min, max-content", "url": "/posts/2.13/", "categories": "CSS", "tags": "", "date": "2020-12-03 00:00:00 +0800", "snippet": "2.13. min, max-contentmin, max content는 각각의 박스가 최대한, 최소한 으로 크기를 지정할 때 쓰는 속성이다. 아래의 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; min-content &amp;lt;div class = &quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;Lorem ipsum, dolor sit amet consectetur adipisicing elit. Cupiditate, ex dolor dicta, optio possimus ipsa officia earum corporis nesciunt tempora ea quaerat, aliquid provident numquam voluptatum accusantium suscipit! Deleniti, consectetur.&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; max-content &amp;lt;div class = &quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Nisi delectus rem animi iste aperiam eius nesciunt perspiciatis adipisci? Enim architecto voluptate exercitationem ratione rem quos obcaecati minima quo non recusandae.&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.grid{ display: grid; gap: 5px; grid-auto-rows: minmax(100px, autofill); color: white;}.grid:nth-child(odd){ grid-template-columns: min-content max-content;}.item:nth-child(odd){ background-color: green;}.item:nth-child(even){ background-color: skyblue;} 결과를 보면, 가로축에 대해서 min-content는 최소한으로 줄였고, max-content는 content를 쓸 수 있을 만큼 최대로 늘린것을 알수 있다. 우리는 repeat, minmax, max, min content를 통해서 굉장한 반응형 웹 사이트를 구축할 수 있다." }, { "title": "Nomad_Coder CSS master 강좌 2.11 ~ 2.12 - minmax, auto-fit, auto-fill", "url": "/posts/2.11~2.12/", "categories": "CSS", "tags": "", "date": "2020-12-03 00:00:00 +0800", "snippet": "2.11 ~ 2.12. minmax, auto-fit, auto-fill1. minmax minmax는 element의 최소와 최대 크기를 정해준다. 아래 예제를 보자..grid{ display: grid; grid-template-columns: repeat(4, minmax(100px, 1fr)); grid-template-rows: repeat(4, 100px); grid-auto-flow: column; gap: 5px; color: white;}.item:nth-child(odd){ background-color: green;}.item:nth-child(even){ background-color: skyblue;} 현재 minmax의 뜻은 이렇다. 최소 크기는 100px, 최대 크기는 1fr로 지정해줘라 라는 뜻이다. 위의 사진은 browser의 가로 길이를 최소로 줄였을 때이다. 설정한 4줄 까지는 100px이 적용되는 모습이다. 2. auto-fit, auto-fill 이 2가지 속성은 반응형 디자인을 만들때 굉장히 많이 사용된다. auto-fit은 cell의 크기를 우선시하여 배치하고, auto-fill은 column의 개수를 우선시하여 많은 column을 만들게 해준다. 아래 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; auto-fill &amp;lt;div class = &quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; auto-fit &amp;lt;div class = &quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;item&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.grid{ display: grid; gap: 5px; grid-template-rows: repeat(auto-fill, 100px); color: white;}s.grid:nth-child(odd){ grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));}.grid:nth-child(even){ grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));}.item:nth-child(odd){ background-color: green;}.item:nth-child(even){ background-color: skyblue;} 이런식으로 auto-fill은 컬럼의 개수에 대해서, auto-fit은 item의 크기에 대해서 중점적으로 배치해준다." }, { "title": "Nomad_Coder CSS master 강좌 2.9 - Place content", "url": "/posts/2.9/", "categories": "CSS", "tags": "", "date": "2020-12-02 00:00:00 +0800", "snippet": "2.9 Place content지난 강좌에서는 셀 내부에서 어떻게 item을 위치시키는가에 대해서 배웠다. 이번에는 grid를 통채로 옮기는 방법에 대해서 배워보자. 1.justify-content justify-content는 grid의 가로를 설정하는 속성이다. 아래 예제를 봐보자..grid{ display: grid; /*grid의 가로 길이를 유심히 봐야한다.*/ background-color: black; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px); justify-content: center; gap: 5px; color: white;}.header{ background-color: aquamarine;}.content{ background-color: skyblue;}.nav{ background-color: pink;}.footer{ background-color: peru;} 그림이 좀 난해해 보이지만 요점은 이렇다. 현재 grid 너비는 100% 이고 세로는 400px이다. 그리드를 지정하면 만든 표 만큼이 영역이라고 생각 할 수도있지만 실제로는 100%를 모두 가져간다. 또한 justify-content를 통해서 grid를 통채로 가운데로 옮긴 모습이다. 이렇듯, justify-content는 grid를 통채로 어디 놓을 것인가에 대한 설정이다. value로는 space-around, space-between, space-evenly 등등 여러가지가 있다. __ 2. align-content 저번 강좌의 문맥처럼 이것 역시 세로에 대해서 grid를 통채로 옮기는 방법이다. 세로 축에 대해서 통채로 옮긴다. 세로의 경우, 높이를 조심하자. __ 3. place-contentplace-content : vertical horizontal 이다." }, { "title": "Nomad_Coder CSS master 강좌 2.8 - Place items", "url": "/posts/2.8/", "categories": "CSS", "tags": "", "date": "2020-12-02 00:00:00 +0800", "snippet": "2.8 Place items이번 강좌에서 배울 것은 justify-items과 align-items, 이 두가지 property에 대해서 배운다. 1. justify-items 이 property는 그리드 안에 있는 자식이 어떠한 형태로 있느냐를 정의한다. default 값은 stretch이다. stretch와 start 2개의 결과를 비교해보자..grid{ /*default : stretch */ display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); color: white; height: 50vh;}.grid{ display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); color: white; height: 50vh; justify-items: start}1. default 2. start 3. center 이런 식으로 cell 내부에서 자식을 어떻게 놓을지에 대해서 가로를 설정하는 속성이다. ___ 2.align-items align-items 는 수직 버전의 justify-items이다. 아래 예제를 보자..grid{ display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); color: white; justify-items: center; align-items: end; height: 50vh;} 수직으로 어떻게 놓을지에 대해서 설정하는 속성이다. 물론 default는 stretch이다. ___ place-items place-items은 위에 두개를 합친 property이다. 수직 먼저 설정하고 수평을 설정한다. 아래 예제를 보자..grid{ display: grid; grid-template-columns: repeat(4, 1fr); grid-template-rows: repeat(4, 1fr); color: white; /*place-items: vertical horizontal*/ place-items: end center; height: 50vh;} 결과 역시 같은 것을 알 수있다." }, { "title": "Nomad_Coder CSS master 강좌 2.10 - Auto columns and Rows", "url": "/posts/2.10/", "categories": "CSS", "tags": "", "date": "2020-12-02 00:00:00 +0800", "snippet": "2.10 Auto columns and Rows아래의 css 코드를 보자. 이 코드는 문제가 있다. 뭐가 문제일까?.grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px); gap: 5px; color: white;}정답은 바로, row의 개수이다. 우리는 현재 4 x 4의 table만 처리가 가능하다. 실무에서는, 우리가 얼마나 많은 data를 가져올지 모르기 때문에 당연히 data의 양이 얼마든 간에, column과 row의 크키가 유지되어야한다. 이번 강좌는 이런 속성에 대해서 배워보자. 1. grid-auto-row(column) 이 속성은 우리가 설정해 놓은 cell의 양보다 더 많은 data가 있을 경우의 크기를 정해준다. 아래코드와 사진을 보자..grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px); grid-auto-rows: 200px; gap: 5px; color: white;} 사진을 보면 4줄까지는 100px 이지만 그 이후부터는 200px의 크기를 가지는 것을 알 수있다.___ 2. grid-auto-flow 이 속성은 우리가 가지고 있는 cell의 양보다 더 많은 데이터가 들어올 때 어느 방향으로 배치할 것인가를 보여준다. 아래 예제는 위의 사진과 다르게 넘치는 데이터를 column 방향으로 보낼 것이다..grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px); grid-auto-flow: column; grid-auto-rows: 200px; gap: 5px; color: white;} 위의 사진 처럼 더 많은 데이터를 어느 방향으로 보내줄 것인가에 대한 속성이다. 화면 cell의 번호를 주목해야한다. 이제 위에서 아래 순으로 정렬이 된 것을 알 수있다." }, { "title": "Nomad_Coder CSS master 강좌 2.7 - Grid Template", "url": "/posts/2.7/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.7 Grid Template본론을 배우기 전에 fr 에 대해서 배워보자. fr은 px, % 와 같이 하나의 단위이다. fr은 특정 스페이스를 쪼개서 최대한 크게 한다. 예를 들어 가로가 1000px에 박스가 4개라면 박스의 width를 1fr로 하면 각각의 박스의 width는 250px이다. 이제 본론으로 들어가자.1. grid-template grid-template은 이제까지 우리가 배웠던 grid의 배치를 한번에 해주는 친구이다. grid-template-area와 grid-template-columns, rows 를 합한 친구라고 생각하면 된다. 아래 코드를 보자..grid{ display: grid; grid-template: &quot;header header header header&quot; 1fr &quot;nav content content content&quot; 2fr &quot;footer footer footer footer&quot; 1fr / 1fr 1fr 1fr 1fr; height: 100vh;}.header{ background-color: aquamarine; grid-area: header;}.content{ background-color: skyblue; grid-area: content;}.nav{ background-color: pink; grid-area: nav;}.footer{ background-color: peru; grid-area: footer;} gird-template을 보면, 해당 배치를 먼저 적은 다음에 row의 크기를 작은 것을 반복한뒤, 맨 마지막에 column의 크기, 개수를 적으면된다. 이때 중요한것이, fr을 사용했기 때문에 높이를 꼭 적어줘야한다. 이러면 브라우저 전체를 뒤덮는 배치가 완료된다." }, { "title": "Nomad_Coder CSS master 강좌 2.6 - Line Naming", "url": "/posts/2.6/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.6 Line Naming이번 강좌에서는 line에 이름을 붙이는 방법을 설명할 것이다. 아래 코드를 보자..grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px);}.grid{ display: grid; grid-template-columns: [first-line] 100px [second-line] 100px [third-line] 100px [fourth-line] 100px [fifth-line]; grid-template-rows: repeat(4, 100px);}저런 방식으로 line 에 이름을 지어 줄 수 있다. 물론 repeat을 통해서도 가능하다. 아래 코드를 보자..grid{ display: grid; grid-template-columns: repeat(, 100px); grid-template-rows: repeat(4, 100px, [sexy-line]);}위의 코드로 했을 경우의 문제는 라인이 4개, 첫 번째 라인이 없다는 것이다. 그래서 앞에 첫 번째 라인을 추가해줘야한다..grid{ display: grid; grid-template-columns: repeat(, 100px); grid-template-rows: [sexy-line] repeat(4, 100px, [sexy-line]);}" }, { "title": "Nomad_Coder CSS master 강좌 2.5 - Shortcuts", "url": "/posts/2.5/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.5 Shortcuts이번 강좌에서는 저번강좌의 속성들을 짧게 쓸 수 있는 방법에 대해서 말해준다. 1. grid-column, grid-row 이 2개는 start와 end를 지정해준다. 아래 코드를 보자..header{ background-color: aquamarine; grid-column-start: 1; grid-column-end: -1; grid-row-start: 1; grid-row-end: 2;}.header{ background-color: aquamarine; grid-column: 1 / -1; grid-row: 1 / 2;}2개의 코드는 같은 기능을 한다. grid-column, row는 /(슬래시)를 기준으로 앞은 start 뒤는 end를 적으면 된다. 다음 기능을 살펴보자. span함수는 범위를 지정한 만큼 가져가게 해준다. 아래 코드를 보자..content{ background-color: skyblue; grid-column: 2 / -1; grid-row: 2 / 4;}.content{ background-color: skyblue; grid-column: 2 / -1; /*start를 지정안하면 span은 시작부터 가져간다.*/ grid-row: 2 / span 2;}이제 저번 코드를 고쳐보자..grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px);}.header{ background-color: aquamarine; grid-column: 1 / -1; grid-row: 1 / 2;}.content{ background-color: skyblue; grid-column: 2 / -1; grid-row: 2 / 4;}.nav{ background-color: pink; grid-column: 1 / 2; grid-row: 2 / 4;}.footer{ background-color: peru; grid-column: 1 / -1; grid-row: -2 / -1;}" }, { "title": "Nomad_Coder CSS master 강좌 2.4 - Rows and Columns", "url": "/posts/2.4/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.4 Rows and Columns이번 시간은 grid-template-areas 로 배치했던 것을 column과 row의 숫자를 이용해서 구현해볼 것이다. 우리는 저번 시간에 header가 윗 부분을 다 차지한것처럼 각각의 box(child)에게 범위를 지정할 수 있다. 1. start, end 우리는 각각의 line 까지 범위를 늘려라~ 라고 할 수있다. 이게 무슨 말이냐면, 예를 들어 “header header header header” 가 있다고 하자, 이 경우 column 은 4개이다. 하지만 line은 5개이다. 라인 까지 넣어주면 “1 header 2 header 3 header 4 header 5” 로 구성된다. start와 end는 이 라인값이다. 예를 들어 header를 앞에 2개만 주고 싶으면 start = 1, end = 3 으로 넣어주면된다. css 코드를 살펴보자..grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px);}.header{ background-color: aquamarine; grid-column-start: 1; grid-column-end: 3;}.content{ background-color: skyblue;}.nav{ background-color: pink;}.footer{ background-color: peru;} 결과를 보면 윗부분 2칸이 header 인 것을 알 수있다. 만약 맨 마지막 라인 까지 늘리고 싶으면 end = -1 을 주면 된다. “1, 2, 3, 4, 5” 는 “-5, -4, -3, -2, -1” 이기도 하다. columns 과 마찬가지로 grid-row-start, end 속성을 이용하여 row 를 얼마나 가져갈지에 대해서도 설정할 수 있다. 아래 코드를 살펴보자..grid{ display: grid; grid-template-columns: repeat(4, 100px); grid-template-rows: repeat(4, 100px);}.header{ background-color: aquamarine; grid-column-start: 1; grid-column-end: -1; grid-row-start: 1; grid-row-end: 2;}.content{ background-color: skyblue; grid-column-start: 2; grid-column-end: -1; grid-row-start: 2; grid-row-end: 4;}.nav{ background-color: pink; grid-column-start: 1; grid-column-end: 2; grid-row-start: 2; grid-row-end: 4;}.footer{ background-color: peru; grid-column-start: 1; grid-column-end: -1; grid-row-start: -2; grid-row-end: -1;} 코드가 너무 많다. 다음에는 이 코드들을 어떻게 줄일수 있는지에 대해서 알아보자." }, { "title": "Nomad_Coder CSS master 강좌 2.3 - Grid Template Areas", "url": "/posts/2.3/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.3 Grid Template Areas이번 강좌는 grid-template-areas 속성에 대해서 알아보자. 들어가기에 앞서 html 문서와 css 문서를 조금 바꿔보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;grid&quot;&amp;gt; &amp;lt;div class=&quot;header&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;content&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;nav&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&quot;footer&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.father{ display: grid; /* repeat(반복할 갯수, 요소의 크기)*/ grid-template-columns: repeat(4, 200px); grid-template-rows: repeat(4, 200px);}.header{ background-color: aquamarine;}.content{ background-color: skyblue;}.nav{ background-color: pink;}.footer{ background-color: peru;} 현재 우리는 4 X 4의 격자무늬를 만들었다. 하지만 grid 내부의 박스의 개수가 4개밖에 없어서 모두 보이지는 않는다. grid-template-area는 grid를 통한 배치를 설게 할 때 눈으로도 보기 유용하다. 다음 코드를 보자..grid{ display: grid; grid-template-columns: repeat(4, 200px); grid-template-rows: repeat(4, 200px); /*areas 를 통해서 배치 설정 */ grid-template-areas: &quot;header header header header&quot; &quot;nav content content content&quot; &quot;nav content content content&quot; &quot;footer footer footer footer&quot;;}.header{ /*header가 html의 class : header 와 연결 시키게 설정*/ grid-area: header; background-color: aquamarine;}.content{ grid-area: content; background-color: skyblue;}.nav{ grid-area: nav; background-color: pink;}.footer{ grid-area: footer; background-color: peru;} 위의 결과물을 보면 띠용!? 할것이다. 천천히 이해해 보자. 일단 grid-template-areas는 앞서 말한대로 격자 모양대로 특정 부분을 넣을 수 있다. 하지만 이를 위해서는 grid-area라는 속성을 통해 넣는 부분의 html 식별자와 grid-template-areas 에서 쓴 변수를 매칭해줘야한다. grid-area:header 의 뜻은 grid-template-areas 안에 header 라는 부분을 grid-area:header 라는 명령어를 가지고 있는 식별자와 연결하겠다 라는 뜻이다. 따라서 .header 부분이 저렇게 4개가 연달아 붙어있는 형태가 된것이다. 빈 공간으로 쓰고 싶으면 .만 써놓으면 된다." }, { "title": "Nomad_Coder CSS master 강좌 2.2 - Grid Basic Concepts", "url": "/posts/2.2/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.2 Grid Basic Concepts이번 강좌는 Grid를 관통하는 핵심적인 개념에 대해서 배운다. grid 역시 flexbox 처럼 대부분의 배치는 Father 요소에서 결정한다. grid는 격자무늬를 만들기 때문에 표를 만드는 느낌으로 받아 들이면 된다. 표를 만들기 위해서는 row, column이 필요하다. 이것을 결정하는 속성이 grid-template-columns, grid-template-rows 이다. 이 두개의 속성을 통해 구조적으로 행과 열의 크기와 개수를 설정할 수 있다. 아래 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;father&quot;&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.father{ display: grid; grid-template-columns: 200px 150px 100px;}.child{ background-color: peru; color: white; font-size: 30px;}.child:nth-child(4){ margin-top: 10%;} grid-template-columns 는 열의 개수와 크기를 지정한다. 현재 css 코드에서는 3개의 열과 각각 200, 150, 100 px의 크기를 가지는 열을 생성한 것을 볼 수있다. 이런식으로 형과 열을 만들고 gap을 주면.father{ display: grid; grid-template-columns: 250px 250px 250px; /*column-gap : column 사이의 gap 크기 설정*/ column-gap: 10px; /*row-gap : row 사이의 gap 크기 설정*/ row-gap: 10px;}.child{ background-color: peru; color: white; font-size: 30px;} 위의 그림처럼 grid를 만들수 있다. 그러면 row길이는 조정하지 않았는데 왜 저렇게 설정 되어있을까? 이유는 바로 font-size 때문이다. 현재 row의 크기는 따로 지정되지 않았기 때문에 font-size가 더 커서 font-size의 크기 만큼 늘어나있다. 이것을 따로 설정해주기 위해서 row 크기 담당인 grid-template-rows 속성을 사용해야한다. 한 번 적용해보면,.father{ display: grid; grid-template-columns: 250px 250px 250px; /*3개의 row 설정*/ grid-template-rows: 100px 50px 300px; /*column-gap, row-gap을 합친 것*/ gap: 10px}.child{ background-color: peru; color: white; font-size: 30px;} 이렇게 row 크기가 달라진 grid를 얻을 수 있다." }, { "title": "Nomad_Coder CSS master 강좌 2.1 - Life before Grid", "url": "/posts/2.1/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "2.1 Life before Grid5개의 박스를 wrap으로 해서 배치하면 어떤 일이 일어나는지 살펴보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;father&quot;&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.father{ display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-between; width: 100%;}.child{ background-color: peru; width: 30%; height: 200px; color: white; font-size: 30px;}.child:nth-child(4){ margin-top: 10%;} space-between 같이 Main axis 축의 공백은 저렇게 알아서 분리해 주지만, cross Axis 축의 경우, 우리가 직접 하나하나 margin을 줘야 된다. 또한 5번 박스를 보면, 우리는 grid(격자 무늬) 처럼 5가 맨 끝이 아니라 가운데로 오게 하고싶다. flexbox는 박스를 정가운데로 오게하거나, 양쪽으로 보내는 건 쉬우나 이런 gird는 어렵다. 그래서 이런 layout에 필요한것이 바로 display: grid이다." }, { "title": "Nomad_Coder CSS master 강좌 1 - Index", "url": "/posts/css/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "강좌 순서1. FLEXBOX1.0 Life Before Flexbox 1.1 First Rule of Flexbox1.2 Main Axis and Cross Axis1.3 Column and Row1.4 align-self and Row1.5 wrap, nowrap, reverse, align-content1.6 flex-grow, flex-shrink1.7 flex-basis2. GRID2.1 Life Before Grid2.2 CSS Grid Basic Concepts2.3 Grid Template Area2.4 Rows and columns2.5 Shortcuts2.6 Line Naming2.7 Grid Template2.8 Place items2.9 Place content2.10 Auto columns and Rows2.11 minmax2.12 auto-fit, auto-fill2.13 min-content, max-content3. SCSS3.0 CSS Preprocessors and Set up3.1 Variables and Nesting3.2 Mixins3.3 Extends3.4 Awesome Mixins and conclusions" }, { "title": "Nomad_Coder CSS master 강좌 1.7 - flex-basis", "url": "/posts/1.7/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.7 flex-basisflex-basis도 flex-shrink, grow 처럼 child에서 적용되는 property 이다. flex-basis는 element에게 처음 크기를 주는 속성이다. 처음 크기지만 실제 크기는 아니다. grow와 shrink로 실제 크기는 늘어나거나 줄어든다." }, { "title": "Nomad_Coder CSS master 강좌 1.6 - flex-grow, flex-shrink", "url": "/posts/1.6/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.6 flex-grow, flex-shrinkflex-wrap: nowrap(한 줄 유지) 일 때, box들은 전체 너비에 맟춰서 작아지기도 한다. flex-shrink는 이 찌그러지는 것을 조절한다. defalut 값은 1이다. 아래 예제와 같이 2번 박스의 flex-shrink를 2로 주면, 1, 3번 보다 2배 더 줄어든다.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;father&quot;&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.father{ display: flex; flex-direction: row; justify-content: space-around; width: 100%; height: 100vh;}.child{ background-color: peru; width: 300px; height: 200px; color: white; font-size: 30px;}.child:nth-child(2){ background-color: black; flex-shrink: 2;} ___flex-grow은 여분 공간을 어떻게 할지에 관해서 조절한다. flex-grow의 비율에 따라 여분의 공간을 가져간다. 아래 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;father&quot;&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.father{ display: flex; flex-direction: row; justify-content: space-around; width: 100%; height: 100vh;}.child{ background-color: peru; width: 300px; height: 200px; color: white; font-size: 30px;}.child:nth-child(2){ background-color: black; flex-grow: 1;}.child:nth-child(3){ flex-grow: 1;} 이렇게 flex-grow 값이 1인 2번과 3번 박스가 여분의 공간을 각자 나눠가진다. 나눠가지는 비율이 flex-grow 값이다." }, { "title": "Nomad_Coder CSS master 강좌 1.5 - wrap, nowrap, align-content, reverse", "url": "/posts/1.5/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.5 wrap, nowrap, align-content, reverse1. wrap, nowrap 시작하기에 앞서 다음 예제를 살펴보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;father&quot;&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;1&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;2&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;3&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;4&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;5&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;child&quot;&amp;gt;6&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.father{ display: flex; flex-direction: row; justify-content: space-around; align-items: flex-start; height: 100vh;}.child{ background-color: blue; width: 200px; height: 200px; color: white; font-size: 30px;} 결과물을 보면 width, height은 200px 이지만, width가 찌그러진것을 알 수있다. flexbox는 item들이 모두 같은 줄에 있도록 유지한다. 너비를 바꾸는 한이 있더라도 같은 줄에 있도록 한다. 이걸 건드리는 속성이 flex-wrap이다. flex-wrap의 default는 nowrap으로 위의 결과와 같이 모든 박스들을 한 줄로 유지해준다. flex-wrap: wrap을 하면 이렇게 box들의 크기를 우선시하면서 한줄 묶기를 하지 않는다. ___ 2. reverse reverse는 박스의 layout 순서를 역순으로 한다. 2가지 방식이 있는데, flex-direction: row-reverse or column-reverse flex-wrap: nowrap-reverse or wrap-reverse이 2가지 방식을 이용하여 역순으로 배치할 수 있다. 물론 이 두가지 방식도 각각 정렬의 결과가 다르니 직접 해보길 바란다. ___3. align-content 아래 그림을 보자. 현재 4각형으로 된 저 공백부분을 조절할 수있는 방법도 있다. 바로 align-content라는 속성이다. 바로 위의 예제는 align-items의 속성이 들어가있지 않았다. 그럼 어떻게 세로로 layout 된 것일까? align-items는 father의 layout을 바꾼다면, align-content는 box 줄 마다의 배치를 바꾼다. 예를 들어 align-content가 center이면, 위의 박스들과 아래 박스들 사이의 공백은 사라진다. default는 space-around 이다..father{ display: flex; flex-direction: row; flex-wrap: wrap; justify-content: space-around; align-content: center; height: 100vh;}.child{ background-color: blue; width: 200px; height: 200px; color: white; font-size: 30px;}" }, { "title": "Nomad_Coder CSS master 강좌 1.3 - Columns and Rows", "url": "/posts/1.3/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.3 Columns and Rows이번 수업은 저번 시간의 연장선이다. 이번에는 Main Axis가 세로로 되게 해보았다. 아래 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;wrapper&quot;&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.wrapper{ display: flex; flex-direction: column; justify-content: space-around; align-items: center; height: 100vh;}.box{ background-color: blue; width: 200px; height: 200px;} flex-direction을 column 으로 한 결과이다. 천천히 보면 이해가 될 것이다." }, { "title": "Nomad_Coder CSS master 강좌 1.2 - Main Axis and Cross Axis", "url": "/posts/1.2/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.2 Main Axis and Cross Axis이번 강좌는 Flexbox Layout에 가장 중요한 방향에 대해서 배운다. 1. Flex-direction flex-direction은 flexbox의 방향을 잡아주는 속성이다. default는 row로, 가로방향이다. 그렇다면 세로 방향은 뭘까? 바로 column 이다. 이제 수평으로 된 box의 위치를 바꿔보자. 어제 예제 까지의 box들은 모두 붙어 있는 상태 지만 justify-content라는 속성을 통해서 box들의 수평 layout을 바꿀 수 있다. 아래 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;wrapper&quot;&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.wrapper{ display: flex; justify-self: center;}.box{ background-color: blue; width: 200px; height: 200px;}justify-content : center 라는 명령어를 통해서 박스들이 가운데로 위치하였다. 이 밖에도 space-between, space-around 등 많은 layout이 있으니 직접 해보길 바란다. ___2. Main Axis and Cross Axis Flexbox는 2개의 방향을 가진다. Main Axis 와 Cross Axis이다. Main Axis는 우리가 아까 말했던 flex-direction 속성으로 방향을 정하면 된다. Cross Axis는 Main Axis와 90도 관계의 방향을 말한다. default의 경우, flex-direction : row 이기 때문에 M은 수평, C는 수직방향이다. 아래 그림을 보면 더 잘 이해될 것이다. ___3. align-items Cross Axis 방향으로 item들(box들)을 옮겨주는 속성이 바로 align-items 이다. Main Axis 방향은 우리가 아까 말했던 것처럼, justify-content 속성이 해준다. 아래 예제를 봐 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;wrapper&quot;&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.wrapper{ display: flex; justify-content: space-around; align-items: center; height: 100vh;}.box{ background-color: blue; width: 200px; height: 200px;}주의 해야할 것은 높이이다. 높이를 따로 정해주지 않으면 박스의 세로길이가 wrapper의 세로 길이이기 때문에 가운데 정렬을 해도 똑같이 보이게 된다." }, { "title": "Nomad_Coder CSS master 강좌 1.1 - First Rule Of Flexbox", "url": "/posts/1.1/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.1 First Rule of Flexbox이번 강좌에서는 Flexbox를 관통하는 몇가지의 필수 개념에 대해서 말한다. 1. Flexbox는 Children과 이야기하지 않는다 저번 예제에서는 직접 box를 일일이 지정하여 움직임을 배치했다(nth-child). 허나 flexbox에서는 이 box들을 가지고 있는 flexbox container를 생성하여 container에게 명령을 전달해야한다. 즉, box 배치는 box를 직접 건드리지 않고 한다. 아래 예제를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;body{ display: flex;}.box{ background-color: blue; width: 200px; height: 200px; display: inline-block;} 결과물을 보면 line 없이 가로, 세로 크기가 200px인 박스 3개가 합쳐져 있는 모습을 볼 수있다. flex-container는 자식에 직접 붙어있는 직계 부모여야한다. 이 부모가 box들의 layout을 담당한다." }, { "title": "Nomad_Coder CSS master 강좌 1.0 - Life Before Flexbox", "url": "/posts/1.0/", "categories": "CSS", "tags": "", "date": "2020-11-30 00:00:00 +0800", "snippet": "1.0 Life Before Flexbox이번 강좌에서는 Flexbox를 배우기 전에 왜 Flexbox가 필요한지, 또한 몇가지의 position 에 관해서 배운다. 먼저 display 속성 중에 block, inline, inline-block에 대해서 알아보자. block : 가로열 전체를 구역으로 삼으며 특정 area를 가져간다. inline : inline은 box가 아닌 element 이다. 즉, width, heigth로 가로, 세로 길이를 조절할 수 없으며 특정 element를 안에 넣어서 크기를 부풀릴수 있다. inline-block : inline 처럼 특정 가로열의 왼쪽으로도 옮길 수 있지만 box를 가질 수 있다.inline-block의 문제점 아래의 html, css 코드를 보자.&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt; &amp;lt;link rel = &quot;stylesheet&quot; href = &quot;style.css&quot;&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class = &quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;.box{ background-color: blue; width: 300px; height: 300px; display: inline-block;}이 경우에 box 들은 가로 세로 300px의 크기로 margin 없이 가로 정렬이 될 것이라고 생각하겠지만, 결과물을 보면 다음과 같이 margin 이 존재하는 것을 볼 수있다. 이런 문제를 해결하기 위해서 Flexbox가 태어났다." }, { "title": "프로그래머스 level 2 : 타겟넘버", "url": "/posts/%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84/", "categories": "programmers", "tags": "", "date": "2020-11-28 00:00:00 +0800", "snippet": "문제 : 타겟 넘버링크 이 문제는 dfs를 이용할 수 있는가에 대해서 물어보는 문제였다. 주어진 배열을 반복문 혹은 재귀를 이용하여 구현하면된다. 필자는 모두 더한 것들을 정답에 넣어놓고 count를 통해서 구했다.def dfs(x, count, target, answer, numbers): if count == target: answer.append(x) return answer dfs(x + numbers[count], count + 1, target, answer, numbers) dfs(x - numbers[count], count + 1, target, answer, numbers)def solution(numbers, target): answer = [] l = len(numbers) dfs(numbers[0], 1, l, answer, numbers) dfs(-numbers[0], 1, l, answer, numbers) return answer.count(target)Best answer알고리즘은 똑같으나 구현 방식이 너무 멋져서 공유한다.def solution(numbers, target): if not numbers and target == 0 : return 1 elif not numbers: return 0 else: return solution(numbers[1:], target-numbers[0]) + solution(numbers[1:], target+numbers[0])" }, { "title": "프로그래머스 Level 2 : 카펫", "url": "/posts/%EC%B9%B4%ED%8E%AB/", "categories": "programmers", "tags": "", "date": "2020-11-28 00:00:00 +0800", "snippet": "문제 : 카펫링크 이 문제는 노란색의 약수를 구하고 이에 대해 갈색의 카펫수를 찾으면서 진행하면된다.def solution(brown, yellow): # 약수 구하기 measure = [] for i in range(yellow, 0, -1): if yellow % i == 0: h = i v = yellow // i if h &amp;gt;= v: measure.append([h, v]) else: break # 약수를 기준으로 갈색 산출 for h, v in measure: if brown == (h + 2) * (v + 2) - h * v: return [h + 2, v + 2]" }, { "title": "프로그래머스 Level 2 : 위장", "url": "/posts/%EC%9C%84%EC%9E%A5/", "categories": "programmers", "tags": "", "date": "2020-11-28 00:00:00 +0800", "snippet": "문제 : 위장링크 이 문제는 주어진 옷들을 해시를 이용하여 구성한 뒤 각각의 옷을 조합하는 개수를 카운트 해야한다. 하지만 가장 중요한 건 수학적 지식이다. [a, b, c] 가 있다고 하자. 이들을 모두 조합하는 방법의 수는 (a + b + c) + (ab + bc + ca) + abc 이다. 만약 a, b, c 가 아닌 a ~ z 까지라면 이거 구현하는거 꽤 귀찮아진다. 필자도 여기서 막혔다. 문제를 해결하는 아이디어는 (a + 1)(b + 1)(c + 1) - 1 = (a + b + c) + (ab + bc + ca) + abc 라는 공식이다. 이를 이용하면 문제를 쉽게 풀 수있다.# velog 의 코드입니다.def solution(clothes): answer = {} for i in clothes: if i[1] in answer: answer[i[1]] += 1 else: answer[i[1]] = 1 cnt = 1 for i in answer.values(): cnt *= (i+1) return cnt - 1" }, { "title": "프로그래머스 Level 2 : 구명보트", "url": "/posts/%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/", "categories": "programmers", "tags": "", "date": "2020-11-28 00:00:00 +0800", "snippet": "문제 : 구명보트링크이 문제는 최대 2명을 태운다는 점에 중점을 뒤서 문제를 풀어야 한다. 예를 들어 구명보트(버티는 무게 : 100kg)에 [10, 20, 30, 80, 85, 90]의 무게를 가진 사람들을 탑승시킨다고 하자. 이 경우 가장 앞에 값과 가장 뒤에 값을 더한 것을 구명 보트의 무게와 비교하여 더 작으면 정답에서 1을 빼고(초기 정답 : 사람의 수) 가장 앞에 변수를 1올리고 뒤에 변수를 1 감소시키는 방식으로 진행하면 된다.def solution(people, limit): answer = len(people) people.sort() # 앞과 뒤를 나타내주는 변수 first, last = 0, len(people) - 1 while first &amp;lt; last: # 앞의 변수와 뒤의 변수의 더한 값이 limit 보다 작으면 2명이 탄것이기 때문에 정답에서 1을 빼고 first(가장 앞의 변수)를 + 1 if people[first] + people[last] &amp;lt;= limit: answer -= 1 first += 1 # limit 보다 클 경우 or 작을 경우 둘다 last는 앞으로 1칸씩 당겨야됨 last -= 1 return answer " }, { "title": "chapter 18 : 실전 그래프 이론 45번 문제(최종 순위)", "url": "/posts/chapter18-q-45/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-12 00:00:00 +0800", "snippet": "문제 : 최종 순위문제 링크책 해답위상정렬을 사용해서 문제를 풀어야 하는 것은 알았으나 실제 구현은 하지도 못한 채 광탈 당하여 내 생각은 건너 뛰고 바로 책 해답으로 들어가겠다.작년의 순위 정보가 주어지면, ‘자기보다 낮은 등수를 가진 팀을 가리키도록’ 방향 그래프를 만들 수 있다. 만약에 이대로 위상정렬을 수행하게 되면, 수행 결과는 5-4-3-2-1이 된다. 즉, 문제에서 제시한 순위 정보와 동일하게 나온다. 다른 경우는 존재하지 않는다.이제 상대적인 순위가 바뀌게 되는 경우에는, 해당 간선의 방향을 반대로 변경하면 된다. 이후에 이 상태에서 위상 정렬을 다시 수행하면 된다. 위상 정렬은 2가지 특이 케이스가 존재한다. 1. 사이클이 존재하는 경우, 2. 위상 정렬의 결과가 1개가 아니라 여러가지인 경우이다. 이 2가지 경우에 해당하지 않는 다면 위상정렬을 수행한 결과는 ‘오직 하나의 경우’만 존재하게 된다. 즉, 가능한 순위가 하나라는 의미가 된다.따라서 변경된 상대적인 순위를 적용한 이후에, 위상 정렬 알고리즘을 실행하면서 사이클이 발생하는지, 혹은 결과가 여러가지인지 확인하면된다. 일반적인 위상 정렬의 경우, 정확히 N개의 노드가 큐에서 출력이된다.만약 노드가 N번 나오기 전에 큐가 비게 빈다면, 사이클이 발생한 것으로 이해 할 수 있다. 또한 특정 시점에 2개 이상의 노드가 큐에 한꺼번에 들어갈 때는, 가능한 정렬 결과가 여러 가지라는 의미가 된다. 그러므로 위상정렬 수행과정에서 큐에서 노드를 뽑을 때 큐의 원소가 항상 1개로 유지되는 경우에만 고유한 순위가 존재하는 것으로 이해할 수 있다.# 최종순위from collections import deque# 테스트 케이스(Test Case)만큼 반복for tc in range(int(input())): # 노드의 개수 n = int(input()) # 모든 노드에 대해서 진입차수 0으로 초기화 indegree = [0] * (n + 1) # 각 노드의 연결된 간선 정보를 담기 위한 인접 행렬 초기화 graph = [[False] * (n + 1) for _ in range(n + 1)] # 작년 순위 정보 입력 data = list(map(int, input().split())) # 방향 그래프의 간선 정보 초기화 for i in range(n): for j in range(i + 1, n): graph[data[i]][data[j]] = True indegree[data[j]] += 1 # 올해 변경된 순위 정보 입력 m = int(input()) for i in range(m): a, b = map(int, input().split()) # 간선의 방향 뒤집기 if graph[a][b]: graph[a][b] = False graph[b][a] = True indegree[a] += 1 indegree[b] -= 1 else: graph[a][b] = True graph[b][a] = False indegree[a] -= 1 indegree[b] += 1 # 위상 정렬 시작 result = [] # 알고리즘 수행 결과를 담을 리스트 q = deque() # 큐 기능을 위한 deque for i in range(1, n + 1): if indegree[i] == 0: q.append(i) certain = False # 위상 정렬 결과가 오직 하나인지의 여부 cycle = False # 그래프 내 사이클이 존재하는지 여부 # 정확히 노드의 개수만큼 반복 for i in range(n): # 큐가 발생했으면 사이클이 발생했다는 의미 if len(q) == 0: cycle = True break # 큐의 원소가 2개 이상이라면 가능한 정렬 결과가 여러 개라는 의미 if len(q) &amp;gt;= 2: certain = False break now = q.popleft() result.append(now) for i in range(1, n + 1): if graph[now][i]: indegree[i] -= 1 if indegree[i] == 0: q.append(i) if cycle: print(&quot;IMPOSSIBLE&quot;) elif certain: print(&quot;?&quot;) else: for i in result: print(i, end = &quot; &quot;) print()" }, { "title": "chapter 18 : 실전 그래프 이론 44번 문제(행성 터널)", "url": "/posts/chapter18-q-44/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-12 00:00:00 +0800", "snippet": "문제 : 행성 터널문제 링크내 생각문제에서 간선에 드는 비용이 나오지 않았기 때문에 비용에 대해서 먼저 풀어낼 필요가 있었다. 입력값을 itertools의 combinations을 이용하여 2개의 좌표에 대한 거리를 모두 구한 후에, 거리순으로 정렬, 크루스칼 알고리즘을 사용하여 문제를 풀어냈다.from itertools import combinationsdef union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a &amp;lt; b: parent[b] = a else: parent[a] = bdef find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x]n = int(input())data = []edges = []parent = [0] * nresult = 0for i in range(n): parent[i] = ifor i in range(n): x, y, z = map(int, input().split()) data.append((x, y, z, i))# one = [x, y, z, i]for one, two in combinations(data, 2): cost = min(abs(one[0] - two[0]), abs(one[1] - two[1]), abs(one[2] - two[2])) edges.append((cost, one[3], two[3]))edges.sort()for edge in edges: _cost, _a, _b = edge if find_parent(parent, _a) != find_parent(parent, _b): union_parent(parent, _a, _b) result += _cost else: continueprint(result)책 해답위의 방법의 경우 간선 2개를 구하는 조합 식이 N(N - 1) / 2 이므로 n이 100000 일 경우는 굉장히 속도적으로 느리다. 그러니 다른방식의 접근을 생각해봐야한다.이 문제의 힌트는 바로 비용에 관한 부분이다. x, y, z 각각에 대한 비용의 최솟값이므로 x, y, z 의 비용만 계산하면 3(N - 1) 의 연산량을 가지게 된다.from itertools import combinationsdef union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a &amp;lt; b: parent[b] = a else: parent[a] = bdef find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x]n = int(input())data = []edges = []parent = [0] * nresult = 0for i in range(n): parent[i] = ix = []y = []z = []for i in range(n): _x, _y, _z = map(int, input().split()) x.append((_x, i)) y.append((_y, i)) z.append((_z, i))x.sort()y.sort()z.sort()# one = [x, y, z, i]for one, two in combinations(data, 2): cost = min(abs(one[0] - two[0]), abs(one[1] - two[1]), abs(one[2] - two[2])) edges.append((cost, one[3], two[3]))edges.sort()for i in range(n - 1): edges.append((x[i + 1][0] -x[i][0], x[i][1], x[i + 1][1])) edges.append((y[i + 1][0] -y[i][0], y[i][1], y[i + 1][1])) edges.append((z[i + 1][0] -z[i][0], z[i][1], z[i + 1][1]))edges.sort()for edge in edges: _cost, _a, _b = edge if find_parent(parent, _a) != find_parent(parent, _b): union_parent(parent, _a, _b) result += _costprint(result)" }, { "title": "chapter 18 : 실전 그래프 이론 43번 문제(어두운 길)", "url": "/posts/chapter18-q-43/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-12 00:00:00 +0800", "snippet": "문제 : 어두운 길한 마을은 N개의 집과 M개의 도로로 구성되어 있습니다. 각 집은 0번부터 N - 1번 까지의 번호로 구분됩니다. 모든 도로에는 가로등이 구비되어 있는데, 특정한 도로의 가로등을 하루 동안 켜기 위한 비용은 해당 도로의 길이와 동일합니다.정부에서는 일부 가로등을 비활성화하되, 마을에 있는 임의의 두 집에 대하여 가로등이 켜진 도로만으로도 오갈 수 있도록 만들고자 합니다. 결과적으로 일부 가로등을 비활성화 하여 최대한 많은 금액을 절약하고 자합니다. 마을의 집과 도로정보가 주어졌을 때, 일부 가로등을 비활성화하여 절약할 수 있는 최대 금액을 출력하는 프로그램을 작성하세요.내 생각이 문제는 전형적인 크루스칼 알고리즘을 묻는 문제이다. 간선에 대하여 낮은 순으로 정리한 뒤, 순환이 일어나지 않으면 결과값에 저장하면 된다.def union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a &amp;lt; b: parent[b] = a else: parent[a] = bdef find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x]n, m = map(int, input().split())parent = [0] * nedges = []max_value = 0result = 0for i in range(n): parent[i] = ifor _ in range(m): a, b, cost = map(int ,input().split()) edges.append((cost, a, b)) max_value += costedges.sort()for edge in edges: _cost, _a, _b = edge if find_parent(parent, _a) != find_parent(parent, _b): union_parent(parent, _a, _b) result += _cost else: continueprint(max_value - result)" }, { "title": "chapter 18 : 실전 그래프 이론 42번 문제(탑승구)", "url": "/posts/chapter18-q-42/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-11 00:00:00 +0800", "snippet": "문제 : 탑승구공항에는 G개의 탑승구가 있으며, 각각의 탑승구는 1번부터 G번까지의 번호로 구분됩니다. 공항에는 P개의 비행기가 차례대로 도착ㄹ할 예정이며, i번째 비행기를 1번부터 g_i번째 탑승구 중 하나에 영구적으로 도킹해야합니다. 이때, 다른 비행기가 도킹하지 않은 탑승구에만 도킹할 수 있습니다.또한 P개의 비행기를 순서대로 도킹하다가 만약에 어떠한 탑승구에도 도킹할 수 없는 비행기가 나오는 경우, 그 시점에서 공항의 운행을 중지합니다. 공항의 관리자는 최대한 많은 비행기를 공항에 도킹하고자 합니다. 최대 몇 대 도킹할 수 있는지 출력하는 프로그램을 작성하세요.내 생각도킹 되는 비행기를 가장 큰 값에 게이트 부터 아래로 내려가면서 도킹이 가능한지 보고, 도킹이 된다면 도킹을 시키면서 count를 증가시킨다. 만약 그게 아니라면 공항의 운행을 중지하고 count 값을 출력한다.# g : 게이트의 개수, p : 비행기의 개수g = int(input())p = int(input())docs = [0] * (g + 1)answer = 0breaker = Falsefor i in range(p): plane = int(input()) for i in range(plane, 0, -1): if i == 1 and docs[i] == 1: breaker = True break if docs[i] == 0: docs[i] = 1 answer += 1 break if breaker: breakprint(answer)책 해답이 문제는 도킹하는 과정을 합연산을 통해서 하면된다. 전체 탑승구가 4개라고 할 때, 문제해결을 위해 0 ~ 4번의 5개의 탑승구를 만든다고 하자. 이때 비행기가 들어오면 도킹을 수행해야하는데, 가능한 큰 번호의 탑승구로 도킹을 수행한다고 가정해보자. 이때 우리는 도킹하는 과정을 탑승구 간 합집합 연산으로 이해할 수 있다. 새롭게 비행기가 도킹이 되면, 해당 집합을 바로 왼쪽에 있는 집합과 합친다. 단, 집합의 루트노드가 0이면, 더 이상 도킹이 불가능 한것으로 판단한다.def union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a &amp;lt; b: parent[b] = a else: parent[a] = bdef find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x]g = int(input())p = int(input())parent = [0] * (g + 1)count = 0for i in range(1, g + 1): parent[i]= ifor _ in range(p): data = find_parent(parent, int(input())) if data: count += 1 union_parent(parent, data, data - 1) else: breakprint(count)" }, { "title": "chapter 18 : 실전 그래프 이론 41번 문제(여행 계획)", "url": "/posts/chapter18-q-41/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-11 00:00:00 +0800", "snippet": "문제 : 여행 계획한올이가 사는 나라에는 N개의 여행지가 있으며, 각 여행자는 1 ~ N번까지의 번호로 구분됩니다. 또한 임의의 두 여행지 사이에는 두 여행지를 연결하는 도로가 존재할 수 있습니다. 이때, 여행자가 도로로 연결되어 있다면 양방향으로 이동이 가능하다는 의미 입니다.한울이는 하나의 여행 계획을 세운 뒤에 이 여행 계획이 간으한지의 여부를 판단하고자 합니다. 예를 들어 N = 5이고, 다음과 같이 도로의 정보가 주어졌다고 가정합시다. 1번 - 2번 1번 - 4번 1번 - 5번 2번 - 3번 2번 - 4번만약 한울이의 여행계획이 2-3-4-3이라고 하면, 이 경우 2번 -&amp;gt; 3번 -&amp;gt; 2번 -&amp;gt; 4번 -&amp;gt; 2번 -&amp;gt; 3번의 순으로 여행이 가능합니다. 여행지의 개수와 여행지 간의 연결 정보가 주어졌을 때, 한울이의 여행 계획이 가능한지의 여부를 판별하는 프로그램을 작성하세요.내 생각여행지 간의 연결 정보를 입력 받으면서 해당 노드들을 서로소 연산을 해주어 같은 집합으로 만든 뒤, 한울이의 여행 계획을 통해서 다른 집합이면 NO를 출력하게 했다.def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x]def union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a &amp;lt; b: parent[b] = a else: parent[a] = bn, m = map(int, input().split())# 서로소 연산을 위한 루트노드 리스트 생성parent = [0] * (n + 1)# 루트 노드 설정for i in range(1, n + 1): parent[i] = ifor i in range(1, n + 1): data = list(map(int, input().split())) for j in range(1, n): if data[j - 1]: union_parent(parent, i, j)plan = list(map(int, input().split()))result = Truefor i in range(len(plan)): if i == len(plan) - 1: break if parent[plan[i]] != parent[plan[i + 1]]: result = Falseprint(parent)if result: print(&quot;YES&quot;)else: print(&quot;NO&quot;)책 해답알고리즘은 위의 내 생각과 동일하다.def find_parent(parent, x): if parent[x] != x: parent[x] = find_parent(parent, parent[x]) return parent[x]def union_parent(parent, a, b): a = find_parent(parent, a) b = find_parent(parent, b) if a &amp;lt; b: parent[b] = a else: parent[a] = bn, m = map(int, input().split())# 서로소 연산을 위한 루트노드 리스트 생성parent = [0] * (n + 1)# 루트 노드 설정for i in range(1, n + 1): parent[i] = ifor i in range(n): data = list(map(int, input().split())) for j in range(n): if data[j]: union_parent(parent, i + 1, j + 1)plan = list(map(int, input().split()))result = Truefor i in range(m - 1): if find_parent(parent, plan[i]) != find_parent(parent, plan[i + 1]): result = Falseprint(parent)if result: print(&quot;YES&quot;)else: print(&quot;NO&quot;)" }, { "title": "chapter 17 : 실전 최단 경로 40번 문제(숨바꼭질)", "url": "/posts/chapter17-q-40/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-08 00:00:00 +0800", "snippet": "문제 : 숨바꼭질동빈이는 숨바꼭질을 하면서 술래로부터 잡히지 않도록 숨을 곳을 찾고 있습니다. 동빈이는 1 ~ N번까지의 헛간 중에서 하나를 골라 숨을 수 있으며, 술래는 항상 1번 헛간에서 출발합니다. 전체 맵에는 총 M개의 양방향 통로가 존재하며, 하나의 통로는 서로 다른 두 헛간을 연결합니다. 또한 전체 맵은 항상 어떤 헛간에서 다른 어떤 헛간으로 도달이 가능한 형태로 주어집니다.동빈이는 1번 헛간으로부터 최단거리가 가장 먼 헛간이 가장 안전하다고 판단하고 있습니다. 이때 최단 거리의 의미는 지나야 하는 길의 개수를 의미합니다. 동빈이가 숨을 헛간의 번호를 출력하는 프로글매을 작성하세요.입력조건 첫째 줄에는 N과 M이 주어지며, 공백으로 구분합니다. 이후 M 개의 줄에 걸쳐서 서로 연결된 두 헛간 A와 B의 번호가 공백으로 구분되어 주어집니다.출력 조건첫 번쨰는 숨어야 하는 헛간 번호를(만약 거리가 같은 헛간이 여러 개면 가장 작은 번호를 출력), 두 번째는 그 헛간까지의 거리를, 세 번째는 그 헛간과 같은 거리를 갖는 헛간의 개수를 출력해야합니다.내 생각다익스트라 알고리즘을 무방향 그래프에 적용하면된다.import heapqINF = int(1e9)n, m = map(int, input().split())# linkedgraph 와 거리 정보를 담을 distance 선언graph = [[] for _ in range(n + 1)]distance = [INF] * (n + 1)# 양방향 그래프(무방향 그래프)for _ in range(m): a, b = map(int, input().split()) graph[a].append((b, 1)) graph[b].append((a, 1))# 다익스트라 알고리즘def djikstra(): q = [] distance[1] = 0 # 거리, 노드 순으로 q에 담음(최소거리 큐) heapq.heappush(q, (0, 1)) while q: dist, now = heapq.heappop(q) if dist &amp;gt; distance[now]: continue for i in graph[now]: # cost : now 까지의 거리 + 해당 노드의 거리 cost = dist + i[1] if cost &amp;lt; distance[i[0]]: distance[i[0]] = cost heapq.heappush(q, (cost, i[0]))djikstra()# 0 번쨰 인덱스의 INF 제거 후 max값 도출max_value = max(distance[1:])print(distance.index(max_value), max_value, distance.count(max_value))" }, { "title": "chapter 17 : 실전 최단 경로 39번 문제(화성 탐사)", "url": "/posts/chapter17-q-39/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-08 00:00:00 +0800", "snippet": "문제 : 화성 탐사내 생각이 문제는 arraylist 의 형태로 나타낸 그래프를 이용하여 dijkstra 알고리즘을 구현하는 문제이다. bfs, dfs와 같아 4가지 방향으로 이동하며 최소 거리를 계속해서 갱신하면 된다.import heapqINF = int(1e9)t = int(input())dx, dy = [0, 0, -1, 1], [-1, 1, 0, 0]def dijkstra(graph): q = [] distance[0][0] = graph[0][0] heapq.heappush(q, (distance[0][0], 0, 0)) while q: dist, x, y = heapq.heappop(q) # dist가 최단거리가 아니면 필요없으니 거름 if distance[x][y] &amp;lt; dist: continue # 4방향으로 이동 for i in range(4): nx, ny = x + dx[i], y + dy[i] if nx &amp;lt; 0 or ny &amp;lt; 0 or nx &amp;gt;= n or ny &amp;gt;= n: continue cost = dist + graph[nx][ny] if cost &amp;lt; distance[nx][ny]: distance[nx][ny] = cost heapq.heappush(q, (cost, nx, ny))while t &amp;gt; 0: n = int(input()) # 그래프와, 최단거리 테이블 생성 graph = [list(map(int, input().split())) for _ in range(n)] distance = [[INF] * n for _ in range(n)] dijkstra(graph) print(distance[n - 1][n - 1]) t -= 1" }, { "title": "chapter 17 : 실전 최단 경로 37번 문제", "url": "/posts/chapter17-q-37/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-07 00:00:00 +0800", "snippet": "문제 : 플로이드문제 링크내 생각플로이드 알고리즘을 알고 있는가를 묻는 문제이다. 플로이드 알고리즘을 그대로 구현하여 정답으로 제시하면 된다. 주의할 점은 입력시, 같은 출발과 도착에 해당하는 내용에 입력이 중복되기 때문에 그 부분을 값을 최소인 것으로 할당 해야한다.INF = int(1e9)# n : 도시의 개수, m : 간선의 개수n = int(input())m = int(input())# 그래프 초기화graph = [[INF] * (n + 1) for _ in range(n + 1)]# 자기 자신에서 자신으로 오는 것 = 0for i in range(1, n + 1): for j in range(1, n + 1): if i == j: graph[i][j] = 0# 간선 입력for _ in range(m): x, y, z = map(int, input().split()) if graph[x][y] &amp;gt; z: graph[x][y] = z# 플로이드-워셜 알고리즘for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])#for i in range(1, n + 1): for j in range(1, n + 1): if graph[i][j] == INF: print(0, end = &quot; &quot;) else: print(graph[i][j], end = &quot; &quot;) print()" }, { "title": "chapter 17 : 실전 DP 38번 문제(성적)", "url": "/posts/chapter17-q-38/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-06 00:00:00 +0800", "snippet": "문제 : 성적내 생각플로이드 워셜 알고리즘을 이용하여 각각의 최소 거리를 계산한후, 최소거리가 존재하면 dist의 값을 1씩 올리는 방식으로 진행했다. 그 이후 dist의 원소 중, n과 같은 값의 개수를 출력했다.n, m = map(int, input().split())graph = [[1e9] * (n + 1) for _ in range(n + 1)]dist = [0] * (n + 1)for i in range(1, n + 1): for j in range(1, n + 1): if i == j: graph[i][j] = 0for _ in range(m): a, b = map(int, input().split()) graph[a][b] = 1for k in range(1, n + 1): for i in range(1, n + 1): for j in range(1, n + 1): graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])# 각 노드는 나가거나 들어오는 화살표 밖에 없다for i in range(1, n + 1): for j in range(1, n + 1): if graph[i][j] != 1e9 or graph[j][i] != 1e9: dist[i] += 1count = 0for i in dist: if i == n: count += 1print(count)" }, { "title": "chapter 16 : 실전 DP 36번 문제(편집 거리)", "url": "/posts/chapter16-q-36/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-06 00:00:00 +0800", "snippet": "문제 : 알고리즘책 해답이 문제는 최소 편집거리를 담을 2차원 테이블을 초기화한 뒤에, 최소 편집 거리를 계산해 테이블에 저장하는 과정으로 문제를 해결할 수 있다. 다이나믹 프로그래밍 점화식은 다음과 같다. 두 문자가 같은 경우 : dp[i][j] = dp[i - 1][j - 1] 두 문자가 다른 경우 : dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])이에 대한 설명은 링크를 참고하자.def edit_dist(str1, str2): n = len(str1) m = len(str2) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): dp[i][0] = i for j in range(1, m + 1): dp[0][j] = j for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) return dp[n][m]str1 = input()str2 = input()print(edit_dist(str1, str2))" }, { "title": "chapter 16 : 실전 DP 35번 문제(못생긴 수)", "url": "/posts/chapter16-q-35/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-06 00:00:00 +0800", "snippet": "문제 : 못생긴 수못생긴 수란 오직 2, 3, 5만을 소인수로 가지는 수를 의미합니다. 다시말해 오직 2, 3, 5를 약수로 가지는 합성수를 의미합니다. 1은 못생긴 수라고 가정합니다. 이때 n번쨰 못생긴 수를 찾는 프로그램을 작성하세요.책 해답이 문제는 가능한 못생긴 수를 앞에서부터 하나씩 찾는 방법으로 해결할 수 있다. 못생긴 수들은 {1,2,3,4,5,6,8,9, …} 와 같이 끊임없이 존재한다. 이때 못생긴 수에 2, 3, 5를 곱한 수 또한 ‘못생긴 수’에 해당한다는 점이 포인트이다.그러니 우리가 할 일은 이 못생긴 수에 2, 3, 5를 곱한 것 중 가장 작은것을 계속해서 갱신하면된다.n = int(input())ugly = [0] * nugly[0] = 1# 2배, 3배를 위한 인덱스i2 = i3 = i5 = 0# 처음의 곱셈값next2, next3, next5 = 2, 3, 5for i in range(1, n): ugly[i] = min(next2, next3, next5) if ugly[i] == next2: i2 += 1 next2 = ugly[i2] * 2 if ugly[i] == next3: i3 += 1 next3 = ugly[i3] * 3 if ugly[i] == next5: i5 += 1 next5 = ugly[i5] * 5print(ugly[n - 1])" }, { "title": "chapter 16 : 실전 DP 34번 문제(병사 배치하기)", "url": "/posts/chapter16-q-34/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-05 00:00:00 +0800", "snippet": "문제 : 병사 배치하기문제 링크내 생각일단 틀렸다.. 어느 정도 점화식에 접근하는 생각에 이르긴 했으나, 결국은 풀지 못했다. max(dp[j], dp[i + 1]) 라는 점화식을 통해서 문제를 해결하려 했으나 결국 실패했다.# 틀린 코드다n = int(input())d = list(map(int, input().split()))dp = [0] * ndp[n - 1] = 1# 뒤에서 부터for i in range(n - 2, -1, -1): if d[i] &amp;lt; d[i + 1]: for j in range(i + 1, n): if d[i] &amp;gt; d[j]: dp[i] = max(dp[j] + 1, dp[i + 1]) continue else: dp[i] = dp[i + 1] + 1print(n - dp[0])책 해답이 문제의 기본 아이디어는 ‘가장 긴 증가하는 부분 수열’ 로 알려진 전형적인 다이나믹 프로그래밍 문제의 아이디어와 같다. 예를 들어 하나의 수열 array = {10, 20, 10, 30, 20, 50} 이 있다고 하자. 이때 가장 긴 증가하는 부분 수열은 {10, 20, 30, 50} 이 될 것이다. D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이 라고 정의하면, 가장 긴 증가하는 부분 수열을 계산하는 점화식은 다음과 같다.모든 0 &amp;lt;= j &amp;lt; i에 대하여, D[i] = max(D[i], D[j] + 1) if array[j] &amp;lt; array[i]이를 이용하면n = int(input())array = list(map(int, input().split()))# 순서를 뒤집어 가장 긴 증가하는 부분 수열 문제로 변환array.reverse()dp = [1] * nfor i in range(1, n): for j in range(0, i): if array[i] &amp;gt; array[j]: dp[i] = max(dp[i], dp[j] + 1)print(n - max(dp))" }, { "title": "chapter 16 : 실전 DP 33번 문제(퇴사)", "url": "/posts/chapter16-q-33/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-04 00:00:00 +0800", "snippet": "문제 : 퇴사문제 링크내 생각문제에서 어떻게 점화식을 끄집어내야 할 지도 모르는 너무 어려운 문제였다. 한마디로 뇌절 당했다… 20분동안 가만히 끄적이다가 못풀겠다는 확신만 더 얻은채로 결국 책에 의존했다.책 해답이 문제를 풀 때는 뒤쪽 날짜부터 거꾸로 확인하는 방식으로 접근하여 해결하는 다이나믹 프로그래밍의 아이디어를 떠올릴 수 있다. 다음은 문제에서 제시된 상담 일정표다.| | 1일 | 2일 | 3일 | 4일 | 5일 | 6일 | 7일 |—|—|—|—|—|—|—|—||T | 3 | 5 | 1 | 1 | 2 | 4 | 2 |P | 10 | 20 | 10 | 20 | 15 | 40 | 200 |1일 차에 상담을 진행한다고 해보자. 이 경우 3일에 걸쳐서 상담을 진행해야 한다. 결과적으로 4일 부터 다시 상담을 진행할 수 있다. 그러므로 1일 차에 상담을 진행하는 경우, 최대 이익은 ‘1일 차의 상담 금액 + 4일부터의 최대 상담 금액’ 이 된다. 따라서 이러한 원리를 이용하여 뒤쪽 날짜부터 거꾸로 계산하며 문제를 해결할 수 있다. 즉, 뒤쪽 부터 매 상담을 하여 ‘현재 상담 일자의 이윤(p[i]) + 현재 상담을 마친 일자부터의 최대 이윤(dp[t[i] + i])를 계산하면 된다. 이후에 계산된 각각의 값중에서 최댓값을 출력하면 된다.n = int(input())t = []p = []dp = [0] * (n)max_value = 0for _ in range(n): t_i, p_i = map(int, input().split()) t.append(t_i) p.append(p_i)# 리스트를 뒤에서 부터 꺼꾸로 확인for i in range(n - 1, -1, -1): time = t[i] + i if time &amp;lt;= n: dp[i] = max(p[i] + dp[t[i] + i], max_value) max_value = dp[i] # 상담이 기간을 벗어나는 경우 else: dp[i] = max_value print(dp, time)print(max_value)" }, { "title": "chapter 16 : 실전 DP 32번 문제(정수 삼각형)", "url": "/posts/chapter16-q-32/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-03 00:00:00 +0800", "snippet": "문제 : 정수 삼각형문제 링크내 생각이 문제는 앞의 31번 문제와 똑같이 풀면 된다. 위에 2개의 선택지 중에 큰 것을 자신의 것과 더하면서 내려가면 된다.n = int(input())data = [list(map(int, input().split())) for _ in range(n)]for i in range(1, n): for j in range(i + 1): if j == 0: data[i][j] += data[i - 1][j] elif j == len(data[i]) - 1: data[i][j] += data[i - 1][j - 1] else: data[i][j] += max(data[i - 1][j - 1], data[i - 1][j])result = 0for j in range(n): result = max(result, data[n - 1][j])print(result)" }, { "title": "chapter 16 : 실전 DP 31번 문제(금광)", "url": "/posts/chapter16-q-31/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-03 00:00:00 +0800", "snippet": "문제 : 금광내 생각금광은 왼쪽에서 오른쪽으로 가면서 캐기 때문에, 금광의 max 값을 저장하는 2차원 리스트를 이용하여 계산하도록 하였다. 재귀를 이용한 방식이다.n, m = map(int, input().split())data = [list(map(int, input().split())) for _ in range(n)]max_golds = [[0] * m for _ in range(n)]answer = 0# 재귀로 오른쪽으로 이동하면서 금을 더함def add_gold(x, y, stored): global answer if x &amp;gt;= n or y &amp;gt;= m or x &amp;lt; 0 or y &amp;lt; 0: return max_golds[x][y] = max(max_golds[x][y], stored + data[x][y]) answer = max(answer, max_golds[x][y]) add_gold(x + 1, y + 1, max_golds[x][y]) add_gold(x - 1, y + 1, max_golds[x][y]) add_gold(x, y + 1, max_golds[x][y]) returnfor i in range(n): add_gold(i, 0, 0)print(answer)책 해답책은 바텀 업 방식으로 풀었다. 금광의 모든 위치에 대하여 왼쪽 위에서 오는 경우, 왼쪽 아래에서 오는 경우, 왼쪽에서 오는 경우의 3가지 경우만 존재한다. 따라서 이 3가지 경우 중에서 가장 많은 금을 가지고 있는 경우를 테이블에 저장해주어 문제를 해결하면 된다.t = int(input())while t &amp;gt; 0: n, m = map(int, input().split()) data = list(map(int, input().split())) # 2차원 리스트를 위한 dp 초기화 dp = [] k = 0 for i in range(n): dp.append(data[k:k + m]) k += m for j in range(1, m): for i in range(n): if i == 0: left_up = 0 left_down = dp[i + 1][j - 1] elif i == (n - 1): left_up = dp[i - 1][j - 1] left_down = 0 else: left_up = dp[i - 1][j - 1] left_down = dp[i + 1][j - 1] dp[i][j] += max(dp[i][j - 1], left_up, left_down) result = 0 for i in range(n): result = max(result, dp[i][m - 1]) print(result) t -= 1" }, { "title": "정보처리기사 - 2과목 : 소프트웨어 개발", "url": "/posts/software-development/", "categories": "information processing", "tags": "", "date": "2020-11-02 00:00:00 +0800", "snippet": "2과목 소프트웨어 개발1장 데이터의 입출력 구현총 정리 1. 자료구조 전반적인 부분 오버플로, 언더플로의 정리 트리 2. DBMS 전반적인 부분 종속성 3. 데이터 입출력 4. 절차형 SQL 전반적인 부분 3, 42장 통합 구현총 정리 1. 단위 모듈 구현 IPC 통신 IPC 통신 영상 2, 단위 모듈 테스트 3. 개발 지원 도구3장 소프트웨어 패키징1 ~ 3. SW 패키징, 릴리즈 노트, DRM 총 정리 4 ~ 8. 소프트웨어 매뉴얼과 분산관리도구, 빌드 자동화 도구 총 정리 git pull, fetch의 차이4장 어플리케이션 테스트 관리49 ~ 51. 어플리케이션 테스트 분류 총 정리 52 ~ 55. 개발 단계별 어플리케이션 테스트 총 정리" }, { "title": "chapter 15 : 실전 이진 탐색 30번 문제(가사 검색)", "url": "/posts/chapter15-q-30/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-02 00:00:00 +0800", "snippet": "문제 : 가사검색문제 링크내 생각”?” 는 정규 표현식에서 메타문자 “.”와 같으니 주어진 query의 “?” 들을 모두 “.” 으로 바꾼 뒤, match를 통해서 확인하면 된다고 생각했다. 허나 해당 방식은 정확성은 만점이나 효율성은 0점을 기록할 정도로 효울적이진 않다.내 코드import redef solution(words, queries): answer = [] for query in queries: temp = query.replace(&quot;?&quot;, &quot;.&quot;) count = 0 for word in words: if re.match(temp, word) and len(temp) == len(word): count += 1 answer.append(count) return answer책 해답이 문제는 이진 탐색을 이용해서 간결하게 해결할 수 있다. 먼저 단어를 길이에 따라서 나눈다. 이후에 모든 리스트를 정렬한 뒤에, 각 쿼리에 대해서 이진 탐색을 수행하여 문제를 해결 할 수 있다. 즉, 길이로 정렬하고, 단어순으로 정렬하는 것이다.책 코드from bisect import bisect_left, bisect_rightdef count_by_range(a, left_value, right_value): # 문자도 가능 right_index = bisect_right(a, right_value) left_index = bisect_left(a, left_value) return right_index - left_indexarray = [[] for _ in range(10001)]reversed_array = [[] for _ in range(10001)] # 단어를 뒤집어서 넣을 리스트def solution(words, queries): answer = [] for word in words: array[len(word)].append(word) # 단어 길이에 맞춰서 저장 reversed_array[len(word)].append(word[::-1]) # 단어를 뒤집어서 저장 for i in range(10001): array[i].sort() reversed_array[i].sort() for q in queries: if q[0] != &quot;?&quot;: res = count_by_range(array[len(q)], q.replace(&quot;?&quot;, &quot;a&quot;), q.replace(&quot;?&quot;, &quot;z&quot;)) else: res = count_by_range(reversed_array[len(q)], q[::-1].replace(&quot;?&quot;, &quot;a&quot;), q[::-1].replace(&quot;?&quot;, &quot;z&quot;)) answer.append(res) return answer느낀 점이번 문제를 통해서 bisect 함수에 문자열이 들어가도 작동하는 것을 깨달았다. 굉장히 편리한 기능이라서 자주 쓸 예정이다. 문제에 난이도가 최상인 만큼 이런 문제를 이진 탐색으로 푸는 건 생각도 못했다.역시 괴물은 많다…" }, { "title": "chapter 15 : 실전 이진 탐색 29번 문제(공유기 설치)", "url": "/posts/chapter15-q-29/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-02 00:00:00 +0800", "snippet": "문제 : 공유기 설치문제링크내 생각이 문제를 이진 탐색으로 어떻게 찾을지 조차도 생각하지 못했다. 머리속에서 떠오르는 알고리즘은 완전탐색 밖에 없었고 너무 느려서 오답처리되었다.책 해답책은 이 문제를 이진 탐색으로 접근한다. 이전의 문제와 다르게, 정렬된 데이터에서 찾는 것이 아니라, 정렬된 데이터의 가장 큰 값과 작은 값을 뺀 gap을 이용하여 이진 탐색을 진행했다.이진 탐색을 이용하여 gap을 변화 시키면서 그 gap이상으로 공유기를 배치할 때 c의 개수로 배치가 되는지를 판단하면서 진행했다.책 코드n, c = map(int, input().split())data = []for _ in range(n): data.append(int(input()))data.sort()start = data[1] - data[0]end = data[-1] - data[0]result = 0while start &amp;lt;= end: mid = (start + end) // 2 # mid = gap value = data[0] count = 1 for i in range(1, n): if data[i] &amp;gt;= value + mid: # 공유기 설치 가능? count += 1 value = data[i] if count &amp;gt;= c: start = mid + 1 result = mid else: end = mid - 1print(result)느낀 점이진 탐색을 적용하려고 노력을 안한 것은 아니나, 정렬된 데이터의 중간값을 찾거나 특정 값을 찾는 문제가 아니기에 적용을 어떻게 해야하는지 감을 못잡았다. 이번 문제를 통해서 이런 방식으로도 이진 탐색을 쓸 수 있다는 것에 굉장히 놀라며, 공부할게 굉장히 많겠구나 라는 생각이 든다." }, { "title": "chapter 15 - 실전 이진 탐색 : 28번 문제(고정점 찾기)", "url": "/posts/chapter15-q-28/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-11-02 00:00:00 +0800", "snippet": "문제 : 고정점 찾기내 생각이 문제는 인덱스와 해당 인덱스의 value값이 같으면 return을 해주고, 만약 인덱스가 값보다 크면, start를 키우고, 작으면 end를 줄이는 방식으로 하면 된다.책 코드n = int(input())data = list(map(int, input().split()))start = 0end = len(data)result = Falsewhile start &amp;lt;= end: mid = (start + end) // 2 if data[mid] == mid: result = True break elif data[mid] &amp;gt; mid: end = mid - 1 else: start = mid + 1if result: print(mid)else: print(-1)느낀 점이 문제에서 가장 중요시 봐야할 부분은 시간 복잡도 O(logN)으로 설계하라는 부분이다. 이는 대놓고 이진탐색으로 풀라고 준 문제인 것 같다. 이번 문제는 이진 탐색을 이해하고 있는가 정도의 문제인 것 같다. 29번 문제에서는 광탈했지만 이거라도 풀어서 다행이다…" }, { "title": "Programmers Level 2 : 큰 수 만들기", "url": "/posts/%ED%81%B0%EC%88%98%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "programmers", "tags": "", "date": "2020-10-22 00:00:00 +0800", "snippet": "문제 : 모의고사문제 링크내 생각def solution(number, k): answer = &#39;&#39; n = len(number) # 매번 sub_str을 만들어주는 자리수 a = n - k # 뒤의 a번째 자리 부터 자름 while len(answer) != (n - k): r = number[::-1][a - 1:][::-1] index = r.index(str(max(list(map(int, r))))) answer += r[index] number = number[index + 1:] a -= 1 return answer" }, { "title": "Programmers Level 1 : 모의고사", "url": "/posts/%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC/", "categories": "programmers", "tags": "", "date": "2020-10-22 00:00:00 +0800", "snippet": "문제 : 모의고사문제 링크풀이이 문제는 반복되는 수열을 리스트에 담아둬서 문제를 해결해야한다. 각각의 학생의 답안지에 대한 수열을 리스트로 만들고, answer 에 대해서 완전 탐색을 진행하면된다. 알고리즘은 이렇다. 학생들의 답안지에 대한 수열을 리스트로 만들어 담아둔다. answers를 이용하여 반복문을 만든다. 답안지 수열의 길이만큼을 정답의 index에 나눠 나온 나머지를 답안지 수열의 인덱스로 넣은 값과 정답을 비교한다. 비교된 값이 옳으면 해당 답안지 수열의 인덱스를 이용하여 정답 개수 리스트에 1더해준다. max를 이용하여 가장 많이 맞은 학생들을 리스트에 넣는다.def solution(answers): # 1 checks = [[1, 2, 3, 4, 5], [2, 1, 2, 3, 2, 4, 2, 5 ], [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]] records = [0] * 3 # 2 for i, a in enumerate(answers): # 답중에 하나를 꺼내옴 # 3 for j, check in enumerate(checks): # j : 학생, check : 학생의 답의 리스트 # 3 -&amp;gt; 4 if check[i % len(check)] == a: records[j] += 1 # 5 return [i + 1 for i, v in enumerate(records) if v == max(records)]3번의 경우가 문제를 푸는 키 포인트이다. 반복되는 수열이니 수열의 길이를 이용하여 정답의 인덱스를 나눈 나머지를 사용하면 계속해서 탐색이 가능하다." }, { "title": "정규표현식을 알아보자(2)", "url": "/posts/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(2)/", "categories": "regular_expression", "tags": "", "date": "2020-10-21 00:00:00 +0800", "snippet": "특수문자해당 글은 Gorio Learning 에서의 글을 공부하기 위해 일일이 타이핑 한 글입니다. 제 나름대로의 해석도 들어가 있습니다. 링크메타문자메타 문제에 대해서는 이전 글에서 설명했다.비인쇄 문자정규표현식을 쓰면서 다른 것들은 거의 볼 일이 없을 것이지만, \\t와 \\n은 알아두는 것이 좋다. \\t : tab \\n : 개행문자(라인 넘김, 키보드로 enter와 동일한 기능)이스케이프 \\이스케이프 문자 \\는 메타문자를 일반 리터럴 문자로 취급하게끔 해준다. 예를 들어 여는 괄호 [는 메타 문자지만, [와 같이 처리해주면 리터럴 문자인 일반 대괄호 문자 ‘[‘와 매칭될 수 있게 된다.하지만, 일반 영수 문자를 이스케이프 처리하면 에러가 나거나 혹은 전혀 다른 의미의 정규식 토큰이 생성된다. 예를 들어 파이썬 에서 \\1&#39;의 경우에는 캡처한 문자열 중 첫번째를 재사용한다는 의미가 되어버린다. 따라서 `를 남용하면 안된다.[] 대괄호 : 여러 문자 중 하나와 일치대괄호 [ 와 ]사이에 원하는 문자를 여러 개 넣으면, 문자열이 넣은 문자 중 하나와 일치하면 매칭이 이루어진다. 즉 OR 개념이라고 할 수 있다. 여기서 중요한 것은 []안에 얼마나 많은 문자 종류가 있는지에 상관 없이 딱 한 문자와 일치된다는 것이다. 예를 들어 정규식 표현이 [abc] 이고 문자열이 ‘a’이면 re.match는 매칭되었다고 할 것이다. ‘b’ 나 ‘c’도 매칭이 된다. 허나 ‘가’, ‘나’ 등 과는 매칭되지 않는다. 대괄호 [] 에는 다른 기능이 더 있다. 이전 글에서 설명한 ‘그 외’ 부분의 문자들인데, 문자 -는 대괄호 안에서는 메타문자 역할을 한다. 하이픈 -은 범위를 형성한다. 예를 들어 [a-z]는 알파벳 소문자 중 하나이기만 하면 매칭이 된다. 또 [A-Z], [0-9]는 각각 알파벳 대문자와 숫자 하나에 매칭된다. 물론 위의 범위 경우 뿐만 아니라 넓은 범위도 가능하다. [가-힣]의 경우는 한글 한 글자에 일치된다.[A-z]는 영문 대소문자와 몇 개의 특수문자도 포함한다. 그러니 영문자를 포함하고 싶으면 [A-Za-z]를 사용하자..마침표 : 모든 문자와 일치개행문자를 제외한 모든 문자와 일치하는 정규표현식은 마침표 .이다. 정말로 모든 문자와 일치되기 때문에 별다른 설명은 필요 없을 것 같다.문자 집합: \\w\\W, \\d\\D, \\s\\S, \\b\\B\\w, \\W : 단어 문자, 비 단어 문자 \\w는 단어 문자 1개와 일치된다. 단어 문자는 영문 대소문자, 숫자 0-9, 언더바 _를 포함한다. \\W는 \\w와 정확히 반대의 역할을 한다." }, { "title": "정규 표현식을 알아보자(1)", "url": "/posts/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D(1)/", "categories": "regular_expression", "tags": "", "date": "2020-10-20 00:00:00 +0800", "snippet": "정규표현식해당 글은 Gorio Learning 에서의 글을 공부하기 위해 일일이 타이핑 한 글입니다. 제 나름대로의 해석도 들어가 있습니다. 링크1:1로 매칭되는 문자정규표현식 안에서, 바로 다음 절에서 설명하는 메타문자를 제외한 모든 문자는 일반 문자열 하나와 매칭된다. 예를 들어 a는 a와 매칭되고 가는 ‘가’와 매칭되는 식이다. 당연히 a가 ‘b’ 또는 ‘가’와 매칭되지는 않는다.메타문자어떤 프로그래밍 언어의 정규표현식이든 메타문자라는 것이 존재한다. 이는 특수한 기능을 하는 문자로, import 등 파이썬의 예약어와 비슷한 역할을 맡는 문자로고 생각하면 된다. 파이썬의 re 모듈의 메타 문자는 총 12개로 다음과 같다. $()*.?[\\^{| 이들 메타문자는 각각의 문자 하나에 매칭되지 않는다. 그럼 찾고자 하는 문자열에 소괄호가 있으면 어떻게 하나?위의 문자들의 앞에 \\ 를 붙여주면 일반 문자처럼 한 글자에 매칭된다. 예를 들어 \\(는 문자 ‘(‘와 매칭된다.그 외그 외에는 ], -, ) 가 있다.re 패키지의 기본 methodimportpy파일에서는 import re를 해주어야 쓸 수 있다.re.match(pattern, string, flags)re.match 함수는 “문자열의 처음”부터 시작하여 패턴이 일치되는 것이 있는지를 확인한다. 다음의 예를 보자.matchObj = re.match(&#39;ab&#39;, &#39;a&#39;)print(matchObj)print(re.match(&#39;ab&#39;, &#39;aba&#39;)) # 인자 : &#39;ab&#39; : 패턴, &#39;aba&#39; : 패턴을 찾을 문자열print(re.match(&#39;ab&#39;, &#39;bbb&#39;))print(re.match(&#39;ab&#39;, &#39;baa&#39;))print(re.match(&#39;ba&#39;, &#39;baa&#39;))결과는 다음과 같다.None&amp;lt;re.Match object; span=(0, 2), match=&#39;ab&#39;&amp;gt;NoneNone&amp;lt;re.Match object; span=(0, 2), match=&#39;ba&#39;&amp;gt;매치가 되었을 때는 match Object를 반환한다. 매치 되지 않으면 None을 반환한다.re.match 함수는 인자로 1) 패턴, 2) 패턴을 찾을 문자열, 3)옵션을 받는다. 3번은 필수 인자는 아닌데, 어떤 옵션이 있는지는 뒤에서 설명한다. ## re.search(pattern, string, flags)re.search 함수는 re.match와 비슷하지만, 반드시 문자열의 처음부터 일치해야 하는 것은 아니다.matchObj = re.search(&#39;ab&#39;, &#39;a&#39;)print(matchObj)print(re.search(&#39;ab&#39;, &#39;aba&#39;)) # 인자 : &#39;ab&#39; : 패턴, &#39;aba&#39; : 패턴을 찾을 문자열print(re.search(&#39;ab&#39;, &#39;bbb&#39;))print(re.search(&#39;aa&#39;, &#39;baa&#39;)) # 이전 예시랑 다른 부분print(re.search(&#39;ba&#39;, &#39;baa&#39;))결과는 다음과 같다.None&amp;lt;re.Match object; span=(0, 2), match=&#39;ab&#39;&amp;gt;None&amp;lt;re.Match object; span=(1, 3), match=&#39;aa&#39;&amp;gt;&amp;lt;re.Match object; span=(0, 2), match=&#39;ba&#39;&amp;gt;결과를 보면 span이라는 것이 보이는데, 이는 x번째 문자부터 y번째 문자 전까지가 패턴과 매치되었음을 뜻한다.re.findall(pattern, string, flags)re.findall 함수는 문자열 중 패턴과 일치되는 모든 부분을 찾는다.import rematchObj = re.findall(&#39;ab&#39;, &#39;a&#39;)print(matchObj)print(re.findall(&#39;ab&#39;, &#39;aba&#39;)) # 인자 : &#39;ab&#39; : 패턴, &#39;aba&#39; : 패턴을 찾을 문자열print(re.findall(&#39;a&#39;, &#39;bbb&#39;))print(re.findall(&#39;a&#39;, &#39;baa&#39;))print(re.findall(&#39;a&#39;, &#39;aba&#39;))결과[][&#39;ab&#39;][][&#39;a&#39;, &#39;a&#39;][&#39;a&#39;, &#39;a&#39;]re.finditer(pattern, string, flags)re.findall과 비슷하지만, 일치된 문자열의 리스트 대신 matchObj가 들어있는 리스트를 반환한다.import rematchObj_iter = re.finditer(&#39;a&#39;, &#39;baa&#39;)print(matchObj_iter)for matchObj in matchObj_iter: print(matchObj)결과&amp;lt;callable_iterator object at 0x7f557aca47c0&amp;gt;&amp;lt;re.Match object; span=(1, 2), match=&#39;a&#39;&amp;gt;&amp;lt;re.Match object; span=(2, 3), match=&#39;a&#39;&amp;gt;re.fullmatch(patten, string, flags)re.fullmatch는 패턴과 문자열이 남는 부분 없이 완벽하게 일치하는지를 검사한다.match Object의 메서드들match Object를 그대로 출력해서 쓰고 싶은 사람은 별로 없을 것이다. re.match 등의 결과로 얻은 matchObj를 활용하는 방법을 정리하면 다음과 같다. |Method|Description||:—:|:—:||group()|일치된 문자열을 반환한다.||start()|일치된 문자열의 시작 위치를 반환한다.||end()|일치된 문자열의 끝 위치를 반환한다.||span()|일치된 문자열의 (시작 위치, 끝 위치) 튜플을 반환한다.|" }, { "title": "chapter 15 : 실전 이진 탐색 27번 문제(정렬된 배열에서 특정 수의 개수 구하기", "url": "/posts/chapter15-q-27/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-18 00:00:00 +0800", "snippet": "문제 : 정렬된 배열에서 특정 수의 개수 구하기# 27번 문제def first_search(array, target, start, end): while start &amp;lt;= end: mid = (start + end) // 2 print(&#39;first&#39;) if array[mid] == target and (mid == 0 or array[mid - 1] &amp;lt; target): return mid elif array[mid] &amp;gt;= target: end = mid - 1 else: start = mid + 1def last_search(array, target, start, end): while start &amp;lt;= end: mid = (start + end) // 2 print(&#39;last&#39;) if array[mid] == target and (mid == len(array) - 1 or array[mid + 1] &amp;gt; target): return mid elif array[mid] &amp;gt; target: end = mid - 1 else: start = mid + 1n, x = map(int, input().split())data = list(map(int, input().split()))first = first_search(data, x, 0, n - 1)last = last_search(data, x, 0, n - 1)print(last - first + 1)" }, { "title": "chapter 3 : 그리디 4번 문제(1이 될 때 까지)", "url": "/posts/chapter3-q-4/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-17 00:00:00 +0800", "snippet": "문제 : 1이 될 때 까지어떠한 수 N이 1이 될 때 까지 다음의 두 과정 중 하나를 반복적으로 선택하여 수행하려고 한다. 두 번쨰 연산은 N이 K로 나누어떨어질 때만 선택할 수 있다. N에서 1을 뺀다. N을 K로 나눈다.N과 K가 주어질 때 N이 1이 될 때까지 1복 혹은 2번의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램을 작성하시오.내 생각이 문제는 전형적인 그리디 알고리즘이다. 나누는게 훨씬 횟수를 빠르게 해주기 때문에 K로 나눠진다면 무조건 나누고(k &amp;gt; 1이라면) 그게 아니면 빼주면 된다.# 1이 될 때 까지n, k = map(int, input().split())count = 0while n != 1: if n % k == 0: n = n / k count += 1 else: n -= 1 count += 1print(count)책 해답책에서는 이런 코드 외의 속도의 향상을 위해서 1을 한번에 빼버리는 방식을 구현했다.# 1이 될 때 까지n, k = map(int, input().split())result = 0while True: target = (n // k) * k # n이 k의 배수가 될 때 까지 뺴기 result += (n - target) n = target # N이 K보다 작을 때 if n &amp;lt; k: break result += 1 n //= kresult += (n - 1)print(result)" }, { "title": "chapter 3 : 그리디 3번 문제(카드 정렬하기)", "url": "/posts/chapter3-q-3/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-17 00:00:00 +0800", "snippet": "문제 : 카드 정렬하기이 문제는 주어진 2차원 리스트의 각 리스트의 최솟값 중에 최대값을 구하는 문제이다. 주어진 2차원 리스트를 반복문을 통해 1차원 리스트로 뽑아낸 후 해당 리스트의 최솟값들을 비교해주면 된다.# 숫자 카드 게임n, m = map(int, input().split())cards_list = [list(map(int, input().split())) for _ in range(n)]result = 0for cards in cards_list: result = max(result, min(cards))print(result)" }, { "title": "chapter 11 : 실전 그리디 3번 문제(문자열 뒤집기)", "url": "/posts/chapter11-q-3/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-17 00:00:00 +0800", "snippet": "문제 : 문자열 뒤집기다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있습니다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 합니다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것입니다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미합니다.내 생각주어진 리스트를 0과 1이 들어있는 리스트로 나눈다 예를 들어 s = ‘0110110’ 이라면 list = [[0], [1, 1], [0], [1, 1], [0]] 이 된다. 이 리스트 안에서 0이 있는 리스트와 1이 있는 리스트의 숫자를 파악하여 최솟값을 구하면 정답이다.# 문자열 뒤집기s = input()def categorize(s): result = [] result.append([s[0]]) for i in range(1, len(s)): if s[i] == s[i - 1]: result[-1].append(s[i]) else: result.append([s[i]]) return resultdef count(result): zero, one = 0, 0 for i in result: if &#39;0&#39; in i: zero += 1 else: one += 1 return min(zero, one)print(count(categorize(s)))책 해답책에서는 0에서 1로 변하거나 1에서 0으로 변할 때의 값을 카운트 하여 그 값중에서 작은 값을 구한다.# 문자열 뒤집기data = input()count0 = 0count1 = 1# 첫 번쨰 원소에 대한 처리if data[0] == &#39;1&#39;: count0 += 1else: count1 += 1for i in range(len(data) - 1): if data[i] != data[i + 1]: # 다음 수에서 1로 바뀌는 경우 if data[i + 1] == &#39;1&#39;: count0 += 1 # 다음 수에서 0으로 바뀌는 경우 else: count1 += 1print(min(count0, count1))" }, { "title": "chapter 11 : 실전 그리디 2번 문제(곱하기 혹은 더하기)", "url": "/posts/chapter11-q-2/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-17 00:00:00 +0800", "snippet": "문제각 자리가 숫자로만 이루어진 문자열 S가 주어졌을 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 ‘X’ or ‘+’ 연산자를 넣어 결과적으로는 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.내 생각각 자리의 숫자가 0 인 경우는 필요 없으니 해당 문자열에서 0을 제거한 뒤, 만약 숫자가 1이라면 더하고 아니면 곱하는 방식으로 구현했다.# 곱하기 혹은 더하기# 1이면 더하기 아니면 곱하기n = input().replace(&#39;0&#39;, &#39;&#39;)result = int(n[0])for i in range(1, len(n)): number = int(n[i]) if number == 1: result += number else: result *= numberprint(result)" }, { "title": "chapter 11 : 실전 그리디 1번 문제(모험가 길드)", "url": "/posts/chapter11-q-1/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-17 00:00:00 +0800", "snippet": "문제 : 모험가 길드한 마을에 모험가가 N명 있습니다. 모험가 길드에서는 N명의 모험가를 대상으로 ‘공포도’를 측정했는데, ‘공포도’가 높은 모험가는 쉽게 공포를 느껴 위험 상황에서 제대로 대처할 능력이 떨어집니다. 모험가 길드장인 동빈이는 모험가 그룹을 안전하게 ㄱ구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날수 있도록 규정했습니다.동빈이를 위해 N명의 모험가에 대한 정보가 주어졌을 때, 여행을 떠날 수 있는 그룹 수의 최대값을 구하는 프로그램을 작성하세요.내 생각주어진 모험가의 공포도 리스트를 해당 원소의 개수를 해당 원소로 나누는 프로그램을 작성하면 된다. 예를 들어 n = 5, list = [2, 3, 1, 2 ,2] 라고 하면 1은 한 개이므로 1 / 1 = 1, 2는 3개 이므로 3 / 2 = 1(int) 3은 1개 이므로 3 / 1 = 0(int) 가 된다.# 모험가 길드n = int(input())data = list(map(int, input().split()))groups = 0data.sort()for i in range(1, len(data) + 1): groups += (data.count(i) // i)print(groups)" }, { "title": "chapter 3 : 그리디 2번 문제(큰 수의 법칙)", "url": "/posts/chapter3-q-2/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-16 00:00:00 +0800", "snippet": "문제 : 큰 수의 법칙이 문제는 전형적인 그리디 문제이다. 하나의 수를 연속해서 더할 때 최대 k번 까지만 가능하므로 주어진 배열에서 가장 큰 수를 k번 더한 뒤, 2번 째 큰 수를 더해주는 것을 반복하면 된다.# 큰 수의 법칙# n : 배열의 크기, m : 몇번 더할 건지, k : 반복해서 몇번 더할지n, m, k = map(int, input().split())numbers = list(map(int, input().split()))numbers.sort(reverse = True) # 내림차순으로count = 0 # 몇 번 더했는지answer = 0while m &amp;gt; 0: if count == k: count = 0 answer += numbers[1] m -= 1 continue answer += numbers[0] count += 1 m -= 1print(answer)책 해답책에서는 반복문 말고 수학적인 방식으로도 풀었다. 풀이가 참신하여 올려본다.예를 들어 [2, 4, 6, 4, 5] 라는 배열에서 m = 8, k = 3 이라면 결과는 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 = 46 일 것이다. 우리는 이를 수열 처럼 볼 수 있다. [6, 6, 6, 5], [6, 6, 6, 5] 인 2개의 수열이 보이는가?k = 3 이라면 한 개당 수열의 크기는 k + 1 = 4 개의 원소가 들어간다. 가장 큰 수는 수열당 k 번 씩 들어가기 때문에 가장 큰 수의 더하기 횟수는 2(수열의 개수) * k = 6 번 더해지는 것을 알 수 있다. 하지만 만약 m = 9 라면 수열은 [6, 6, 6, 5], [6, 6, 6, 5]. [6] 으로 이뤄지게 된다. 이 경우에는 m % (k + 1) 번의 개수만큼 가장 큰 수를 더하게 된다.즉 정리하면 가장 큰 수를 더하는 횟수 = (m / (k + 1)) * k + m % (k + 1) 이다.# 큰 수의 법칙# n : 배열의 크기, m : 몇번 더할 건지, k : 반복해서 몇번 더할지n, m, k = map(int, input().split())numbers = list(map(int, input().split()))numbers.sort(reverse = True)count = (m // (k + 1)) * kcount += m % (k + 1)answer = 0answer += numbers[0] * countanswer += numbers[1] * (m - count)print(answer)" }, { "title": "chapter 14 : 실전 정렬 26번 문제(카드 정렬하기)", "url": "/posts/chapter14-q-26/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-15 00:00:00 +0800", "snippet": "문제 : 카드 정렬하기문제 링크내 생각초기에는 카드 묶음을 정렬한 뒤, 앞에서 2개씩 더한 것을 계속해서 더해주면 된다고 생각했다. 예를 들면 10, 20, 40이 있다면 그냥 앞에서 부터 10 + 20 = 30, 30 + 40 = 70 -&amp;gt; 30 + 70 = 100 이런 식으로 풀려고 했다.그러다 보니 10은 10은 2번 20도 2번 40은 1번 더한 것과 같아서 다음과 같은 코드를 작성했다. 물론 결과는 실패 였다.내 코드n = int(input())data = [int(input())for _ in range(n)]data.sort()summary = data[0] * (n - 1)for i in range(1, n): summary += data[i] * (n - i)print(summary)책 해답무엇이 문제였을까를 고민해보니, 내가 한 답은 매번 최소의 카드 묶음 두개를 고르는 방식이 아니였다. 이 문제는 매번 2개를 고를 때마다 최소의 값을 골라야한다. 그렇다면 최소의 값을 위해 계속 정렬해야하는데 우리는 이미 그걸 해주는 자료구조를 알고있다. 바로 최소 힙이다.최소 힙은 heapq.heappush 와 heapq.heappop을 통해서 푸시 할 때는 최소 값이 가장 앞으로 오게, 팝을 할 때는 가장 작은 값이 리턴되도록 되어 있다. 따라서 우리는 데이터를 최소 힙에 넣어두고 2개를 팝하여 더한 것을 다시 힙에 넣는 방식으로 구현하면 된다.책 코드import heapq # 파이썬은 최소힙을 지원한다.n = int(input())answer = []for _ in range(n): heapq.heappush(answer, int(input())) # 데이터를 최소 힙에 넣음summary = 0 # 결과while True: if len(answer) == 1: # 힙의 크기가 1일때 까지 break one = heapq.heappop(answer) two = heapq.heappop(answer) summary += one + two # 더한 것을 저장 heapq.heappush(answer, one + two) # 더한 것을 다시 최소 힙에 넣음print(summary)" }, { "title": "chapter 14 : 실전 정렬 25번 문제(실패율)", "url": "/posts/chapter14-q-25/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-15 00:00:00 +0800", "snippet": "문제 : 실패율문제 링크내 생각주어진 조건을 그대로 구현하면된다. 핵심 로직은 실패율을 구하는 방식인데 나는 filter 함수를 이용하여구현했다. 알고리즘은 맞으나 속도가 느려 런타임 에러로 인해 답을 맞추지는 못했다.내 코드def solution(N, stages): temp = [] answer = [] for stage in range(1, N+ 1): reached = len(list(filter(lambda x : x &amp;gt;= stage, stages))) reached_but_not_clear = stages.count(stage) faliure = float(reached_but_not_clear) / reached temp.append((stage, faliure)) temp = sorted(temp, key = lambda x : (-x[1], x[0])) for i in temp: answer.append(i[0]) return(answer)책 코드def solution(N, stages): answer = [] length = len(stages) for i in range(1, N + 1): count = stages.count(i) if length == 0: failure = 0 else: failure = count / length answer.append((i, failure)) length -= count answer.sort(key = lambda x : x[1], reverse = True) answer = [i[0] for i in answer] return answer" }, { "title": "chpater 14 : 실전 정렬 24번 문제(안테나)", "url": "/posts/chapter14-q-24/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-15 00:00:00 +0800", "snippet": "문제 : 안테나문제 링크내 생각주어진 집의 위치를 평균내에서 해당 위치에 안태나를 구축한 뒤에 값을 계싼하면 최솟값이 될 것이라고 생각했다. 혹시 모르는 오류에 대비하여 평균 앞 뒤의 값을 계산하여 최솟값의 인덱스를 출력하도록 하였다.내 코드# 안테나# 입력 -&amp;gt;데이터 정렬 -&amp;gt;평균 -&amp;gt; 거리 산출n = int(input())data = list(map(int, input().split()))data.sort()aver = sum(data) // len(data)result = []for i in range(aver-1, aver + 2): summary = 0 for j in data: summary += abs(i - j) result.append((i, summary))result.sort(key = lambda x : x[1])print(result[0][0])책 해답이 문제의 핵심 아이디어는 정확히 중간 값의 해당하는 위치의 집에 안테나를 설치했을 때, 안테나로 부터 모든 집까지의 거리의 총합이 최소가 된다는 점이다.책 코드n = int(input())data = list(map(int, input().split()))data.sort()print(data[(n - 1) // 2])느낀 점음… 핵심아이디어를 생각하지 못했다. 평균이 아닌 위치의 중간 값이 최소가 되는 줄 몰라서 문제를 제대로 풀지 못하였다. 이러한 핵심아이디어를 추론하려면 시간이 오래걸리겠지만, 그래도 하다보면 늘테니 조금 더 고민해보고 문제를 풀어가는 습관을 들이는게 맞는 듯 싶다." }, { "title": "chapter 14 : 실전 정렬 23번 문제(국영수)", "url": "/posts/chapter14-q-23/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-15 00:00:00 +0800", "snippet": "문제 : 국영수문제 링크내 생각문제에서 주어지는 조건대로 정렬하면 되는 문제이다. 파이썬의 sort() 함수는 default가 오름차순 이므로 내림차순을 할 떄는 앞에 -를 붙여주면 된다. key로 정렬 기준을 튜플로 리턴해주는 lambda 함수를 만들어주면 딘다.내 코드# 23번 문제 국영수# 국어(내림차순) -&amp;gt; 영어(오름차순) -&amp;gt; 수학(내림차순) -&amp;gt; 이름(오름차순)n = int(input())# 입력 : 이름, 국어, 영어, 수학data = [list(input().split()) for _ in range(n)]data.sort(key = lambda x : (-int(x[1]), int(x[2]), -int(x[3]), x[0]))for i in range(n): print(data[i][0])책 해답파이썬에서는 튜플을 원소로 하는 리스트가 있을 때, 그 리스트를 정렬하면 기본적으로 각 튜플을 구성하는 원소에 순서에 맞게 정렬된다는 특징이 있다.예를 들어 튜플이 3개의 원소로 구성 된다면 모든 원소가 첫 번쨰 원소의 준서에 맞게 정렬되고, 첫 번째 원소의 값이 같은 경우 두 번쨰 원소의 순서에 맞게 정렬되고, 거기에 두 번쨰 원소의 값까지 같은 경우 세 번쨰 원소의 순서에 맞게 정렬된다. 아래의 소스코드를 보자.a = [(5, 1, 5), (3, 5, 5], (3, 1, 9), (3, 1, 1)a.sort() # 정렬 수행print(a)# 출력 : [(3, 1, 1), (3, 1, 9), (3, 5, 5), (5,1, 5)]또한 리스트의 원소를 정렬할 떄는 sort() 함수의 key 속성에 값을 대입하여 내가 원하는 ‘조건’에 맞게 튜플을 정렬시킬 수 있다는 점을 기억하자.책 코드해당 코드는 위의 ‘내 코드’ 와 거의 유사하여 따로 넣지는 않았다." }, { "title": "chapter 13 복습", "url": "/posts/chapter_13_practice/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-14 00:00:00 +0800", "snippet": "15번 문제 : 특정 거리의 도시 찾기# 특정 거리의 도시 찾기# n개의 도시, m개의 도로# 특정 도시 x로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 k인 모든 도시를 출력하는 프로그램 작성# 입력 -&amp;gt; 각 도시의 최단 거리를 나타내는 리스트 생성 -&amp;gt; 그래프를 순회하면서(bfs) 최단거리 갱신 -&amp;gt; 최단거리가 k인 도시 출력하는from collections import dequen, m, k, x = map(int, input().split())graph = [[] * (n + 1) for _ in range(n + 1)] # 그래프 생성# 그래프 입력(linked graph)for _ in range(m): start, end = map(int, input().split()) graph[start].append(end)# 최단 거리 정보를 담는 리스트dist = [1e9] * (n + 1)def bfs(start): q = deque() distance = 0 dist[start] = distance q.append(start) while q: distance += 1 for _ in range(len(q)): start = q.popleft() for i in graph[start]: dist[i] = min(dist[i], distance) q.append(i)bfs(x)result = Falsefor idx, value in enumerate(dist): if value == k: result = True print(idx)if not result: print(-1)16번 문제 : 연구소# 연구소# 바이러스 유출 -&amp;gt; 막기위해서 연구소에 벽을 세움# n* m 의 크기의 연구소, 빈칸 or 벽으로 나뉘어져있음# 일부 칸에 바이러스 존재, 바이러스는 상하좌우로 퍼져나감# 연구소의 지도가 주어졌을 떄 얻을 수 있는 안전 영역 크기의 최대값을 구하는 프로그램 작성# 입력 -&amp;gt; 벽을 세우고 -&amp;gt; 바이러스 퍼트리고 -&amp;gt; 안전 영역 크기 계싼from collections import dequeimport copyn, m = map(int, input().split())lab = [list(map(int, input().split())) for _ in range(n)] # 연구소 입력temp = [[0] * m for _ in range(n)]result = 0def get_score(): result = 0 for i in range(n): for j in range(m): if temp[i][j] == 0: result += -1 return resultdef virus(x, y): q = deque() q.append((x, y)) dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1] while q: x, y = q.popleft() for i in range(4): nx, ny = x + dx[i], y + dy[i] if nx &amp;gt;= n or ny &amp;gt;= m or nx &amp;lt; 0 or ny &amp;lt; 0: continue if temp[nx][ny] == 0: q.append((nx, ny)) temp[nx][ny] = 2def dfs(count): global result if count == 3: for i in range(n): for j in range(m): temp[i][j] = lab[i][j] for i in range(n): for j in range(m): if temp[i][j] == 2: virus(i, j) result = max(get_score(), result) return for i in range(n): for j in range(m): if lab[i][j] == 0: lab[i][j] = 1 count += 1 dfs(count) lab[i][j] = 0 count -= 1dfs(0)print(result)17번 문제 : 경쟁적 전염# 경쟁적 전염# n x n 시험관, 1 x 1 크기의 칸이고 각각의 칸에는 바이러스 존재가 가능, 바이러스는 1 ~ k까지 k 가지 있으며 모든 바이러스는 이 중 하나의 속함# 바이러스는 1초마다 상하 좌우 조 증식함, 매초 번호가 낮은 종류의 바이러스 부터 증식, 바이러스가 있는 곳에는 다른 바이러스 침입 불가# 시험관의 크기와 바이러스의 위치 정보가 주어졌을 때, s 초가 지난 후에 (x, y)에 존재하는 바이러스의 종류를 출력하는 프로그램 작성# 초가 시작 되면 -&amp;gt; 바이러스가 낮은 순으로 부터 증식n, k = map(int, input().split())maps = [list(map(int, input().split())) for _ in range(n)]s, x, y = map(int, input().split())def virus(x, y): visited[x][y] = True dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1] for i in range(4): nx, ny = x + dx[i], y + dy[i] if nx &amp;gt;= n or ny &amp;gt;= n or nx &amp;lt; 0 or ny &amp;lt; 0: continue if maps[nx][ny] == 0 and visited[nx][ny] == False: visited[nx][ny] = True maps[nx][ny] = maps[x][y]count = 0while count &amp;lt; s: for v in range(1, k + 1): visited = [[False] * n for _ in range(n)] for i in range(n): for j in range(n): if maps[i][j] == v and visited[i][j] == False: virus(i, j) count += 1print(maps[x - 1][y - 1])" }, { "title": "chapter 13 : 실전 bfs/dfs 21번 문제(인구이동)", "url": "/posts/chapter13-q-21/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-11 23:53:29 +0800", "snippet": "문제 : 인구이동문제 링크내 생각이 문제는 bfs를 통해서 풀면 되겠다고 느끼고 실제로 그렇게 하려고 했다. 허나 문제를 제대로 읽지 않아서 문제에서 요구하는 알고리즘을 생각해내지 못했고 그 결과 어려운 문제까진 아니였으나 내 자신이 어렵게 만들어 버렸다.책 해답책에서는 전형적인 bfs라고 소개한다. 문제에서 요구하는 그대로를 알고리즘으로 구현하면 된다.책 코드from collections import deque# 땅의 크기(N), L, R 값을 입력받기n, l, r = map(int, input().split())# 전체 나라의 정보(N x N)를 입력 받기graph = []for _ in range(n): graph.append(list(map(int, input().split())))dx = [-1, 0, 1, 0]dy = [0, -1, 0, 1]# 특정 위치에서 출발하여 모든 연합을 체크한 뒤에 데이터 갱신def process(x, y, index): # (x, y)의 위치와 연결된 나라(연합) 정보를 담는 리스트 united = [] united.append((x, y)) # 너비 우선 탐색 (BFS)을 위한 큐 라이브러리 사용 q = deque() q.append((x, y)) union[x][y] = index # 현재 연합의 번호 할당 summary = graph[x][y] # 현재 연합의 전체 인구 수 count = 1 # 현재 연합의 국가 수 # 큐가 빌 때까지 반복(BFS) while q: x, y = q.popleft() # 현재 위치에서 4가지 방향을 확인하며 for i in range(4): nx = x + dx[i] ny = y + dy[i] # 바로 옆에 있는 나라를 확인하여 if 0 &amp;lt;= nx &amp;lt; n and 0 &amp;lt;= ny &amp;lt; n and union[nx][ny] == -1: # 옆에 있는 나라와 인구 차이가 L명 이상, R명 이하라면 if l &amp;lt;= abs(graph[nx][ny] - graph[x][y]) &amp;lt;= r: q.append((nx, ny)) # 연합에 추가하기 union[nx][ny] = index summary += graph[nx][ny] count += 1 united.append((nx, ny)) # 연합 국가끼리 인구를 분배 for i, j in united: graph[i][j] = summary // counttotal_count = 0# 더 이상 인구 이동을 할 수 없을 때까지 반복while True: union = [[-1] * n for _ in range(n)] index = 0 for i in range(n): for j in range(n): if union[i][j] == -1: # 해당 나라가 아직 처리되지 않았다면 process(i, j, index) index += 1 # 모든 인구 이동이 끝난 경우 if index == n * n: break total_count += 1# 인구 이동 횟수 출력print(total_count)느낀 점문제… 를 잘 읽어야한다… 문제 읽는 시간을 아껴서 문제를 푸는데 쓴다는 생각은 정말 초짜가 하는 짓인것 같다. 문제를 읽는데에 아무리 시간이 오래걸리더라도 해당 문제에서 어떻게 풀 것인지 를 다 뽑은 후에 문제를 풀어야 할 것 같다. 다음 문제에서 가장 먼저 할 것은 문제를 제대로 읽고 문제를 푸는 알고리즘을 손으로 적어볼 생각이다." }, { "title": "chapter 13 : 실전 bfs/dfs 20번 문제(감시피하기)", "url": "/posts/chapter13-q-20/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-11 23:53:29 +0800", "snippet": "문제 : 감시피하기문제 링크내 생각3개의 장애물을 설치하는 문제는 예전에 16번 연구소 문제에서 다뤘었다. 그 알고리즘을 다시 세워서 장애물을 만든 뒤, dfs를 이용하여 한 방향으로만 나아가는 함수를 만들어 장애물이 없다면 모두 ‘X’ 로 만들고, 있다면 멈추는 함수를 구현했다. 그 후 결과 리스트에서 S가 검출되면 True, 아니면 False를 리턴하게 했다.내 코드# 1. 입력n = int(input())maps = [list(input().split()) for _ in range(n)]temp = [[0] * n for _ in range(n)]dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]result = []# 3. dfs를 통해 단방향으로 이동하면서 S를 X로 바꿈(장애물이 있으면 종료)def check_stu(x, y, direction): nx, ny = x + dx[direction], y + dy[direction] if nx &amp;lt; n and ny &amp;lt; n and nx &amp;gt;= 0 and ny &amp;gt;= 0: if temp[nx][ny] == &#39;O&#39; or temp[nx][ny] == &#39;T&#39;: return elif temp[nx][ny] == &#39;S&#39;: temp[nx][ny] = &#39;X&#39; check_stu(nx, ny, direction) return check_stu(nx, ny, direction)# 2. dfs를 통한 반복문def dfs(count): if count == 3: for i in range(n): for j in range(n): temp[i][j] = maps[i][j] for i in range(n): for j in range(n): if temp[i][j] == &#39;T&#39;: for direction in range(4): check_stu(i, j, direction) # 4. 장애물이 3개 설치 되었을 때, 감시 체크후 S가 존재하는지 확인 for i in range(n): for j in range(n): # 5. S가 있으면 결과에 담음 if temp[i][j] == &#39;S&#39;: result.append(True) return for i in range(n): for j in range(n): if maps[i][j] == &#39;X&#39;: count += 1 maps[i][j] = &#39;O&#39; dfs(count) maps[i][j] = &#39;X&#39; count -= 1 return Falsedfs(0)# 6. 결과에 True가 있으면 Yes, 아니면 No를 출력if True in result: print(&#39;Yes&#39;)else: print(&#39;No&#39;)책 해답이 문제는 장애물을 정확히 3개 설치하는 모든 경우를 확인하여, 매 경우마다 모든 학생을 감시로 부터 피하도록 할 수 있는지의 여부를 출력해야한다. 그렇다면 장애물을 정확히 3개 설치하는 모든 경우의 수는 얼마나 될지 생각해보자. 복도의 크기는 N x N이며, N은 최대 6이다. 따라서 장애물을 정확히 3개 설치하는 모든 조합의 수는 최악의 경우 36C3이 될 것이다. 이는 10,000 이하의 수이므로 모든 조합을 고려하여 완전 탐색을 수행해도 시간 초과 없이 문제를 해결할 수 있다. 따라서 모든 조합을 찾기 위해서 DFS 혹은 BFS를 이용해 모든 조합을 반환하는 메서드를 작성하거나, 파이썬의 조합 라이브러리를 이용할 수 있다.책 코드from itertools import combinationsn = int(input())board = []teachers = []spaces = []for i in range(n): board.append(list(input().split())) for j in range(n): if board[i][j] == &#39;T&#39;: teachers.append((i, j)) if board[i][j] == &#39;X&#39;: spaces.append((i, j))def watch(x, y, direction): # 왼쪽으로 감시 if direction == 0: while y &amp;gt;= 0: if board[x][y] == &#39;S&#39;: return True if board[x][y] == &#39;O&#39;: return False y -= 1 # 오른쪽으로 감시 if direction == 1: while y &amp;lt; n: if board[x][y] == &#39;S&#39;: return True if board[x][y] == &#39;O&#39;: return False y += 1 # 위쪽으로 감시 if direction == 2: while x &amp;gt;= 0: if board[x][y] == &#39;S&#39;: return True if board[x][y] == &#39;O&#39;: return False x -= 1 # 아래쪽으로 감시 if direction == 3: while x &amp;lt; n: if board[x][y] == &#39;S&#39;: return True if board[x][y] == &#39;O&#39;: return False x += 1 return Falsedef process(): for x, y in teachers: for i in range(4): if watch(x, y, i): return True return Falsefind = Falsefor data in combinations(spaces, 3): for x, y in data: board[x][y] = &#39;O&#39; if not process(): find = True break for x, y in data: board[x][y] = &#39;X&#39;if find: print(&#39;Yes&#39;)else: print(&#39;No&#39;)" }, { "title": "chapter 13 : 실전 bfs/dfs 19번 문제(연산자 끼워넣기)", "url": "/posts/chapter13-q-19/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-06 23:53:29 +0800", "snippet": "문제 : 연산자 끼워넣기문제 링크내 생각이 문제는 완전 탐색을 통해서 문제를 풀어야한다고 생각했다. 연산자의 개수를 순열을 통해서 이리저리 바꾸면서 앞에서 부터 연산하여 그 값을 리스트에 저장, 모든 작업이 끝나면 가장 큰 값과 가장 작은 값을 출력하면 된다고 생각했다.내 아이디어는 이렇다. 입력을 받는다. 사칙연산을 순열을 통해 모든 경우의 수를 고려하게 만든다. 앞에서부터 사칙연산을 한다. 사칙연산을 한 결과를 리스트에 저장한다. 리스트에서 가장 큰 값과 가장 작은 값을 출력한다.내 코드# 연산자 끼워 넣기# 주어진 수와 연산자로 최대, 최솟값을 구하시오# 연산은 무조건 앞에서 뒤로 이루어진다.# 나눗셈은 몫만 취한다# 음수를 양수로 나누면 양수로 바꿔 몫을 취한뒤 음수로 바꾼다.# 알고리즘# 1. 입력# 2. 사칙연산 조합 생성# 3. 사칙연산 조합으로 앞에서 부터 산수# 4. 산수 나온 결과를 리스트에 대입, max, min으로 결과 도출from itertools import permutationsdef conduct_calculation(answer,operand, operate): if operate == &#39;+&#39;: return answer + operand elif operate == &#39;-&#39;: return answer - operand elif operate == &#39;*&#39;: return answer * operand elif operate == &#39;/&#39;: if answer &amp;lt; 0: return -(abs(answer) // operand) else: return answer // operand# 1.n = int(input())numbers = list(map(int, input().split()))operates = &#39;&#39;k = list(map(int, input().split())) # k = 사칙연산의 개수# 2.operates += &#39;+&#39; * int(k[0])operates += &#39;-&#39; * int(k[1])operates += &#39;*&#39; * int(k[2])operates += &#39;/&#39; * int(k[3])operates = list(operates)operates_lists = permutations(operates, n - 1)result = []for operates_list in operates_lists: answer = numbers[0] for idx, operate in enumerate(operates_list): # 3. answer = conduct_calculation(answer, numbers[idx + 1], operate) result.append(answer)# 4.print(max(result), min(result))책 해답이 문제는 최대 11개의 수가 주어졌을 때, 각 수와 수 사이의 사칙연산 중 하나를 삽입하는 모든 경우에 대하여 만들어질 수 있는 결과의 최댓값 및 최솟값을 구하면 된다. 따라서 모든 경우의 수를 계산하기 위하여(완전 탐색) DFS 혹은 BFS를 이용하여 문제를 해결할 수 있다.본, 문제에 대한 정답 소스코드는 중복 순열(product) 클래스를 사용하지 않고 DFS를 이용하여 푸는 방법을 소개하겠다.책 코드n = int(input())# 연산을 수행하고자 하는 수 리스트data = list(map(int, input().split()))# 더하기, 빼기, 곱하기, 나누기 연산자 개수add, sub, mul, div = map(int, input().split())# 최솟값과 최댓값 초기화min_value = 1e9max_value = -1e9# 깊이 우선 탐색 (DFS) 메서드def dfs(i, now): global min_value, max_value, add, sub, mul, div # 모든 연산자를 다 사용한 경우, 최솟값과 최댓값 업데이트 if i == n: min_value = min(min_value, now) max_value = max(max_value, now) else: # 각 연산자에 대하여 재귀적으로 수행 if add &amp;gt; 0: add -= 1 dfs(i + 1, now + data[i]) add += 1 if sub &amp;gt; 0: sub -= 1 dfs(i + 1, now - data[i]) sub += 1 if mul &amp;gt; 0: mul -= 1 dfs(i + 1, now * data[i]) mul += 1 if div &amp;gt; 0: div -= 1 dfs(i + 1, int(now / data[i])) # 나눌 때는 나머지를 제거 div += 1# DFS 메서드 호출dfs(1, data[0])# 최댓값과 최솟값 차례대로 출력print(max_value)print(min_value)느낀점재귀를 통해서 하는 방식 자체에서 꽤나 놀랐다. 앞에서 부터 나아가는 반복이기 때문에 당연히 재귀로 구현도 가능하다는 것을 깨달아야했는데 깨닫지 못한게 조금 아쉽다. 속도 역시 내 코드보다 휠씬 빠르다. 오늘도 배웁니다 ㅠ… 사칙연산 4가지에 대해서 각각의 재귀를 통해서 연산을 함으로써 문제를 굉장히 쉽게 구현해냈다. 재귀를 어려워 하는 나에게는 굉장히 좋은 예시가 되었다." }, { "title": "chapter 13 : 실전 bfs/dfs 18번 문제(괄호 변환)", "url": "/posts/chapter13-q-18/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-05 23:53:29 +0800", "snippet": "문제: 괄호 변환문제 링크내 생각이 문제는 별 하나임에도 불구하고 풀지 못했다. 문제를 제대로 이해하지 못하여, “분리” 라는 부분을 “추출”로 잘못 이해했다. 주어진 문자열을 분리하여 재귀적으로 더해주면 되는 문제인데, 추출로 생각하다보니 머리가 꼬였다.책 해답이 문제는 제시된 알고리즘을 재귀적으로 구현하여 해결 할 수 있다. 구현을 위한 알고리즘은 문제에 그대로 제시되어 있기 때문에, 재귀 함수를 이용하여 문제에 기재되어 있는 알고리즘을 실수없이 안정적으로 구현할 수 있으면 문제를 해결 할 수 있다.엄밀히 말하면 이 문제는 DFS 문제는 아니다. 하지만 DFS 알고리즘의 핵심이 되는 재귀 함수 구현을 요구한다는 점에서 DFS 연습 목적의 문제로 이 파트에서 다룬다.이 문제를 실수 없이 풀려면 소스코드를 최대한 단순화 하는 것이 좋다. 따라서 특정 문자열에서 “균형잡힌 괄호 문자열”의 인덱스를 반환하는 함수와 특정한 “균형잡힌 괄호 문자열”이 “올바른 괄호 문자열” 인지 판단하는 메서드를 별도로 구현한다. 이후에 재귀 함수에서 이 두 함수를 불러오도록 소스코드를 작성할 수 있다.책 코드def balanced_index(p): count = 0 # 왼쪽 괄호의 개수 for i in range(len(p)): if p[i] == &#39;(&#39;: count += 1 else: count -= 1 if count == 0: return idef check_proper(p): count = 0 # 왼쪽 괄호의 개수 for i in p: if i == &#39;(&#39;: count += 1 else: if count == 0: # 쌍이 맞지 않는 경우에 False 반환 return False count -= 1 return True # 쌍이 맞는 경우에 True 반환def solution(p): answer = &#39;&#39; if p == &#39;&#39;: return answer index = balanced_index(p) u = p[:index + 1] v = p[index + 1:] # 올바른 괄호 문자열이면, v에 대해 함수를 수행한 결과를 붙여 반환 if check_proper(u): answer = u + solution(v) else: answer = &#39;(&#39; answer += solution(v) answer += &#39;)&#39; # 프로그래머스에서 문자열 슬라이싱이 잘 안됨 u = list(u[1:-1]) for i in range(len(u)): if u[i] == &#39;)&#39;: u[i] = &#39;(&#39; else: u[i] = &#39;)&#39; answer += &#39;&#39;.join(u) return answer느낀 점몇번 풀어보지 않은 괄호 문제라서 문제의 시작부터 겁을 먹었었다. 괄호에 대해서 안좋은 추억이 있어서 그랬는지도 모르겠다. 하지만 해답을 보니 생각보다 굉장히 쉬웠고, 너무 많이 머리를 쓰려하는게 오히려 독이 되는 것 같다. 천천히 흐름대로 하나하나 하는 습관을 들여보자. 그러면 어느새 문제는 다 풀려있다." }, { "title": "chapter 13 : 실전 bfs/dfs 17번 문제(경쟁적 전염)", "url": "/posts/chapter13-q-17/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-04 23:53:29 +0800", "snippet": "문제 : 경쟁적 전염문제링크내 생각이 문제는 배열을 순회하면서 바이러스의 순서에 따라 바이러스를 퍼트려야하는 문제이다. 즉, bfs를 한 번씩 상하좌우로만 하며 바이러스를 퍼트려야한다.연쇄되는 바이러스 전염을 막기위해 visited라는 2차원 배열을 매초 초기화 하여 쓰며 해당 알고리즘을 풀어나간다. 입력 시간 초 설정(반복문) 바이러스 순서(반복문) visited 초기화 바이러스 전염 시작(반복문) 다시 바이러스 전염을 위한 visited 초기화이 순서로 하면 될 것 같다.내 코드# 경쟁적 전염# 매 초 번호가 낮은 바이러스부터 퍼짐# 1초당 상하좌우 1칸씩# 1. 입력# 2. 시간 초 설정(반복문)# 3. 바이러스 순서(반복문)# 4. visited 초기화# 5. 바이러스 전염 시작(반복문)# 6. 다시 바이러스 전염을 위한 visited 초기화#4def infection(x, y): dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1] visited[x][y] = True for i in range(4): nx, ny = x + dx[i], y + dy[i] if nx &amp;gt;= n or ny &amp;gt;= n or nx &amp;lt; 0 or ny &amp;lt; 0: continue if plask[nx][ny] == 0: plask[nx][ny] = plask[x][y] visited[nx][ny] = True# 1. 입력n, k = map(int, input().split())# 시험관의 정보plask = []for _ in range(n): plask.append(list(map(int, input().split())))visited = [[False] * n for _ in range(n)]s, x, y = map(int, input().split())# 2. 시간 초 설정count = 0while count &amp;lt; s: # 3. 바이러스 설정 for virus in range(1, k + 1): # 4, 6 : visited 초기화 visited = [[False] * n for _ in range(n)] # 5 : 바이러스 전염 for i in range(n): for j in range(n): if plask[i][j] == virus and visited[i][j] == False: infection(i, j) count += 1print(plask[x - 1][y - 1])책 해답이 문제는 너비 우선 탐색을 이용하여 해결 할 수 있다. 다만, 문제에 나와 있는 대로 각 바이러스가 낮은 번호부터 증식한다는 점을 기억하자. 낮은 번호부터 증식하므로, 초기에 큐에 원소를 삽입할 때는 낮은 바이러스의 번호부터 삽입해야한다. 이후에 너비 우선 탐색을 수행하며 방문하지 않은 위치를 차례대로 방문하도록 하면 된다.책 코드from collections import dequen, k = map(int, input().split())graph = [] # 전체 보드 정보를 담는 리스트data = [] # 바이러스에 대한 정보를 담는 리스트for i in range(n): # 보드 정보를 한 줄 단위로 입력\\ graph.append(list(map(int, input().split()))) for j in range(n): # 해당 위치에 바이러스가 존재하는 경우 if graph[i][j] != 0: # (바이러스 종류, 시간, 위치 x, 위치 y) data.append((graph[i][j], 0, i, j))# 정렬 이후에 큐로 옮기기(낮은 번호의 바이러스가 먼저 증식하므로)data.sort()q = deque(data)target_s, target_x, target_y = map(int, input().split())dx, dy = [-1, 1, 0, 0], [0, 0, 1, -1]while q: virus, s, x, y = q.popleft() if s == target_s: break for i in range(4): nx, ny = x + dx[i], y + dy[i] if nx &amp;gt;= 0 and ny &amp;gt;= 0 and nx &amp;lt; n and ny &amp;lt; n: if graph[nx][ny] == 0: graph[nx][ny] = virus q.append((virus, s + 1, nx, ny))print(graph[target_x - 1][target_y - 1])느낀 점책의 해답을 보니 나는 뭔가 헛짓거리를 많이 한것 같다. bfs의 개념을 제대로 이용하지 못했고, 이용하지 못했다는 것은 개념이해가 잘 안됬다는 것이다. 문제 풀이를 하며 새운 계획을 다시 보니 바이러스가 퍼지는 걸 bfs라고 하면서 머리속으로는 dfs를 하고 있었다. 그냥 데이터만 정렬해서 bfs로 풀면 되는 문제였다." }, { "title": "chapter 13 : 실전 bfs/dfs 16번 문제(연구소)", "url": "/posts/chapter13-q-16/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-04 23:53:29 +0800", "snippet": "문제인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었습니다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 합니다.연구소는 크기가 N x M인 직사각형으로 나타낼 수 있으며, 직사각형은 1 x 1크기의 정사각형으로 나누어져 있습니다.주어진 2차원 배열에서 0은 빈칸, 1은 벽, 2는 바이러스입니다. 바이러스는 상하좌우 인접한 빈칸으로 모두 펴져나갈 수 있습니다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야합니다.3개의 벽을 세워서 만들 수 있는 안전지대의 최댓값을 구하세요내 생각3개의 벽을 세워서 안전지대를 만드는 것이기 때문에, 이 문제는 조합 + bfs or dfs 로 해결할 수 있을 것 같다. 벽을 세우는 것은 조합으로, 바이러스의 유출을 bfs or dfs로 하여 전염시킨뒤 안전지대를 구하면 될 것이라고 판단했다. 그러나 내 실력이 좋지 못하여 조합 라이브러리를 통해서 벽의 위치를 설정하지 못했다… 벽의 위치를 1개 씩 설정한 뒤에 다시 반복문의 위로 올라가야하는데 그 부분이 잘 되지 않았다.책 코드# 연구소# 1. 조합을 통한 벽의 위치# 2. bfs or dfs을 통한 바이러스 유출# 3. 안전지대 계산n, m = map(int, input().split())data = []temp = [[0]*m for _ in range(n)] # 벽을 설치한 뒤의 맵 리스트for _ in range(n): data.append(list(map(int, input().split())))dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]result = 0# dfsdef virus(x, y): for i in range(4): nx, ny = x + dx[i], y + dy[i] # 상, 하, 좌, 우 중에서 바이러스가 퍼질 수 있는 경우 if nx &amp;gt;= 0 and ny &amp;gt;= 0 and nx &amp;lt; n and ny &amp;lt; m: if temp[nx][ny] == 0: temp[nx][ny] = 2 virus(nx, ny)# 안전지대 계산def get_score(): score = 0 for i in range(n): for j in range(m): if temp[i][j] == 0: score += 1 return score# 깊이 우선 탐색을 이용해 울타리를 설치하면서, 매번 안전 영역의 크기 계산def dfs(count): global result # 울타리가 3개 설치된 경우 if count == 3: for i in range(n): for j in range(m): temp[i][j] = data[i][j] # 각 바이러스의 위치에서 전파 진행 for i in range(n): for j in range(m): if temp[i][j] == 2: virus(i, j) result = max(result, get_score()) return # 울타리 설치 for i in range(n): for j in range(m): if data[i][j] == 0: data[i][j] = 1 count += 1 dfs(count) # 벽 다시 없애기 data[i][j] = 0 count -= 1dfs(0)print(result)내 코드책에서는 dfs를 통해서 울타리를 설치했지만 나는 이 부분을 조합으로 바꿔보았다. 하지만 반복문이 더 많아지고 속도 역시 더 느려졌다.# 연구소# 1. 조합을 통한 벽의 위치# 2. bfs or dfs을 통한 바이러스 유출# 3. 안전지대 계산from itertools import combinationsn, m = map(int, input().split())data = []temp = [[0]*m for _ in range(n)] # 벽을 설치한 뒤의 맵 리스트empty = [] # 조합을 위한 리스트for _ in range(n): data.append(list(map(int, input().split())))dx, dy = [-1, 1, 0, 0], [0, 0, -1, 1]result = 0# dfsdef virus(x, y): for i in range(4): nx, ny = x + dx[i], y + dy[i] # 상, 하, 좌, 우 중에서 바이러스가 퍼질 수 있는 경우 if nx &amp;gt;= 0 and ny &amp;gt;= 0 and nx &amp;lt; n and ny &amp;lt; m: if temp[nx][ny] == 0: temp[nx][ny] = 2 virus(nx, ny)# 안전지대 계산def get_score(): score = 0 for i in range(n): for j in range(m): if temp[i][j] == 0: score += 1 return scorefor i in range(n): for j in range(m): if data[i][j] == 0: empty.append((i, j))# 조합으로 벽 경우의 수 생성walls_list = combinations(empty, 3)for walls in walls_list: for i in range(n): for j in range(m): temp[i][j] = data[i][j] # 벽 할당 for wall in walls: temp[wall[0]][wall[1]] = 1 for i in range(n): for j in range(m): if temp[i][j] == 2: virus(i, j) result = max(result, get_score())print(result)느낀 점어려운 문제였다. 물론 문제 해결을 위한 아이디어는 비슷하게 생각했지만, 아직 코드 구현능력이 많이 부족하다. 많은 코딩을 해야하고, 논리적으로 생각하여 코드 구현을 할 줄 알아야한다. 이 문제를 통해서 재귀를 통해 벽을 생성, 삭제하는 방법을 알았다." }, { "title": "chapter 13 : 실전 bfs/dfs 15번 문제(특정 거리의 도시 찾기)", "url": "/posts/chapter13-q-15/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-04 23:53:29 +0800", "snippet": "문제어떤 나라에는 1 ~ N번까지의 도시와 M개의 단방향 도로가 존재합니다. 모든 도로의 거리는 1입니다. 이때 특정한 도시 x로 부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 k인 모든 도시의 번호를 출력하는 프로그램을 작성하세요.내 생각이번 문제는 주어진 그래프에서 출발점으로부터 특정 거리가 최소거리인 노드를 찾는 문제이다. 이를 위해서는 bfs를 이용하면 효과적이라고 생각했다.이번 문제의 알고리즘은 이렇다. 출발점을 q에 넣고, 출발점으로 부터 각 노드에 대한 최소거리를 저장하는 리스트를 하나 만든다. 출발점으로 부터 시작되는 노드들을 담으면서 최소거리 리스트에 거리 1을 넣어준다. while 문을 통해 q에 원소를 빼고 넣으며 bfs 알고리즘을 수행한다. while 문 내부에 q에 길이에 대한 반복문을 넣으면서 해당 반복문이 끝나면 거리를 1씩 증가시킨다. 최소거리 리스트의 값과 비교를 통해 최소거리를 갱신한다.내 코드# 특정 거리의 도시 찾기from collections import dequen, m, k, x = map(int, input().split())# 그래프 개수 입력graph = [[] for _ in range(n + 1)]# 간선 정보 입력for _ in range(m): a, b = map(int, input().split()) graph[a].append(b)dist = [1e9] * (n + 1)def bfs(start): dist[start] = 0 count = 1 q = deque() for i in graph[start]: q.append(i) while q: for _ in range(len(q)): start = q.popleft() dist[start] = min(dist[start], count) for j in graph[start]: q.append(j) count += 1bfs(1)print(dist)책 해답책의 경우도 bfs를 사용했다. 허나 나의 풀이와 다른 점은 while문 내에서 다시 한번 반복문을 사용한게 아니라, 최소거리 리스트의 정보를 이용하여 최소거리를 갱신했다.책 코드from collections import deque# 도시의 개수, 도로의 개수, 거리정보, 출발 도시 번호n, m, k, x = map(int, input().split())graph = [[] for _ in range(n + 1)]for _ in range(m): a, b = map(int, input().split()) graph[a].append(b)distance = [-1] * (n + 1)distance[x] = 0# bfs 수행q = deque([x])while q: now = popleft() # 현재 도시에서 이동할 수 있는 모든 도시를 확인 for next_node in graph[now]: # 아직 방문하지 않은 도시라면 if distance[next_node] == -1: # 최단 거리 갱신 distance[next_node] = distance[now] + 1 q.append(next_node)# 최단 거리가 k인 모든 도시의 번호를 오름차순으로 출력check = Falsefor i in range(1, n + 1): if distance[i] == k: print(i) check = Trueif check == False: print(-1)" }, { "title": "chapter 12 : 실전 구현 13번 문제(치킨 배달)", "url": "/posts/chapter12-q-13/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-10-04 16:31:29 +0800", "snippet": "문제: 치킨 배달크기가 N X N 인 도시가 있습니다. 도시의 각 칸은 빈칸, 치킨집, 집 중 하나입니다. 도시의 칸은 (r, c)와 같은 형태로 나타냅니다.이 곳에 사는 사람들은 치킨을 매우 좋아합니다. 따라서 사람들은 ‘치킨 거리’ 라는 말을 주로 사용합니다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리입니다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있습니다. 도시의 치킨거리는 모든 집의 치킨 거리의 합입니다.도시의 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야합니다. 어떻게 고르면 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하세요.내 생각M개의 치킨집을 구하기 떄문에 경우의 수를 구하는 순열을 이용하면 될 것이다. 맵을 순회하며 집과 치킨집의 위치정보를 저장한뒤, 순열을 이용하여 치킨집의 경우의 수를 만들고, 이들을 각각 도시의 치킨거리를 구하여 최솟값을 구하면 된다고 생각한다.내 코드# 치킨 배달# 1. 맵을 만들어 값을 입력 받는다# 2. 맵을 순회하며 집의 위치와 치킨집의 위치를 저장한다((i,j)의 형태로)# 3. 저장한 치킨집중 M 개를 뽑는다(permutations)# 4. 뽑은 치킨집과 집의 거리들을 비교하며 최솟값을 만든다.from itertools import permutations# n : 도시의 길이, m : 치킨집의 개수n, m = map(int, input().split())# 1. 맵 입력data = [list(map(int, input().split())) for _ in range(n)]answer = []# 2. 집 : 1, 치킨집 : 2houses, chickens = [], []# 2. 배열에 진입하여 치킨집과 집의 행과 열을 들고옴for i in range(n): for j in range(n): if data[i][j] == 1: houses.append((i, j)) elif data[i][j] == 2: chickens.append((i, j))# 3. m개의 치킨집 순열chickens_per = list(permutations(chickens, m))# 치킨집 목록 뽑음for per in chickens_per: distance = 0 # 집 하나 for house in houses: min_value = n * n # 치킨 거리 뽑음 for chicken_house in per: min_value = min(min_value, abs(house[0] - chicken_house[0]) + abs(house[1] - chicken_house[1])) distance += min_value answer.append(distance)print(min(answer))책 해답순서를 고려하지 않고 M개를 뽑는다… 순열이 아닌 조합이다…파이썬의 조합 라이브러리를 이용하여 모든 경우의 수를 간단히 계산하면 된다.책 코드from itertools import combinationsn, m = map(int, input().split())chicken, house = [], []for r in range(n): data = list(map(int, input().split())) for c in range(n): if data[c] == 1: house.append((r, c)) elif data[c] == 2: chicken.append((r, c))candidates = list(combinations(chicken, m))# 치킨 거리의 합을 계싼하는 함수def get_sum(candidate): result = 0 for hx, hy in house: temp = 1e9 for cx, cy in candidate: temp = min(temp, abs(hx - cx) + abs(hy - cy)) # 가장 가까운 치킨집까지의 거리를 더하기 result += temp return resultresult = 1e9for candidate in candidates: result = min(result, get_sum(candidate))print(result)느낀 점순서를 고려하지 않고 뽑는다 = 조합이다. 일단 문제를 푼 것은 굉장히 행복하지만 답의 코드 작성과 내 코드를 비교하면 아직 한참 먼 것 같다. 물론 부담이 되지는 않는다. 천천히 할 생각이다. 중요한건 내가하는 일을 재밌게 하는 것이지 무리하면서 잘 할 필요는 없다고 생각한다.별 2개짜리 문제를 풀었으니 뿌듯하다." }, { "title": "programmers level 2 : 가장 큰 정사각형", "url": "/posts/square/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-09-25 23:53:29 +0800", "snippet": "문제 : 가장 큰 정사각형0 과 1로 이루어진 N x N 의 정사각형 2차원 배열을 줬을 때 1로 이루어진 가장 큰 정사각형의 크기를 구하시오내 생각오 2차원 배열? 오 0과 1? 넓이 구하기? 이건 bfs 지! 하고 생각 했다가 바로 당해버렸다… n의 범위가 1000 까지므로 1000 x 1000 이면 기본적으로 1,000,000의 연산을 해야하는데 이걸 생각 못한 것이다. 연산량이 거대하고 문제에서 수학의 향기가 나기 때문에 이 문제는 DP 로 풀어야 한다. 나의 경우, 우선 bfs로 1인 x, y 값을 리스트에 담아서 이를 이용하여 정사각형을 확인하려 했지만 정사각형을 구하는 알고리즘을 생각하지 못하여 풀지 못했다.해결법위에서 언급한 것처럼, DP를 통해서 해야한다. 정사각형의 한 포인트(배원의 원소)를 기준으로 좌, 상단, 좌측 상단을 확인하여 해당 원소에 다시 값을 할당해야한다. 예를 들면, (2,2) 에서 확인 하면 (1,2), (2,1), (1,1) 의 원소들의 값을 보고, 그 값중에 최솟값의 값의 + 1을 (2,2)에 할당하면 된다. 단, 원래의 (2,2) 의 값은 0 이상이여야 한다.코드def solution(board): # 정사각형의 한 변의 길이 row = len(board) col = len(board[0]) max_point = 0 sum_point = 0 # 모든 배열이 0 인경우 for i in range(row): sum_point += sum(board[i]) if sum_point == 0: return 0 # 배열 내부로 진입 for i in range(1, row): for j in range(1, col): # 우측 아래가 0이 아니라면 if board[i][j]: # 정사각형 변의 길이 구하기 : 우측아래가 0이 아니고 나머지 3개의 최솟값에 + 1 board[i][j] = min(board[i][j - 1], board[i - 1][j], board[i - 1][j - 1]) + 1 max_point = max(board[i][j], max_point) if max_point: return max_point ** 2 # max_point = 0 일 떄는 1을 리턴(가장 작은 정사각형 크기) else: return 1느낀점일단 문제를 잘 읽어보지 않고 섣부르게 bfs로 접근하려고 하여 시작부터 꼬인 문제이다. 물론 bfs로도 풀수 있는 문제이지만, DP가 효율성 면에서 훨씬 더 좋다고 생각한다. 요즘들어 특히 더 느끼지만, 읽는 것을 잘하는 것이 문제에 해결하는데에 가장 기초가 되는 것 같다. 서투르게 문제를 풀려하지말고 천천히 읽어나가는 연습부터, 좀 오래걸리더라도 꾸준히 해야겠다." }, { "title": "chapter 12 : 실전 구현 12번 문제(기둥과 보 설치)", "url": "/posts/chapter12-q-12/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-09-24 23:53:31 +0800", "snippet": "문제프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다. 기둥은 바닥위에 있거나 보의 한쪽 끝부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다. 보는 한쪽 끝부분이 기둥 위에 있거나, 또는 양쪽 끝부분이 다른 보와 동시에 연결되어 있어야 합니다.단, 바닥은 벽면의 맨 아래 지면을 말합니다.2차원 벽면은 n x n크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다.벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 떄, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.책 해답이 문제는 전형적인 시뮬레이션 문제이다. 주어진 구조물을 하나씩 설치, 삭제하면서 해당 구조물이 온전한지, 온전하지 않은지 판단하면서 나아가면 될 것이다.코드def possible(answer): for x, y, stuff in answer: if stuff == 0: # 설치된 것이 &#39;기둥&#39; 인 경우 # 바닥 위 혹은 보의 한쪽 끝 위 혹은 다른 기둥 위라면 정상 if y == 0 or [x - 1, y, 1] in answer or [x, y, 1] in answer or [x, y - 1, 0] in answer: continue return False elif stuff == 1: # 한쪽 끝부분이 기둥 위 혹은 양쪽 끝부분이 다른 보와 동시에 연결 if [x, y - 1, 0] in answer or [x + 1, y - 1, 0] in answer or ([x - 1, y, 1] in answer and [x + 1, y, 1] in answer): continue: return False return Truedef solution(n, bulid_frame): answer = [] for frame in bulid_frame: # 작업(frame)의 개수는 최대 1,000개 x, y, stuff, operate = frame if operate == 0: # 삭제 하는 경우 answer.remove([x, y, stuff]) # 일단 삭제하고 if not possible(answer): # 괜찮은지 확인하고 answer.append([x, y, stuff]) # 안괜찮으면 다시 설치 if operate == 1: # 설치 하는 경우 answer.append([x, y, stuff]) if not possible(answer): answer.remove([x, y, stuff]) # 가능한 구조물이 아니라면 다시 제거 return sorted(answer)" }, { "title": "chapter 12 : 실전 구현 11번 문제(뱀)", "url": "/posts/chapter12-q-11/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-09-24 18:46:30 +0800", "snippet": "문제 : 뱀Dummy 라는 도스 게임이 있습니다. 이 게임에는 뱀이 나와서 기어 다니는데, 사과를 먹으면 뱀의 길이가 늘어납니다. 뱀이 이리저리 기어 다니다가 벽 도는 자기 자신의 몸과 부딪히면 게임이 끝납니다. 게임은 N x N 정사각 보드 위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있습니다. 보드의 상하좌우 끝에는 벽이 있 습니다. 게임을 시작할 때 뱀은 맨 위 맨 좌측에 위차하고 뱀의 길이는 1입니다. 뱀은 처음에 오른쪽을 향합니다. 뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따릅니다. 먼저 뱀은 몸길이를 늘려 머리를 다음 칸에 위치 시킵니다. 만약 이동한 칸에 사과가 있다면 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않습니다. 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워줍니다. 몸길이는 변하지 않습니다.사과의 위치와 뱀의 이동 경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하세요.내 생각뱀의 크기는 큐를 이용하면 좋을 것이라고 생각했다. 먹지못하면 꼬리가 잘리기 때문에 이 부분은 선입 선출인 큐를 이용하면 구현이 가능하다 판단했다. dx, dy를 이용하여 회전하면서 구현하면 할만하다고 본다.내 코드이번에는 풀었기 때문에 내 코드를 공유한다.from collections import deque# map 입력n = int(input())maps = [[0] * (n + 1) for _ in range(n + 1)]# 사과 위치 입력k = int(input())for _ in range(k): a, b = map(int, input().split()) maps[a][b] = 1# 뱀의 이동 입력l = int(input())data = []sum_value = 0for i in range(l): if i: distance, direction = input().split() data.append([int(distance) - sum_value, direction]) sum_value = int(distance) else: distance, direction = input().split() data.append([int(distance) , direction]) sum_value = int(distance)# 마지막 이동은 부딪히기 전까지 무한대이기 때문에 거리를 무한대에 가까운 값으로 설정data.append([int(1e9), &#39;D&#39;])# 북 동 남 서dx, dy = [-1, 0, 1, 0], [0, 1, 0, -1]# 뱀의 진행 방향(dx, dy의 인덱스에 들어간다)dire = 1# 뱀을 큐로 구현snake = deque()# 뱀의 초기 위치snake.append((1, 1))def sol(): global dire count = 0 for d in data: for _ in range(d[0]): count += 1 x, y = snake.pop() nx, ny = x + dx[dire], y + dy[dire] # 벽에 부딪히면 종료 if nx &amp;gt; n + 1 or ny &amp;gt; n + 1 or nx &amp;lt;= 0 or ny &amp;lt;= 0: print(&#39;wall&#39;, nx, ny) return count # 뱀의 몸통에 부딪히면 종료 if (nx, ny) in snake: print(&#39;snake&#39;, nx, ny) return count # 뱀의 이동, 사과 없을 때 if maps[nx][ny] == 0: snake.append((x, y)) snake.append((nx, ny)) snake.popleft() # 사과 있을 때 elif maps[nx][ny] == 1: snake.append((x, y)) snake.append((nx, ny)) print(nx, ny) if d[1] == &#39;D&#39;: dire = (dire + 1) % len(dx) elif d[1] == &#39;L&#39;: dire = (dire + 3) % len(dx)해결법이 문제 또한 전형적인 시뮬레이션 문제 유형으로, 문제에서 요구하는 대로 실수 없이 구현 해낼 수 있다면 정답 판 정을 받을 수 있다. 2차원의 배열상의 맵에서 뱀이 이동하도록 해야하므로 2차원 배열상의 특정 위치에서 동, 남, 서, 북의 위치로 이동하는 기능을 구현해야한다. 이 문제의 경우, 뱀이 처음에 오른쪽을 바로보고 있다는 점을 고려하자. 더불어 뱀의 머리가 뱀의 몸에 닿는 경우에도 종료해야 하므로, 매 시점마다 뱀이 존재하는 위치를 항상 2차원 리스 트에 기록해야한다. 이러한 시뮬레이션 문제 유형은 가장 쉽게 풀기 위해서는 그림으로 그려보는 것이 좋다. 일반적인 코딩 테스트에서는 종이와 펜은 사용할 수 있도록 해주기 때문에, 문제를 보자마자 일단 종이에 자신만의 그림으로 그려보는 것이 좋다.코드n = int(input())k - int(input())data = [[0] * (n + 1) for _ in range(n + 1)] # 맵 정보# 맵 정보(사과 있는 곳은 1로 표시)for _ in range(k): a, b = map(int, input().split()) data[a][b] = 1 # 방향 회전 정보 입력l = int(input())for _ in range(l): x, c = input().split() info.append(int(x), c) # 처음에는 오른쪽을 보고 있으므로(동, 남, 서 ,북) dx = [0, -1, 0, 1] dy = [1, 0, -1, 0] def turn(direction, c): if c == &#39;L&#39;: direction = (direction - 1) % 4 else: direction = (direction + 1) % 4 return direction def simulate(): x, y = 1, 1 # 뱀의 머리 위치 data[x][y] = 2 # 뱀이 존재하는 위치는 2로 표시 direction = 0 # 처음에는 동쪽을 봄 time = 0 # 시간 index = 0 # 다음에 회전할 정보 q = [(x, y)] # 뱀이 차지하고 있는 위치 정보(꼬리가 앞쪽) while True: nx = x + dx[direction] ny = y + dy[direction] # 뱀 범위에 있고, 뱀의 몸통이 없는 위치라면 if 1 &amp;lt;= x and nx &amp;lt;= n and 1 &amp;lt;= ny and ny &amp;lt;= n and data[nx][ny] != 2: # 사과가 없다면 이동 후에 꼬리 제거 if data[nx][ny] == 0: data[nx][ny] = 2 q.append((nx, ny)) px, py = q.pop(0) data[px][py] = 0 # 사과가 있다면 이동 후에 꼬리 그대로 두기 if data[nx][ny] == 1: data[nx][ny] = 2 q.append((nx, ny)) # 벽이나 뱀의 몸통과 부딫혔다면 else: time += 1 break x, y = nx, ny # 다음 위치로 머리를 이동 time += 1 if index &amp;lt; 1 and time == info[index][0]: # 회전일 경우에 회전 direction = turn(direction, info[index][1]) index += 1 return time print(simulate())느낀 점구현 문제 특징 상, 내 코드와 큰 차이는 없으나, deque.popleft 를 이용한 나와는 달리 pop(0)을 통해서 구현했다 는 점이 새롭다. 이전까지 q의 구현은 deque으로 구현하는게 좋다고 배웠는데, 굳이 deque을 쓰지 않고 pop(0)을 쓰면 되는 점에 또 배웠다." }, { "title": "chapter 12 : 실전 구현 10번 문제(자물쇠와 열쇠)", "url": "/posts/chapter12-q-10/", "categories": "algorithm, python", "tags": "algorithm", "date": "2020-09-23 18:31:29 +0800", "snippet": "문제고고학자인 튜브는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열로고 살펴버니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법 에 대해 다음과 같이 설명해주는 종이가 발견되었습니다.잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다.자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다.열쇠를 나타내기 위한 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개 변수로 주어질 때, 열쇠로 자물쇠를 열 수 있으면 true, 없으면 false를 return 하도록 solution 함수를 완성해주세요.내 생각이 문제는 완전 탐색을 통해서 모든 경우의 수를 조사해야 한다는 생각에는 도달했다. 하지만 돌리고 옮기는 방식을 어떻게 하면 완전 탐색으로 구현해야 할 지 몰라서 결국 풀지 못했던 문제이다. 문제 해결 방식의 기초 포인트는 이해 했으나, 결국은 풀지 못했다.해결법동빈님의 솔루션을 그대로 참고하겠다.우리가 해야 할 일은 열쇠를 적당히 회전하고 이동시켜 자물쇠의 홈에 딱 맞게 끼워 넣는 것이다. 이 문제를 해결하기 위해서 얼마나 효율적인 알고리즘을 작성해야 하는지 고려해보자. 일단 문제에서 제시한 자물쇠와 원소의 크기는 20 x 20 보다 작다. 크기가 20 x 20인 2차원 리스트에 있는 모든 원소에 접근할 때는 400만큼의 연산이 필요할 것이다.교재에서 언급했듯이 파이썬의 경우 일반적인 코딩 테스트 채점 환경에서 1초에 2,000만에서 1억정도의 연산을 처리할 수 있다. 그렇기 때문에, 완전 탐색을 이용해서 열쇠를 이동이나 회전시켜서 자물쇠에 끼워보는 작업을 전부 시도해보는 접근 방법을 이용할 수 있다.다시 말해 문제 해결 아이디어는 완전 탐색이다. 다만, 완전 탐색을 수원하게 하기 위해서 자물쇠 리스트의 크기를3배 이상으로 변경하면 계산이 수월해진다. 예를 들어 열쇠와 자물쇠가 이렇게 3 x 3 크기라고 가정하자. 이때 가장먼저 자물쇠를 크기가 3배인 새로운 리스트로 만들어 중앙 부분으로 옮긴다.이제 열쇠 배열을 왼쪽 위부터 시작해서 한 칸씩 이동하는 방식으로 차례대로 자물쇠의 모든 홈을 채울 수 있는지 확인하면 된다. 문제에서는 0은 홈 부분, 1은 돌기 부분을 나타낸다. 따라서 자물쇠 리스트에 열쇠 리스트의 값을 더한 뒤에, 더한 결과를 확인했을 때 자물쇠 부분의 모든 값이 정확히 1인지를 확인하면 된다. 만약 모든 값이 정확히 1이라면 자물쇠의 홈 부분을 정확히 채운 것이라고 할 수 있다.코드# 이 코드는 프로그래머스 사이트에서 태스트해야 정상 동작한다.# 2차원 리스트 90도 회전def rotate_a_matrix_by_90_degrees(a): n = len(a) # 행 길이 계산 m = len(a[0]) # 열 길이 계산 result = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): result[j][n - i - 1] = a[i][j] # 열의 번호는 바뀜 return result# 자물쇠의 중간 부분이 모두 1인지 확인def check(new_lock): lock_length = len(new_lock) // 3 for i in range(lock_length, lock_length * 2): for j in range(lock_length, lock_length * 2): if new_lock[i][j] != 1: return False return Truedef solution(key, lock): n = len(lock) m = len(key) new_lock = [[0] * (n * 3) for _ in range(n * 3)] # 새로운 자물쇠의 중앙 부분에 기존의 자물쇠 넣기 for i in range(n): for j in range(n): new_lock[i + n][j + n] = lock[i][j] # 4가지 방향에 대해서 확인 for rotation in range(4): key = rotate_a_matrix_by_90_degree(key): for x in range(n * 2): for y in range(n * 2): # 자물쇠에 열쇠를 끼워 넣기 for i in range(m): for j in range(m): new_lock[x + i][y + i] += key[i][j] # 자물쇠 검사 if check(new_lock) == True: return True for i in range(m): for j in range(m): new_lock[x + i][y + j] -= key[i][j] return False느낀 점완전 탐색이니 무식하게 한번 돌리고 다 비교하고 돌리고 다 비교하고 이러면 되는걸 너무 깊게 생각한 것 같다. 알고리즘 문제를 풀면서 항상 느끼는 것은 너무 잘하려고 하면 머리가 너무 복잡해져서 평소의 퍼포먼스보다도 못한 결과가 나온다는 점이다. 머리 속은 비우고, 할 수 있는 것에만 집중하는 습관을 들여야겠다." } ]
